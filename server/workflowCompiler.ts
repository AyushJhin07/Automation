// WORKFLOW COMPILER - NodeGraph to Google Apps Script Code Generation
// Based on ChatGPT's compiler architecture with real code generation

import { NodeGraph, CodeFile, GraphNode } from '../shared/nodeGraphSchema';
import { EnhancedNodeCatalog } from './enhancedNodeCatalog';

export class WorkflowCompiler {
  private nodeCatalog: EnhancedNodeCatalog;

  constructor() {
    this.nodeCatalog = EnhancedNodeCatalog.getInstance();
  }

  public async compileWorkflow(graph: NodeGraph): Promise<{ files: CodeFile[]; entry: string }> {
    console.log('ðŸ”¨ Compiling NodeGraph to Google Apps Script:', graph.name);

    const files: CodeFile[] = [];

    // 1. Generate main orchestration file
    files.push(this.generateMainOrchestration(graph));

    // 2. Generate helper files
    files.push(this.generateRuntimeHelpers());
    files.push(this.generateStorageHelpers());
    files.push(this.generateHttpHelpers());

    // 3. Generate OAuth2 helpers if needed
    if (this.requiresOAuth2(graph)) {
      files.push(this.generateOAuth2Helpers());
    }

    // 4. Generate Apps Script manifest
    files.push(this.generateManifest(graph));

    // 5. Generate README with deployment instructions
    files.push(this.generateReadme(graph));

    console.log('âœ… Compiled workflow into', files.length, 'files');

    return {
      files,
      entry: 'Code.js'
    };
  }

  private generateMainOrchestration(graph: NodeGraph): CodeFile {
    const sortedNodes = this.topologicalSort(graph);
    
    let code = `/**
 * ${graph.name}
 * Generated by AI Workflow Builder
 * 
 * ${graph.metadata?.description || 'Automated workflow'}
 */

// Main workflow orchestration function
function run_graph_(payload) {
  var state = { ctx: {}, data: payload || {} };
  var startTime = new Date();
  
  console.log(JSON.stringify({
    ts: startTime.toISOString(),
    event: 'workflow_start',
    workflow: '${graph.id}',
    payload: payload
  }));
  
  try {
`;

    // Generate node execution calls in topological order
    sortedNodes.forEach(nodeId => {
      const node = graph.nodes.find(n => n.id === nodeId);
      if (node) {
        code += `    // Execute ${node.label}\n`;
        code += `    state = node_${node.id.replace(/[^a-zA-Z0-9]/g, '_')}(state);\n`;
        code += `    console.log(JSON.stringify({ ts: new Date().toISOString(), node: '${node.id}', status: 'completed' }));\n\n`;
      }
    });

    code += `    var endTime = new Date();
    console.log(JSON.stringify({
      ts: endTime.toISOString(),
      event: 'workflow_complete',
      workflow: '${graph.id}',
      duration_ms: endTime.getTime() - startTime.getTime()
    }));
    
    return state.data;
  } catch (e) {
    console.error(JSON.stringify({
      ts: new Date().toISOString(),
      event: 'workflow_error',
      workflow: '${graph.id}',
      error: e.message,
      stack: e.stack
    }));
    throw e;
  }
}

`;

    // Generate individual node functions
    graph.nodes.forEach(node => {
      code += this.generateNodeFunction(node, graph);
      code += '\n';
    });

    // Generate trigger setup functions
    code += this.generateTriggerSetup(graph);

    return {
      path: 'Code.js',
      content: code
    };
  }

  private generateNodeFunction(node: GraphNode, graph: NodeGraph): string {
    const catalog = this.nodeCatalog.getNodeCatalog();
    const allNodeTypes = { ...catalog.triggers, ...catalog.transforms, ...catalog.actions };
    const nodeType = allNodeTypes[node.type];
    
    if (!nodeType) {
      return `// ERROR: Unknown node type ${node.type}`;
    }

    const functionName = `node_${node.id.replace(/[^a-zA-Z0-9]/g, '_')}`;
    
    let functionCode = `/**
 * ${node.label} (${node.type})
 * ${nodeType.description}
 */
function ${functionName}(state) {
  try {
`;

    // Generate function body based on node type
    if (node.type.startsWith('trigger.')) {
      functionCode += this.generateTriggerNodeCode(node, nodeType);
    } else if (node.type.startsWith('transform.')) {
      functionCode += this.generateTransformNodeCode(node, nodeType);
    } else if (node.type.startsWith('action.')) {
      functionCode += this.generateActionNodeCode(node, nodeType);
    }

    functionCode += `    return state;
  } catch (e) {
    console.error('Node ${node.id} failed:', e.message);
    throw new Error('Node ${node.id} (${node.label}) failed: ' + e.message);
  }
}`;

    return functionCode;
  }

  private generateTriggerNodeCode(node: GraphNode, nodeType: any): string {
    switch (node.type) {
      case 'trigger.time.cron':
        return `    // Time-based trigger - handled by Apps Script triggers
    state.data.triggerTime = new Date().toISOString();
    state.data.triggerType = 'cron';
`;

      case 'trigger.webhook.inbound':
        return `    // Webhook trigger - handled by doPost function
    state.data.webhookData = state.data.webhook || {};
    state.data.triggerType = 'webhook';
`;

      case 'trigger.gmail.new_email':
        return this.generateGmailTriggerCode(node);

      case 'trigger.sheets.new_row':
        return this.generateSheetsTriggerCode(node);

      default:
        if (node.type.includes('trigger.')) {
          return this.generateGenericTriggerCode(node);
        }
        return '    // Unknown trigger type\n';
    }
  }

  private generateTransformNodeCode(node: GraphNode, nodeType: any): string {
    switch (node.type) {
      case 'transform.filter.expr':
        return `    // Filter data based on expression
    var expression = ${JSON.stringify(node.params.expression)};
    var items = state.data.items || [];
    var filteredItems = items.filter(function(item, index) {
      try {
        // Safe evaluation context
        var ctx = state.ctx;
        return eval('(function(item, ctx) { return ' + expression + '; })')(item, ctx);
      } catch (e) {
        console.warn('Filter expression failed for item', index, ':', e.message);
        return false;
      }
    });
    state.data.items = filteredItems;
    state.data.filteredCount = filteredItems.length;
`;

      case 'transform.text.extract_regex':
        return `    // Extract text using regex
    var source = ${JSON.stringify(node.params.source)};
    var pattern = ${JSON.stringify(node.params.pattern)};
    var flags = ${JSON.stringify(node.params.flags || 'g')};
    
    var sourceText = getNestedValue_(state.data, source) || '';
    var regex = new RegExp(pattern, flags);
    var matches = sourceText.match(regex);
    
    state.data.extractedText = matches ? matches[0] : '';
    state.data.allMatches = matches || [];
`;

      case 'transform.template.interpolate':
        return `    // Interpolate template with data
    var template = ${JSON.stringify(node.params.template)};
    var bindings = ${JSON.stringify(node.params.bindings || {})};
    
    // Merge state data with bindings
    var templateData = Object.assign({}, state.data, bindings);
    
    // Simple template interpolation
    var result = template.replace(/\\{\\{([^}]+)\\}\\}/g, function(match, path) {
      return getNestedValue_(templateData, path.trim()) || match;
    });
    
    state.data.templatedText = result;
`;

      case 'transform.json.path':
        return `    // Extract JSON field using path
    var source = ${JSON.stringify(node.params.source)};
    var path = ${JSON.stringify(node.params.path)};
    
    var sourceData = getNestedValue_(state.data, source);
    var extractedValue = getNestedValue_(sourceData, path);
    
    state.data.extractedValue = extractedValue;
`;

      default:
        return '    // Unknown transform type\n';
    }
  }

  private generateActionNodeCode(node: GraphNode, nodeType: any): string {
    switch (node.type) {
      case 'action.gmail.send':
        return this.generateGmailSendCode(node);

      case 'action.sheets.append_row':
        return this.generateSheetsAppendCode(node);

      case 'action.calendar.create_event':
        return this.generateCalendarCreateCode(node);

      case 'action.http.request':
        return this.generateHttpRequestCode(node);

      default:
        if (node.type.includes('action.')) {
          return this.generateGenericActionCode(node);
        }
        return '    // Unknown action type\n';
    }
  }

  private generateGmailTriggerCode(node: GraphNode): string {
    return `    // Gmail new email trigger
    var query = ${JSON.stringify(node.params.query)};
    var watchLabel = ${JSON.stringify(node.params.watchLabel || '')};
    
    // Get emails matching query (polling implementation)
    var threads = GmailApp.search(query, 0, 50);
    var newEmails = [];
    
    threads.forEach(function(thread) {
      var messages = thread.getMessages();
      var lastMessage = messages[messages.length - 1];
      
      // Check if we've seen this message before
      var messageId = lastMessage.getId();
      if (!seen_('gmail_' + messageId)) {
        newEmails.push({
          id: messageId,
          subject: lastMessage.getSubject(),
          from: lastMessage.getFrom(),
          to: lastMessage.getTo(),
          body: lastMessage.getPlainBody(),
          date: lastMessage.getDate().toISOString(),
          threadId: thread.getId()
        });
        markSeen_('gmail_' + messageId);
      }
    });
    
    state.data.newEmails = newEmails;
    state.data.emailCount = newEmails.length;
`;
  }

  private generateSheetsTriggerCode(node: GraphNode): string {
    return `    // Google Sheets new row trigger
    var spreadsheetId = ${JSON.stringify(node.params.spreadsheetId)};
    var sheetName = ${JSON.stringify(node.params.sheetName)};
    
    var spreadsheet = SpreadsheetApp.openById(spreadsheetId);
    var sheet = spreadsheet.getSheetByName(sheetName);
    
    if (!sheet) {
      throw new Error('Sheet not found: ' + sheetName);
    }
    
    var lastRow = sheet.getLastRow();
    var lastProcessedRow = parseInt(getStore_().getProperty('sheets_last_row_' + spreadsheetId + '_' + sheetName) || '1');
    
    var newRows = [];
    if (lastRow > lastProcessedRow) {
      var range = sheet.getRange(lastProcessedRow + 1, 1, lastRow - lastProcessedRow, sheet.getLastColumn());
      var values = range.getValues();
      
      values.forEach(function(row, index) {
        newRows.push({
          rowNumber: lastProcessedRow + index + 1,
          values: row,
          timestamp: new Date().toISOString()
        });
      });
      
      getStore_().setProperty('sheets_last_row_' + spreadsheetId + '_' + sheetName, lastRow.toString());
    }
    
    state.data.newRows = newRows;
    state.data.rowCount = newRows.length;
`;
  }

  private generateGenericTriggerCode(node: GraphNode): string {
    const appName = node.type.split('.')[1];
    return `    // Generic ${appName} trigger
    var params = ${JSON.stringify(node.params)};
    
    // Polling-based trigger implementation
    var lastCheck = getStore_().getProperty('${node.id}_last_check') || '0';
    var currentTime = new Date().getTime();
    var intervalMs = (params.intervalMinutes || 15) * 60 * 1000;
    
    if (currentTime - parseInt(lastCheck) < intervalMs) {
      state.data.triggerResult = { skipped: true, reason: 'interval_not_reached' };
      return state;
    }
    
    // Make API call to check for new data
    var endpoint = params.endpoint || 'https://api.${appName.toLowerCase()}.com/check';
    var response = fetchJson_({
      method: 'GET',
      url: endpoint,
      headers: { 'Authorization': 'Bearer ' + getSecret_('${appName.toUpperCase()}_ACCESS_TOKEN') }
    });
    
    state.data.triggerResult = response;
    getStore_().setProperty('${node.id}_last_check', currentTime.toString());
`;
  }

  private generateGmailSendCode(node: GraphNode): string {
    return `    // Send Gmail email
    var to = interpolateValue_(${JSON.stringify(node.params.to)}, state.data);
    var subject = interpolateValue_(${JSON.stringify(node.params.subject)}, state.data);
    var bodyText = interpolateValue_(${JSON.stringify(node.params.bodyText || '')}, state.data);
    var bodyHtml = interpolateValue_(${JSON.stringify(node.params.bodyHtml || '')}, state.data);
    var cc = interpolateValue_(${JSON.stringify(node.params.cc || '')}, state.data);
    var bcc = interpolateValue_(${JSON.stringify(node.params.bcc || '')}, state.data);
    
    var options = {};
    if (cc) options.cc = cc;
    if (bcc) options.bcc = bcc;
    if (bodyHtml) options.htmlBody = bodyHtml;
    
    var result = GmailApp.sendEmail(to, subject, bodyText, options);
    
    state.data.emailSent = {
      to: to,
      subject: subject,
      timestamp: new Date().toISOString(),
      success: true
    };
`;
  }

  private generateSheetsAppendCode(node: GraphNode): string {
    return `    // Append row to Google Sheets
    var spreadsheetId = interpolateValue_(${JSON.stringify(node.params.spreadsheetId)}, state.data);
    var sheetName = interpolateValue_(${JSON.stringify(node.params.sheetName)}, state.data);
    var values = ${JSON.stringify(node.params.values)};
    
    // Interpolate values with state data
    var interpolatedValues = values.map(function(value) {
      return interpolateValue_(value, state.data);
    });
    
    var spreadsheet = SpreadsheetApp.openById(spreadsheetId);
    var sheet = spreadsheet.getSheetByName(sheetName);
    
    if (!sheet) {
      throw new Error('Sheet not found: ' + sheetName);
    }
    
    sheet.appendRow(interpolatedValues);
    
    state.data.rowAppended = {
      spreadsheetId: spreadsheetId,
      sheetName: sheetName,
      values: interpolatedValues,
      timestamp: new Date().toISOString()
    };
`;
  }

  private generateCalendarCreateCode(node: GraphNode): string {
    return `    // Create Google Calendar event
    var calendarId = interpolateValue_(${JSON.stringify(node.params.calendarId || 'primary')}, state.data);
    var title = interpolateValue_(${JSON.stringify(node.params.title)}, state.data);
    var start = interpolateValue_(${JSON.stringify(node.params.start)}, state.data);
    var end = interpolateValue_(${JSON.stringify(node.params.end)}, state.data);
    var description = interpolateValue_(${JSON.stringify(node.params.description || '')}, state.data);
    var attendees = ${JSON.stringify(node.params.attendees || [])};
    
    var startDate = new Date(start);
    var endDate = new Date(end);
    
    var calendar = CalendarApp.getCalendarById(calendarId) || CalendarApp.getDefaultCalendar();
    var event = calendar.createEvent(title, startDate, endDate, {
      description: description,
      guests: attendees.join(',')
    });
    
    state.data.eventCreated = {
      eventId: event.getId(),
      title: title,
      start: start,
      end: end,
      calendarId: calendarId,
      timestamp: new Date().toISOString()
    };
`;
  }

  private generateHttpRequestCode(node: GraphNode): string {
    return `    // HTTP Request
    var method = ${JSON.stringify(node.params.method)};
    var url = interpolateValue_(${JSON.stringify(node.params.url)}, state.data);
    var headers = ${JSON.stringify(node.params.headers || {})};
    var body = ${JSON.stringify(node.params.body)};
    var timeoutSec = ${JSON.stringify(node.params.timeoutSec || 30)};
    
    // Interpolate headers and body
    Object.keys(headers).forEach(function(key) {
      headers[key] = interpolateValue_(headers[key], state.data);
    });
    
    if (body && typeof body === 'object') {
      body = JSON.stringify(body);
    } else if (body) {
      body = interpolateValue_(body, state.data);
    }
    
    var response = fetchJson_({
      method: method,
      url: url,
      headers: headers,
      body: body,
      timeoutSec: timeoutSec
    });
    
    state.data.httpResponse = response;
    state.data['${node.id}'] = response;
`;
  }

  private generateGenericActionCode(node: GraphNode): string {
    const appName = node.type.split('.')[1];
    const actionName = node.type.split('.')[2];
    
    return `    // Generic ${appName} ${actionName} action
    var params = ${JSON.stringify(node.params)};
    
    // Interpolate all parameters
    Object.keys(params).forEach(function(key) {
      if (typeof params[key] === 'string') {
        params[key] = interpolateValue_(params[key], state.data);
      }
    });
    
    // Make API call
    var endpoint = 'https://api.${appName.toLowerCase()}.com/${actionName}';
    var response = fetchJson_({
      method: 'POST',
      url: endpoint,
      headers: {
        'Authorization': 'Bearer ' + getSecret_('${appName.toUpperCase()}_ACCESS_TOKEN'),
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(params)
    });
    
    state.data.${actionName}Result = response;
    state.data['${node.id}'] = response;
`;
  }

  private generateTriggerSetup(graph: NodeGraph): string {
    let code = `
// Trigger setup functions
`;

    const triggerNodes = graph.nodes.filter(node => node.type.startsWith('trigger.'));
    
    triggerNodes.forEach(node => {
      if (node.type === 'trigger.time.cron') {
        code += this.generateCronTriggerSetup(node);
      } else if (node.type === 'trigger.webhook.inbound') {
        code += this.generateWebhookSetup(node);
      }
    });

    // Add webhook handler if needed
    const hasWebhook = triggerNodes.some(node => node.type === 'trigger.webhook.inbound');
    if (hasWebhook) {
      code += `
/**
 * Webhook handler for incoming HTTP requests
 */
function doPost(e) {
  try {
    var payload = {};
    if (e.postData && e.postData.contents) {
      payload = JSON.parse(e.postData.contents);
    }
    payload.webhook = {
      headers: e.parameter,
      timestamp: new Date().toISOString()
    };
    
    var result = run_graph_(payload);
    
    return ContentService
      .createTextOutput(JSON.stringify({ success: true, result: result }))
      .setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    return ContentService
      .createTextOutput(JSON.stringify({ success: false, error: error.message }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}`;
    }

    return code;
  }

  private generateCronTriggerSetup(node: GraphNode): string {
    return `
/**
 * Setup cron trigger for ${node.label}
 */
function setupCronTrigger_${node.id.replace(/[^a-zA-Z0-9]/g, '_')}() {
  // Delete existing triggers
  ScriptApp.getProjectTriggers().forEach(function(trigger) {
    if (trigger.getHandlerFunction() === 'run_graph_') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  
  // Create new trigger
  var trigger = ScriptApp.newTrigger('run_graph_');
  
  ${node.params.everyMinutes ? `trigger.timeBased().everyMinutes(${node.params.everyMinutes});` : ''}
  ${node.params.everyHours ? `trigger.timeBased().everyHours(${node.params.everyHours});` : ''}
  ${node.params.cron ? `// Custom cron: ${node.params.cron} (implement with time-based trigger)` : ''}
  
  trigger.create();
  console.log('Cron trigger created for ${node.label}');
}`;
  }

  private generateWebhookSetup(node: GraphNode): string {
    return `
/**
 * Setup webhook trigger for ${node.label}
 */
function setupWebhookTrigger_${node.id.replace(/[^a-zA-Z0-9]/g, '_')}() {
  // Webhook URL will be available after deployment
  console.log('Webhook endpoint: ' + ScriptApp.getService().getUrl());
  console.log('Webhook path: ${node.params.path}');
}`;
  }

  private generateRuntimeHelpers(): CodeFile {
    return {
      path: 'helpers/runtime.js',
      content: `/**
 * Runtime helper functions
 */

/**
 * Get nested value from object using dot notation
 */
function getNestedValue_(obj, path) {
  if (!obj || !path) return undefined;
  
  return path.split('.').reduce(function(current, key) {
    return current && current[key] !== undefined ? current[key] : undefined;
  }, obj);
}

/**
 * Interpolate template string with data
 */
function interpolateValue_(template, data) {
  if (typeof template !== 'string') return template;
  
  return template.replace(/\\{\\{([^}]+)\\}\\}/g, function(match, path) {
    var value = getNestedValue_(data, path.trim());
    return value !== undefined ? value : match;
  });
}

/**
 * Safe JSON parsing
 */
function safeJsonParse_(text, defaultValue) {
  try {
    return JSON.parse(text);
  } catch (e) {
    console.warn('JSON parse failed:', e.message);
    return defaultValue || {};
  }
}

/**
 * Get secret from PropertiesService
 */
function getSecret_(key) {
  return PropertiesService.getScriptProperties().getProperty(key) || '';
}

/**
 * Set secret in PropertiesService
 */
function setSecret_(key, value) {
  PropertiesService.getScriptProperties().setProperty(key, value);
}
`
    };
  }

  private generateStorageHelpers(): CodeFile {
    return {
      path: 'helpers/storage.js',
      content: `/**
 * Storage helper functions for state management
 */

/**
 * Get PropertiesService store
 */
function getStore_() {
  return PropertiesService.getScriptProperties();
}

/**
 * Check if we've seen this item before (deduplication)
 */
function seen_(key) {
  return getStore_().getProperty('seen_' + key) === '1';
}

/**
 * Mark item as seen
 */
function markSeen_(key) {
  getStore_().setProperty('seen_' + key, '1');
}

/**
 * Get last processed timestamp
 */
function getLastProcessed_(key) {
  return getStore_().getProperty('last_' + key) || '0';
}

/**
 * Set last processed timestamp
 */
function setLastProcessed_(key, timestamp) {
  getStore_().setProperty('last_' + key, timestamp.toString());
}

/**
 * Clear all stored state (use with caution)
 */
function clearAllState_() {
  getStore_().deleteAllProperties();
  console.log('All stored state cleared');
}
`
    };
  }

  private generateHttpHelpers(): CodeFile {
    return {
      path: 'helpers/http.js',
      content: `/**
 * HTTP helper functions with retry and error handling
 */

/**
 * Make HTTP request with JSON response
 */
function fetchJson_(options) {
  var maxRetries = 3;
  var retryDelay = 1000; // 1 second
  
  for (var attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      var response = makeHttpRequest_(options);
      
      if (response.status >= 200 && response.status < 300) {
        return response;
      } else if (response.status >= 500 && attempt < maxRetries) {
        // Server error - retry
        console.warn('HTTP request failed (attempt ' + attempt + '), retrying:', response.status);
        Utilities.sleep(retryDelay * attempt);
        continue;
      } else {
        // Client error or final attempt - throw
        throw new Error('HTTP request failed: ' + response.status + ' - ' + response.body);
      }
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }
      console.warn('HTTP request error (attempt ' + attempt + '), retrying:', error.message);
      Utilities.sleep(retryDelay * attempt);
    }
  }
}

/**
 * Make raw HTTP request
 */
function makeHttpRequest_(options) {
  var url = options.url;
  var method = options.method || 'GET';
  var headers = options.headers || {};
  var body = options.body;
  var timeoutSec = options.timeoutSec || 30;
  
  var params = {
    method: method,
    headers: headers,
    muteHttpExceptions: true
  };
  
  if (body && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
    params.payload = typeof body === 'string' ? body : JSON.stringify(body);
  }
  
  var response = UrlFetchApp.fetch(url, params);
  var responseCode = response.getResponseCode();
  var responseBody = response.getContentText();
  
  // Try to parse JSON response
  var parsedBody;
  try {
    parsedBody = JSON.parse(responseBody);
  } catch (e) {
    parsedBody = responseBody;
  }
  
  return {
    status: responseCode,
    body: parsedBody,
    headers: response.getHeaders(),
    raw: responseBody
  };
}
`
    };
  }

  private generateOAuth2Helpers(): CodeFile {
    return {
      path: 'helpers/oauth2.js',
      content: `/**
 * OAuth2 helper functions for external service authentication
 */

/**
 * Get OAuth2 service for external APIs
 */
function getService_(serviceName) {
  return OAuth2.createService(serviceName)
    .setAuthorizationBaseUrl('https://accounts.google.com/oauth/authorize')
    .setTokenUrl('https://accounts.google.com/oauth/token')
    .setClientId(getSecret_(serviceName.toUpperCase() + '_CLIENT_ID'))
    .setClientSecret(getSecret_(serviceName.toUpperCase() + '_CLIENT_SECRET'))
    .setCallbackFunction('authCallback')
    .setPropertyStore(PropertiesService.getScriptProperties());
}

/**
 * OAuth2 callback handler
 */
function authCallback(request) {
  var service = getService_('default');
  var authorized = service.handleCallback(request);
  if (authorized) {
    return HtmlService.createHtmlOutput('Success! You can close this tab.');
  } else {
    return HtmlService.createHtmlOutput('Denied. You can close this tab');
  }
}

/**
 * Get authorization URL for OAuth2 flow
 */
function getAuthorizationUrl_(serviceName) {
  var service = getService_(serviceName);
  if (service.hasAccess()) {
    console.log('Already authorized for ' + serviceName);
    return null;
  } else {
    var authorizationUrl = service.getAuthorizationUrl();
    console.log('Visit this URL to authorize ' + serviceName + ': ' + authorizationUrl);
    return authorizationUrl;
  }
}
`
    };
  }

  private generateManifest(graph: NodeGraph): CodeFile {
    return {
      path: 'appsscript.json',
      content: JSON.stringify({
        timeZone: "America/New_York",
        exceptionLogging: "STACKDRIVER",
        runtimeVersion: "V8",
        oauthScopes: graph.scopes,
        webapp: {
          access: "ANYONE_ANONYMOUS",
          executeAs: "USER_DEPLOYING"
        }
      }, null, 2)
    };
  }

  private generateReadme(graph: NodeGraph): CodeFile {
    const triggerNodes = graph.nodes.filter(n => n.type.startsWith('trigger.'));
    const hasWebhook = triggerNodes.some(n => n.type === 'trigger.webhook.inbound');
    const hasCron = triggerNodes.some(n => n.type === 'trigger.time.cron');

    return {
      path: 'README.md',
      content: `# ${graph.name}

${graph.metadata?.description || 'Automated workflow generated by AI Workflow Builder'}

## Deployment Instructions

### 1. Create Apps Script Project
1. Go to [script.google.com](https://script.google.com)
2. Create a new project
3. Replace the default Code.gs content with the generated code

### 2. Add Helper Files
Copy all files from the \`helpers/\` directory to your Apps Script project:
- helpers/runtime.js
- helpers/storage.js  
- helpers/http.js
${this.requiresOAuth2(graph) ? '- helpers/oauth2.js' : ''}

### 3. Update Manifest
Replace the appsscript.json content with the generated manifest.

### 4. Set Required Secrets
In Apps Script Editor, go to Project Settings â†’ Script Properties and add:

${graph.secrets.map(secret => `- \`${secret}\`: Your ${secret.toLowerCase().replace(/_/g, ' ')}`).join('\n')}

### 5. Required OAuth Scopes
This automation requires the following permissions:
${graph.scopes.map(scope => `- ${scope}`).join('\n')}

### 6. Setup Triggers

${hasCron ? `#### Time-based Triggers
Run the setup function in Apps Script Editor:
\`\`\`javascript
${triggerNodes.filter(n => n.type === 'trigger.time.cron').map(n => 
  `setupCronTrigger_${n.id.replace(/[^a-zA-Z0-9]/g, '_')}();`
).join('\n')}
\`\`\`
` : ''}

${hasWebhook ? `#### Webhook Setup
1. Deploy as web app (Execute as: User deploying, Access: Anyone)
2. Copy the web app URL
3. Configure your external service to send webhooks to this URL

Example webhook URL: \`https://script.google.com/macros/s/{SCRIPT_ID}/exec\`
` : ''}

### 7. Test the Workflow
Run the main function manually to test:
\`\`\`javascript
run_graph_({});
\`\`\`

## Workflow Structure

**Nodes:** ${graph.nodes.length}
**Triggers:** ${triggerNodes.length}
**Actions:** ${graph.nodes.filter(n => n.type.startsWith('action.')).length}
**Transforms:** ${graph.nodes.filter(n => n.type.startsWith('transform.')).length}

**Estimated Value:** ${graph.metadata?.estimatedValue || 'Significant time savings'}
**Complexity:** ${graph.metadata?.complexity || 'Medium'}

## Support
Generated by AI Workflow Builder - For support, contact your system administrator.
`
    };
  }

  private requiresOAuth2(graph: NodeGraph): boolean {
    return graph.nodes.some(node => 
      node.type.includes('slack') || 
      node.type.includes('salesforce') ||
      node.type.includes('hubspot') ||
      !node.type.includes('google') && !node.type.includes('builtin')
    );
  }

  private topologicalSort(graph: NodeGraph): string[] {
    const nodeIds = graph.nodes.map(n => n.id);
    const adjacencyList = new Map<string, string[]>();
    const inDegree = new Map<string, number>();

    // Initialize
    nodeIds.forEach(id => {
      adjacencyList.set(id, []);
      inDegree.set(id, 0);
    });

    // Build adjacency list and in-degree count
    graph.edges.forEach(edge => {
      const fromList = adjacencyList.get(edge.from) || [];
      fromList.push(edge.to);
      adjacencyList.set(edge.from, fromList);

      const currentInDegree = inDegree.get(edge.to) || 0;
      inDegree.set(edge.to, currentInDegree + 1);
    });

    // Kahn's algorithm
    const queue: string[] = [];
    const result: string[] = [];

    // Find nodes with no incoming edges
    nodeIds.forEach(id => {
      if ((inDegree.get(id) || 0) === 0) {
        queue.push(id);
      }
    });

    while (queue.length > 0) {
      const current = queue.shift()!;
      result.push(current);

      const neighbors = adjacencyList.get(current) || [];
      neighbors.forEach(neighbor => {
        const newInDegree = (inDegree.get(neighbor) || 0) - 1;
        inDegree.set(neighbor, newInDegree);

        if (newInDegree === 0) {
          queue.push(neighbor);
        }
      });
    }

    return result;
  }
}