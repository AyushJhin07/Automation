import { CompileResult, WorkflowGraph, WorkflowNode } from '../../common/workflow-types';

export function compileToAppsScript(graph: WorkflowGraph): CompileResult {
  const triggers   = graph.nodes.filter(n => n.type === 'trigger').length;
  const actions    = graph.nodes.filter(n => n.type === 'action').length;
  const transforms = graph.nodes.filter(n => n.type === 'transform').length;

  const code = emitCode(graph);
  const manifest = emitManifest(graph);

  return {
    workflowId: graph.id,
    graph,
    stats: { nodes: graph.nodes.length, triggers, actions, transforms },
    files: [
      { path: 'Code.gs',        content: code },
      { path: 'appsscript.json', content: manifest },
    ],
  };
}

function emitManifest(graph: WorkflowGraph): string {
  // Collect all required scopes from the graph nodes
  const requiredScopes = new Set<string>([
    'https://www.googleapis.com/auth/script.external_request' // Always needed for external APIs
  ]);

  // Add scopes based on node types and apps
  graph.nodes.forEach(node => {
    if (node.app === 'gmail') {
      requiredScopes.add('https://www.googleapis.com/auth/gmail.modify');
    }
    if (node.app === 'sheets') {
      requiredScopes.add('https://www.googleapis.com/auth/spreadsheets');
    }
    if (node.app === 'calendar') {
      requiredScopes.add('https://www.googleapis.com/auth/calendar');
    }
    if (node.app === 'drive') {
      requiredScopes.add('https://www.googleapis.com/auth/drive');
    }
    if (node.app === 'slack') {
      // Slack uses external requests, already covered
    }
    if (node.app === 'dropbox') {
      // Dropbox uses external requests, already covered
    }
  });

  return JSON.stringify({
    timeZone: 'Etc/UTC',
    exceptionLogging: 'STACKDRIVER',
    oauthScopes: Array.from(requiredScopes),
  }, null, 2);
}

function emitCode(graph: WorkflowGraph): string {
  console.log(`üîß Walking graph with ${graph.nodes.length} nodes and ${graph.edges.length} edges`);
  
  // Analyze the graph structure
  const triggerNodes = graph.nodes.filter(n => n.type === 'trigger');
  const actionNodes = graph.nodes.filter(n => n.type === 'action');
  const transformNodes = graph.nodes.filter(n => n.type === 'transform');
  
  console.log(`üìä Graph analysis: ${triggerNodes.length} triggers, ${actionNodes.length} actions, ${transformNodes.length} transforms`);
  
  // Generate code by walking execution path
  let codeBlocks: string[] = [];
  
  // Add header
  codeBlocks.push(`
/**
 * Generated by Apps Script Studio - Intelligent Workflow
 * Prompt: ${graph.meta?.prompt || 'Automated workflow'}
 * Nodes: ${graph.nodes.length} | Edges: ${graph.edges.length}
 * Automation Type: ${graph.meta?.automationType || 'generic'}
 */`);
  
  // Generate main function
  codeBlocks.push(generateMainFunction(graph));
  
  // Generate trigger setup if needed
  if (triggerNodes.some(t => t.op.includes('time') || t.op.includes('schedule'))) {
    codeBlocks.push(generateTriggerSetup(triggerNodes));
  }
  
  // Generate helper functions for each node type
  codeBlocks.push(...generateNodeFunctions(graph.nodes));
  
  return codeBlocks.join('\n\n');
}

function generateMainFunction(graph: WorkflowGraph): string {
  // Build execution flow based on graph edges
  const executionOrder = buildExecutionOrder(graph);
  
  let code = `
function main() {
  console.log('üöÄ Starting intelligent workflow...');
  
  try {
    let workflowData = {};
    
    // Execute workflow nodes in order (synchronous style for Apps Script)
${executionOrder.map((nodeId, index) => {
  const node = graph.nodes.find(n => n.id === nodeId);
  if (!node) return '';
  
  const indent = '    ';
  if (index === 0) {
    return `${indent}// ${node.name || node.op}
${indent}workflowData = execute${capitalizeFirst(node.op.split('.').pop() || 'Node')}(${JSON.stringify(node.params)});`;
  } else {
    return `${indent}
${indent}// ${node.name || node.op}
${indent}workflowData = execute${capitalizeFirst(node.op.split('.').pop() || 'Node')}(workflowData, ${JSON.stringify(node.params)});`;
  }
}).join('\n')}
    
    console.log('‚úÖ Workflow completed successfully');
    return workflowData;
    
  } catch (error) {
    console.error('‚ùå Workflow failed:', error);
    throw error;
  }
}`;

  return code;
}

function buildExecutionOrder(graph: WorkflowGraph): string[] {
  // Simple topological sort based on edges
  const visited = new Set<string>();
  const order: string[] = [];
  
  // Find nodes with no incoming edges (triggers)
  const triggerNodes = graph.nodes.filter(n => n.type === 'trigger');
  const actionNodes = graph.nodes.filter(n => n.type === 'action');
  const transformNodes = graph.nodes.filter(n => n.type === 'transform');
  
  // Add triggers first
  triggerNodes.forEach(node => {
    if (!visited.has(node.id)) {
      visited.add(node.id);
      order.push(node.id);
    }
  });
  
  // Add transforms
  transformNodes.forEach(node => {
    if (!visited.has(node.id)) {
      visited.add(node.id);
      order.push(node.id);
    }
  });
  
  // Add actions
  actionNodes.forEach(node => {
    if (!visited.has(node.id)) {
      visited.add(node.id);
      order.push(node.id);
    }
  });
  
  return order;
}

function generateTriggerSetup(triggerNodes: WorkflowNode[]): string {
  return `
function setupTriggers() {
  // Remove existing triggers
  ScriptApp.getProjectTriggers().forEach(tr => {
    if (tr.getHandlerFunction() === 'main') ScriptApp.deleteTrigger(tr);
  });
  
  // Create new triggers based on workflow configuration
${triggerNodes.filter(t => t.op.includes('time') || t.op.includes('schedule')).map(trigger => {
  const params = trigger.params;
  if (params.frequency === 'daily') {
    return `  ScriptApp.newTrigger('main')
    .timeBased()
    .everyDays(1)
    .atHour(9)
    .create();`;
  } else if (params.frequency === 'hourly') {
    return `  ScriptApp.newTrigger('main')
    .timeBased()
    .everyHours(1)
    .create();`;
  } else if (params.frequency === 'weekly') {
    return `  ScriptApp.newTrigger('main')
    .timeBased()
    .everyWeeks(1)
    .onWeekDay(ScriptApp.WeekDay.MONDAY)
    .create();`;
  }
  return '';
}).filter(Boolean).join('\n')}
}`;
}

function generateNodeFunctions(nodes: WorkflowNode[]): string[] {
  const codeBlocks: string[] = [];
  
  // Generate execution functions for each unique node operation
  const nodeOps = new Set(nodes.map(n => n.op));
  
  nodeOps.forEach(nodeOp => {
    const node = nodes.find(n => n.op === nodeOp);
    if (!node) return;
    
    codeBlocks.push(generateNodeExecutionFunction(nodeOp, node));
  });
  
  return codeBlocks;
}

function generateNodeExecutionFunction(nodeOp: string, node: WorkflowNode): string {
  const functionName = `execute${capitalizeFirst(nodeOp.split('.').pop() || 'Node')}`;
  
  if (nodeOp.startsWith('gmail.') || node.app === 'gmail') {
    return generateGmailTriggerFunction(functionName, node);
  } else if (nodeOp.startsWith('sheets.') || node.app === 'sheets' || nodeOp.startsWith('google-sheets.') || node.app === 'google-sheets-enhanced') {
    return generateGoogleSheetsFunction(functionName, node);
  } else if (nodeOp.startsWith('slack.') || node.app === 'slack' || nodeOp.startsWith('slack-enhanced.') || node.app === 'slack-enhanced') {
    return generateSlackEnhancedFunction(functionName, node);
  } else if (nodeOp.startsWith('dropbox.') || node.app === 'dropbox' || nodeOp.startsWith('dropbox-enhanced.') || node.app === 'dropbox-enhanced') {
    return generateDropboxEnhancedFunction(functionName, node);
  } else if (nodeOp.startsWith('calendar.') || node.app === 'calendar' || nodeOp.startsWith('google-calendar.') || node.app === 'google-calendar') {
    return generateGoogleCalendarFunction(functionName, node);
  } else if (nodeOp.startsWith('drive.') || node.app === 'drive' || nodeOp.startsWith('google-drive.') || node.app === 'google-drive') {
    return generateGoogleDriveFunction(functionName, node);
  } else if (nodeOp.startsWith('email.') || node.app === 'email') {
    return generateEmailTransformFunction(functionName, node);
  } else if (nodeOp.startsWith('time.') || node.app === 'time') {
    return generateTimeTriggerFunction(functionName, node);
  } else if (nodeOp.startsWith('system.') || node.app === 'system') {
    return generateSystemActionFunction(functionName, node);
  } else if (nodeOp.startsWith('shopify.') || node.app === 'shopify') {
    return generateShopifyActionFunction(functionName, node);
  } else if (nodeOp.startsWith('salesforce.') || node.app === 'salesforce' || nodeOp.startsWith('salesforce-enhanced.') || node.app === 'salesforce-enhanced') {
    return generateSalesforceEnhancedFunction(functionName, node);
  } else if (nodeOp.startsWith('jira.') || node.app === 'jira' || nodeOp.startsWith('jira-enhanced.') || node.app === 'jira-enhanced') {
    return generateJiraEnhancedFunction(functionName, node);
  } else if (nodeOp.startsWith('forms.') || node.app === 'forms' || nodeOp.startsWith('google-forms.') || node.app === 'google-forms') {
    return generateGoogleFormsFunction(functionName, node);
  } else if (nodeOp.startsWith('mailchimp.') || node.app === 'mailchimp' || nodeOp.startsWith('mailchimp-enhanced.') || node.app === 'mailchimp-enhanced') {
    return generateMailchimpEnhancedFunction(functionName, node);
  } else if (nodeOp.startsWith('hubspot.') || node.app === 'hubspot' || nodeOp.startsWith('hubspot-enhanced.') || node.app === 'hubspot-enhanced') {
    return generateHubspotEnhancedFunction(functionName, node);
  } else if (nodeOp.startsWith('pipedrive.') || node.app === 'pipedrive') {
    return generatePipedriveFunction(functionName, node);
  } else if (nodeOp.startsWith('zoho-crm.') || node.app === 'zoho-crm') {
    return generateZohoCRMFunction(functionName, node);
  } else if (nodeOp.startsWith('dynamics365.') || node.app === 'dynamics365') {
    return generateDynamics365Function(functionName, node);
  } else if (nodeOp.startsWith('google-contacts.') || node.app === 'google-contacts') {
    return generateGoogleContactsFunction(functionName, node);
  } else if (nodeOp.startsWith('microsoft-teams.') || node.app === 'microsoft-teams') {
    return generateMicrosoftTeamsFunction(functionName, node);
  } else if (nodeOp.startsWith('stripe.') || node.app === 'stripe') {
    return generateStripeFunction(functionName, node);
  } else if (nodeOp.startsWith('twilio.') || node.app === 'twilio') {
    return generateTwilioFunction(functionName, node);
  } else if (nodeOp.startsWith('paypal.') || node.app === 'paypal') {
    return generatePayPalFunction(functionName, node);
  } else if (nodeOp.startsWith('zoom-enhanced.') || node.app === 'zoom-enhanced') {
    return generateZoomEnhancedFunction(functionName, node);
  } else if (nodeOp.startsWith('google-chat.') || node.app === 'google-chat') {
    return generateGoogleChatFunction(functionName, node);
  } else if (nodeOp.startsWith('google-meet.') || node.app === 'google-meet') {
    return generateGoogleMeetFunction(functionName, node);
  } else if (nodeOp.startsWith('ringcentral.') || node.app === 'ringcentral') {
    return generateRingCentralFunction(functionName, node);
  } else if (nodeOp.startsWith('webex.') || node.app === 'webex') {
    return generateWebexFunction(functionName, node);
  } else if (nodeOp.startsWith('bigcommerce.') || node.app === 'bigcommerce') {
    return generateBigCommerceFunction(functionName, node);
  } else if (nodeOp.startsWith('woocommerce.') || node.app === 'woocommerce') {
    return generateWooCommerceFunction(functionName, node);
  } else if (nodeOp.startsWith('magento.') || node.app === 'magento') {
    return generateMagentoFunction(functionName, node);
  } else if (nodeOp.startsWith('square.') || node.app === 'square') {
    return generateSquareFunction(functionName, node);
  } else if (nodeOp.startsWith('stripe-enhanced.') || node.app === 'stripe-enhanced') {
    return generateStripeEnhancedFunction(functionName, node);
  }
  
  // Default generic function
  return `
async function ${functionName}(inputData, params) {
  console.log('üîß Executing ${node.name || nodeOp}');
  console.log('üì• Input:', inputData);
  console.log('‚öôÔ∏è Params:', params);
  
  // TODO: Implement ${nodeOp} execution logic
  return { ...inputData, ${nodeOp.replace(/\./g, '_')}: 'executed' };
}`;
}

function generateGmailTriggerFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(params) {
  console.log('üìß Executing Gmail trigger: ${node.name || 'New Email Detection'}');
  
  const query = params.query || 'is:unread';
  const maxResults = params.maxResults || 10;
  
  try {
    const threads = GmailApp.search(query, 0, maxResults);
    const emails = [];
    
    threads.forEach(thread => {
      const messages = thread.getMessages();
      messages.forEach(message => {
        emails.push({
          id: message.getId(),
          subject: message.getSubject(),
          from: message.getFrom(),
          date: message.getDate(),
          body: message.getPlainBody(),
          threadId: thread.getId()
        });
      });
    });
    
    console.log(\`üìß Found \${emails.length} emails matching query: \${query}\`);
    return { emails, query, maxResults };
    
  } catch (error) {
    console.error('‚ùå Gmail trigger failed:', error);
    throw error;
  }
}`;
}

// Comprehensive Google Sheets implementation
function generateGoogleSheetsFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'append_row';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üìä Executing Google Sheets: ${node.name || operation}');
  
  const spreadsheetId = params.spreadsheetId;
  const operation = params.operation || '${operation}';
  
  if (!spreadsheetId) {
    console.warn('‚ö†Ô∏è Spreadsheet ID is required for most operations');
  }
  
  try {
    const spreadsheet = spreadsheetId ? SpreadsheetApp.openById(spreadsheetId) : null;
    
    switch (operation) {
      case 'append_row':
        return handleAppendRow(spreadsheet, params, inputData);
      case 'update_cell':
        return handleUpdateCell(spreadsheet, params, inputData);
      case 'update_range':
        return handleUpdateRange(spreadsheet, params, inputData);
      case 'get_values':
        return handleGetValues(spreadsheet, params, inputData);
      case 'clear_range':
        return handleClearRange(spreadsheet, params, inputData);
      case 'create_sheet':
        return handleCreateSheet(spreadsheet, params, inputData);
      case 'delete_sheet':
        return handleDeleteSheet(spreadsheet, params, inputData);
      case 'duplicate_sheet':
        return handleDuplicateSheet(spreadsheet, params, inputData);
      case 'format_cells':
        return handleFormatCells(spreadsheet, params, inputData);
      case 'find_replace':
        return handleFindReplace(spreadsheet, params, inputData);
      case 'sort_range':
        return handleSortRange(spreadsheet, params, inputData);
      case 'test_connection':
        return handleTestConnection(params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Sheets operation: \${operation}\`);
        return { ...inputData, sheetsWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Google Sheets \${operation} failed:\`, error);
    return { ...inputData, sheetsError: error.toString(), sheetsSuccess: false };
  }
}

function handleAppendRow(spreadsheet, params, inputData) {
  const sheet = getSheet(spreadsheet, params.sheet || params.sheetName || 'Sheet1');
  const values = params.values || extractRowData(inputData);
  
  if (!Array.isArray(values) || values.length === 0) {
    throw new Error('Values array is required for append operation');
  }
  
  const range = sheet.getRange(sheet.getLastRow() + 1, 1, 1, values.length);
  range.setValues([values]);
  
  console.log(\`‚úÖ Appended row to \${sheet.getName()}: \${values.length} columns\`);
  return { ...inputData, sheetsAppended: true, rowsAdded: 1, sheetName: sheet.getName() };
}

function handleUpdateCell(spreadsheet, params, inputData) {
  const range = params.range;
  const value = params.value;
  
  if (!range || value === undefined) {
    throw new Error('Range and value are required for cell update');
  }
  
  const cell = spreadsheet.getRange(range);
  cell.setValue(value);
  
  console.log(\`‚úÖ Updated cell \${range} with value: \${value}\`);
  return { ...inputData, sheetsUpdated: true, updatedRange: range, updatedValue: value };
}

function handleUpdateRange(spreadsheet, params, inputData) {
  const range = params.range;
  const values = params.values;
  
  if (!range || !Array.isArray(values)) {
    throw new Error('Range and values 2D array are required for range update');
  }
  
  const targetRange = spreadsheet.getRange(range);
  targetRange.setValues(values);
  
  console.log(\`‚úÖ Updated range \${range} with \${values.length} rows\`);
  return { ...inputData, sheetsUpdated: true, updatedRange: range, rowsUpdated: values.length };
}

function handleGetValues(spreadsheet, params, inputData) {
  const range = params.range;
  
  if (!range) {
    throw new Error('Range is required for get values operation');
  }
  
  const targetRange = spreadsheet.getRange(range);
  const values = targetRange.getValues();
  
  console.log(\`‚úÖ Retrieved \${values.length} rows from range \${range}\`);
  return { ...inputData, sheetsData: values, retrievedRange: range, rowCount: values.length };
}

function handleClearRange(spreadsheet, params, inputData) {
  const range = params.range;
  
  if (!range) {
    throw new Error('Range is required for clear operation');
  }
  
  const targetRange = spreadsheet.getRange(range);
  targetRange.clear();
  
  console.log(\`‚úÖ Cleared range \${range}\`);
  return { ...inputData, sheetsCleared: true, clearedRange: range };
}

function handleCreateSheet(spreadsheet, params, inputData) {
  const title = params.title || 'New Sheet';
  const index = params.index || undefined;
  
  const newSheet = index !== undefined 
    ? spreadsheet.insertSheet(title, index)
    : spreadsheet.insertSheet(title);
  
  console.log(\`‚úÖ Created new sheet: \${title}\`);
  return { ...inputData, sheetCreated: true, sheetName: title, sheetId: newSheet.getSheetId() };
}

function handleDeleteSheet(spreadsheet, params, inputData) {
  const sheetName = params.sheetName || params.title;
  
  if (!sheetName) {
    throw new Error('Sheet name is required for delete operation');
  }
  
  const sheet = spreadsheet.getSheetByName(sheetName);
  if (!sheet) {
    throw new Error(\`Sheet '\${sheetName}' not found\`);
  }
  
  spreadsheet.deleteSheet(sheet);
  
  console.log(\`‚úÖ Deleted sheet: \${sheetName}\`);
  return { ...inputData, sheetDeleted: true, deletedSheetName: sheetName };
}

function handleDuplicateSheet(spreadsheet, params, inputData) {
  const sourceSheetName = params.sourceSheet || 'Sheet1';
  const newSheetName = params.newSheetName || \`Copy of \${sourceSheetName}\`;
  
  const sourceSheet = spreadsheet.getSheetByName(sourceSheetName);
  if (!sourceSheet) {
    throw new Error(\`Source sheet '\${sourceSheetName}' not found\`);
  }
  
  const duplicatedSheet = sourceSheet.copyTo(spreadsheet);
  duplicatedSheet.setName(newSheetName);
  
  console.log(\`‚úÖ Duplicated sheet '\${sourceSheetName}' as '\${newSheetName}'\`);
  return { ...inputData, sheetDuplicated: true, newSheetName: newSheetName, sourceSheetName: sourceSheetName };
}

function handleFormatCells(spreadsheet, params, inputData) {
  const range = params.range;
  const format = params.format || {};
  
  if (!range) {
    throw new Error('Range is required for formatting');
  }
  
  const targetRange = spreadsheet.getRange(range);
  
  // Apply formatting options
  if (format.backgroundColor) targetRange.setBackground(format.backgroundColor);
  if (format.fontColor) targetRange.setFontColor(format.fontColor);
  if (format.fontSize) targetRange.setFontSize(format.fontSize);
  if (format.fontWeight) targetRange.setFontWeight(format.fontWeight);
  if (format.numberFormat) targetRange.setNumberFormat(format.numberFormat);
  if (format.horizontalAlignment) targetRange.setHorizontalAlignment(format.horizontalAlignment);
  if (format.verticalAlignment) targetRange.setVerticalAlignment(format.verticalAlignment);
  
  console.log(\`‚úÖ Formatted range \${range}\`);
  return { ...inputData, sheetsFormatted: true, formattedRange: range };
}

function handleFindReplace(spreadsheet, params, inputData) {
  const findText = params.findText;
  const replaceText = params.replaceText || '';
  const sheetName = params.sheetName;
  
  if (!findText) {
    throw new Error('Find text is required for find/replace operation');
  }
  
  let targetSheet;
  if (sheetName) {
    targetSheet = spreadsheet.getSheetByName(sheetName);
    if (!targetSheet) {
      throw new Error(\`Sheet '\${sheetName}' not found\`);
    }
  } else {
    targetSheet = spreadsheet.getActiveSheet();
  }
  
  const textFinder = targetSheet.createTextFinder(findText);
  const replacements = textFinder.replaceAllWith(replaceText);
  
  console.log(\`‚úÖ Replaced \${replacements} instances of '\${findText}' with '\${replaceText}'\`);
  return { ...inputData, sheetsReplaced: true, replacements: replacements, findText: findText, replaceText: replaceText };
}

function handleSortRange(spreadsheet, params, inputData) {
  const range = params.range;
  const sortColumn = params.sortColumn || 1;
  const ascending = params.ascending !== false;
  
  if (!range) {
    throw new Error('Range is required for sort operation');
  }
  
  const targetRange = spreadsheet.getRange(range);
  targetRange.sort({ column: sortColumn, ascending: ascending });
  
  console.log(\`‚úÖ Sorted range \${range} by column \${sortColumn} (\${ascending ? 'ascending' : 'descending'})\`);
  return { ...inputData, sheetsSorted: true, sortedRange: range, sortColumn: sortColumn };
}

function handleTestConnection(params, inputData) {
  try {
    // Test by accessing SpreadsheetApp
    const user = Session.getActiveUser().getEmail();
    console.log(\`‚úÖ Google Sheets connection test successful. User: \${user}\`);
    return { ...inputData, connectionTest: 'success', userEmail: user };
  } catch (error) {
    console.error('‚ùå Sheets connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

// Helper functions
function getSheet(spreadsheet, sheetNameOrRange) {
  if (!spreadsheet) throw new Error('Spreadsheet is required');
  
  let sheetName = sheetNameOrRange;
  if (sheetNameOrRange.includes('!')) {
    sheetName = sheetNameOrRange.split('!')[0];
  }
  
  const sheet = spreadsheet.getSheetByName(sheetName);
  if (!sheet) {
    throw new Error(\`Sheet '\${sheetName}' not found\`);
  }
  
  return sheet;
}

function extractRowData(inputData) {
  // Extract meaningful data from various input formats
  if (inputData.emails && Array.isArray(inputData.emails) && inputData.emails.length > 0) {
    const email = inputData.emails[0];
    return [email.subject || '', email.from || '', email.date || new Date(), email.body || ''];
  } else if (inputData.formResponses && Array.isArray(inputData.formResponses) && inputData.formResponses.length > 0) {
    const response = inputData.formResponses[0];
    return Object.values(response.answers || {});
  } else if (inputData.shopifyResult && inputData.shopifyResult.customer) {
    const customer = inputData.shopifyResult.customer;
    return [customer.first_name || '', customer.last_name || '', customer.email || '', customer.phone || ''];
  } else {
    // Generic extraction
    const values = [];
    ['name', 'email', 'phone', 'company', 'subject', 'message', 'date'].forEach(key => {
      if (inputData[key] !== undefined) {
        values.push(inputData[key]);
      }
    });
    return values.length > 0 ? values : ['Data from workflow', new Date().toString()];
  }
}`;
}

// Comprehensive Slack implementation
function generateSlackEnhancedFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'send_message';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üí¨ Executing Slack: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const botToken = PropertiesService.getScriptProperties().getProperty('SLACK_BOT_TOKEN');
  const webhookUrl = PropertiesService.getScriptProperties().getProperty('SLACK_WEBHOOK_URL');
  
  try {
    switch (operation) {
      case 'send_message':
        return handleSendMessage(botToken, webhookUrl, params, inputData);
      case 'send_direct_message':
        return handleSendDirectMessage(botToken, params, inputData);
      case 'create_channel':
        return handleCreateChannel(botToken, params, inputData);
      case 'invite_user_to_channel':
        return handleInviteUser(botToken, params, inputData);
      case 'get_channel_history':
        return handleGetChannelHistory(botToken, params, inputData);
      case 'upload_file':
        return handleUploadFile(botToken, params, inputData);
      case 'add_reaction':
        return handleAddReaction(botToken, params, inputData);
      case 'get_user_info':
        return handleGetUserInfo(botToken, params, inputData);
      case 'list_channels':
        return handleListChannels(botToken, params, inputData);
      case 'set_channel_topic':
        return handleSetChannelTopic(botToken, params, inputData);
      case 'archive_channel':
        return handleArchiveChannel(botToken, params, inputData);
      case 'pin_message':
        return handlePinMessage(botToken, params, inputData);
      case 'schedule_message':
        return handleScheduleMessage(botToken, params, inputData);
      case 'test_connection':
        return handleSlackTestConnection(botToken, webhookUrl, params, inputData);
      case 'message_received':
      case 'mention_received':
        return handleSlackTrigger(botToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Slack operation: \${operation}\`);
        return { ...inputData, slackWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Slack \${operation} failed:\`, error);
    return { ...inputData, slackError: error.toString(), slackSuccess: false };
  }
}

function handleSendMessage(botToken, webhookUrl, params, inputData) {
  const channel = params.channel || '#general';
  const text = params.text || params.message || inputData.message || 'Workflow notification';
  const username = params.username || 'Apps Script Bot';
  const iconEmoji = params.icon_emoji || ':robot_face:';
  
  // Try bot token first, then webhook
  if (botToken) {
    const response = UrlFetchApp.fetch('https://slack.com/api/chat.postMessage', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${botToken}\`,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify({
        channel: channel,
        text: text,
        username: username,
        icon_emoji: iconEmoji,
        attachments: params.attachments || [],
        blocks: params.blocks || []
      })
    });
    
    const data = JSON.parse(response.getContentText());
    if (data.ok) {
      console.log(\`‚úÖ Slack message sent to \${channel}\`);
      return { ...inputData, slackSent: true, channel: channel, messageTs: data.ts };
    } else {
      throw new Error(\`Slack API error: \${data.error}\`);
    }
  } else if (webhookUrl) {
    const response = UrlFetchApp.fetch(webhookUrl, {
      method: 'POST',
      contentType: 'application/json',
      payload: JSON.stringify({
        channel: channel,
        text: text,
        username: username,
        icon_emoji: iconEmoji
      })
    });
    
    if (response.getResponseCode() === 200) {
      console.log(\`‚úÖ Slack webhook message sent to \${channel}\`);
      return { ...inputData, slackSent: true, channel: channel };
    } else {
      throw new Error(\`Webhook failed with status: \${response.getResponseCode()}\`);
    }
  } else {
    throw new Error('Neither Slack bot token nor webhook URL is configured');
  }
}

function handleSendDirectMessage(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for direct messages');
  }
  
  const userId = params.userId || params.user;
  const text = params.text || params.message || 'Direct message from automation';
  
  if (!userId) {
    throw new Error('User ID is required for direct message');
  }
  
  const response = UrlFetchApp.fetch('https://slack.com/api/chat.postMessage', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${botToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      channel: userId,
      text: text
    })
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    console.log(\`‚úÖ Direct message sent to user \${userId}\`);
    return { ...inputData, slackDmSent: true, userId: userId, messageTs: data.ts };
  } else {
    throw new Error(\`Slack API error: \${data.error}\`);
  }
}

function handleCreateChannel(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for channel creation');
  }
  
  const name = params.name || params.channelName;
  const isPrivate = params.is_private || false;
  
  if (!name) {
    throw new Error('Channel name is required');
  }
  
  const response = UrlFetchApp.fetch('https://slack.com/api/conversations.create', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${botToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      name: name,
      is_private: isPrivate
    })
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    console.log(\`‚úÖ Created Slack channel: #\${name}\`);
    return { ...inputData, slackChannelCreated: true, channelId: data.channel.id, channelName: name };
  } else {
    throw new Error(\`Slack API error: \${data.error}\`);
  }
}

function handleInviteUser(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for inviting users');
  }
  
  const channelId = params.channelId || params.channel;
  const userId = params.userId || params.user;
  
  if (!channelId || !userId) {
    throw new Error('Channel ID and User ID are required');
  }
  
  const response = UrlFetchApp.fetch('https://slack.com/api/conversations.invite', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${botToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      channel: channelId,
      users: userId
    })
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    console.log(\`‚úÖ Invited user \${userId} to channel \${channelId}\`);
    return { ...inputData, slackUserInvited: true, channelId: channelId, userId: userId };
  } else {
    throw new Error(\`Slack API error: \${data.error}\`);
  }
}

function handleGetChannelHistory(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for channel history');
  }
  
  const channelId = params.channelId || params.channel;
  const limit = params.limit || 100;
  
  if (!channelId) {
    throw new Error('Channel ID is required');
  }
  
  const response = UrlFetchApp.fetch(\`https://slack.com/api/conversations.history?channel=\${channelId}&limit=\${limit}\`, {
    method: 'GET',
    headers: {
      'Authorization': \`Bearer \${botToken}\`
    }
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    console.log(\`‚úÖ Retrieved \${data.messages.length} messages from channel \${channelId}\`);
    return { ...inputData, slackMessages: data.messages, messageCount: data.messages.length };
  } else {
    throw new Error(\`Slack API error: \${data.error}\`);
  }
}

function handleUploadFile(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for file upload');
  }
  
  const channels = params.channels || params.channel || '#general';
  const title = params.title || 'File from automation';
  const content = params.content || params.fileContent || inputData.fileContent || 'Sample content';
  const filename = params.filename || 'automation-file.txt';
  
  const response = UrlFetchApp.fetch('https://slack.com/api/files.upload', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${botToken}\`
    },
    payload: {
      channels: channels,
      title: title,
      filename: filename,
      content: content
    }
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    console.log(\`‚úÖ Uploaded file to Slack: \${filename}\`);
    return { ...inputData, slackFileUploaded: true, fileId: data.file.id, filename: filename };
  } else {
    throw new Error(\`Slack API error: \${data.error}\`);
  }
}

function handleListChannels(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for listing channels');
  }
  
  const types = params.types || 'public_channel,private_channel';
  const excludeArchived = params.exclude_archived !== false;
  
  const response = UrlFetchApp.fetch(\`https://slack.com/api/conversations.list?types=\${types}&exclude_archived=\${excludeArchived}\`, {
    method: 'GET',
    headers: {
      'Authorization': \`Bearer \${botToken}\`
    }
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    const channels = data.channels.map(channel => ({
      id: channel.id,
      name: channel.name,
      isChannel: channel.is_channel,
      isPrivate: channel.is_private,
      isArchived: channel.is_archived,
      memberCount: channel.num_members || 0
    }));
    
    console.log(\`‚úÖ Retrieved \${channels.length} Slack channels\`);
    return { ...inputData, slackChannels: channels, channelCount: channels.length };
  } else {
    throw new Error(\`Slack API error: \${data.error}\`);
  }
}

function handleSlackTestConnection(botToken, webhookUrl, params, inputData) {
  try {
    if (botToken) {
      const response = UrlFetchApp.fetch('https://slack.com/api/auth.test', {
        method: 'POST',
        headers: {
          'Authorization': \`Bearer \${botToken}\`
        }
      });
      
      const data = JSON.parse(response.getContentText());
      if (data.ok) {
        console.log(\`‚úÖ Slack bot token test successful. Team: \${data.team}, User: \${data.user}\`);
        return { ...inputData, connectionTest: 'success', team: data.team, user: data.user };
      } else {
        throw new Error(\`Bot token test failed: \${data.error}\`);
      }
    } else if (webhookUrl) {
      const testResponse = UrlFetchApp.fetch(webhookUrl, {
        method: 'POST',
        contentType: 'application/json',
        payload: JSON.stringify({
          text: 'Connection test from Apps Script',
          username: 'Test Bot'
        })
      });
      
      if (testResponse.getResponseCode() === 200) {
        console.log('‚úÖ Slack webhook test successful');
        return { ...inputData, connectionTest: 'success', method: 'webhook' };
      } else {
        throw new Error(\`Webhook test failed: \${testResponse.getResponseCode()}\`);
      }
    } else {
      throw new Error('Neither bot token nor webhook URL is configured');
    }
  } catch (error) {
    console.error('‚ùå Slack connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleSlackTrigger(botToken, params, inputData) {
  // This simulates checking for new messages/mentions
  if (!botToken) {
    console.warn('‚ö†Ô∏è Bot token required for message triggers, using webhook fallback');
    return { ...inputData, slackTrigger: 'simulated', message: 'Trigger detected' };
  }
  
  const channelId = params.channelId || params.channel;
  const keywords = params.keywords || '';
  
  try {
    if (channelId) {
      const response = UrlFetchApp.fetch(\`https://slack.com/api/conversations.history?channel=\${channelId}&limit=10\`, {
        method: 'GET',
        headers: {
          'Authorization': \`Bearer \${botToken}\`
        }
      });
      
      const data = JSON.parse(response.getContentText());
      if (data.ok && data.messages.length > 0) {
        const recentMessages = data.messages.filter(msg => {
          if (!keywords) return true;
          return msg.text && msg.text.toLowerCase().includes(keywords.toLowerCase());
        });
        
        console.log(\`üì® Slack trigger found \${recentMessages.length} matching messages\`);
        return { ...inputData, slackTrigger: recentMessages, triggerCount: recentMessages.length };
      }
    }
    
    return { ...inputData, slackTrigger: [], triggerCount: 0 };
  } catch (error) {
    console.error('‚ùå Slack trigger check failed:', error);
    return { ...inputData, slackTriggerError: error.toString() };
  }
}`;
}

// Comprehensive Dropbox implementation
function generateDropboxEnhancedFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'upload_file';
  
  return `
function ${functionName}(inputData, params) {
  console.log('‚òÅÔ∏è Executing Dropbox: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const dropboxToken = PropertiesService.getScriptProperties().getProperty('DROPBOX_ACCESS_TOKEN');
  
  if (!dropboxToken) {
    console.warn('‚ö†Ô∏è Dropbox access token not configured, skipping operation');
    return { ...inputData, dropboxSkipped: true, error: 'Missing access token' };
  }
  
  try {
    switch (operation) {
      case 'upload_file':
        return handleDropboxUpload(dropboxToken, params, inputData);
      case 'download_file':
        return handleDropboxDownload(dropboxToken, params, inputData);
      case 'list_folder':
        return handleListFolder(dropboxToken, params, inputData);
      case 'create_folder':
        return handleCreateDropboxFolder(dropboxToken, params, inputData);
      case 'delete_file':
        return handleDeleteDropboxFile(dropboxToken, params, inputData);
      case 'move_file':
        return handleMoveDropboxFile(dropboxToken, params, inputData);
      case 'copy_file':
        return handleCopyDropboxFile(dropboxToken, params, inputData);
      case 'get_metadata':
        return handleGetDropboxMetadata(dropboxToken, params, inputData);
      case 'create_shared_link':
        return handleCreateSharedLink(dropboxToken, params, inputData);
      case 'search':
        return handleDropboxSearch(dropboxToken, params, inputData);
      case 'test_connection':
        return handleDropboxTestConnection(dropboxToken, params, inputData);
      case 'file_uploaded':
      case 'file_deleted':
      case 'folder_shared':
        return handleDropboxTrigger(dropboxToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Dropbox operation: \${operation}\`);
        return { ...inputData, dropboxWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Dropbox \${operation} failed:\`, error);
    return { ...inputData, dropboxError: error.toString(), dropboxSuccess: false };
  }
}

function handleDropboxUpload(dropboxToken, params, inputData) {
  const path = params.path || params.destination || '/uploaded_file.txt';
  const content = params.content || params.fileContent || inputData.fileContent || 'Default content';
  const mode = params.mode || 'add';
  const autorename = params.autorename !== false;
  
  const response = UrlFetchApp.fetch('https://content.dropboxapi.com/2/files/upload', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${dropboxToken}\`,
      'Content-Type': 'application/octet-stream',
      'Dropbox-API-Arg': JSON.stringify({
        path: path,
        mode: mode,
        autorename: autorename
      })
    },
    payload: content
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Uploaded file to Dropbox: \${data.name}\`);
    return { ...inputData, dropboxUploaded: true, filePath: data.path_display, fileId: data.id };
  } else {
    throw new Error(\`Upload failed: \${response.getResponseCode()}\`);
  }
}

function handleDropboxDownload(dropboxToken, params, inputData) {
  const path = params.path || params.filePath;
  
  if (!path) {
    throw new Error('File path is required for download');
  }
  
  const response = UrlFetchApp.fetch('https://content.dropboxapi.com/2/files/download', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${dropboxToken}\`,
      'Dropbox-API-Arg': JSON.stringify({ path: path })
    }
  });
  
  if (response.getResponseCode() === 200) {
    const content = response.getContentText();
    console.log(\`‚úÖ Downloaded file from Dropbox: \${path}\`);
    return { ...inputData, dropboxDownload: { path: path, content: content, size: content.length } };
  } else {
    throw new Error(\`Download failed: \${response.getResponseCode()}\`);
  }
}

function handleListFolder(dropboxToken, params, inputData) {
  const path = params.path || params.folderPath || '';
  const recursive = params.recursive || false;
  const limit = params.limit || 2000;
  
  const response = UrlFetchApp.fetch('https://api.dropboxapi.com/2/files/list_folder', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${dropboxToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      path: path,
      recursive: recursive,
      limit: limit
    })
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    const entries = data.entries.map(entry => ({
      name: entry.name,
      path: entry.path_display,
      type: entry['.tag'], // file or folder
      id: entry.id,
      size: entry.size || 0,
      modifiedTime: entry.server_modified || null
    }));
    
    console.log(\`‚úÖ Listed \${entries.length} items from Dropbox folder: \${path}\`);
    return { ...inputData, dropboxEntries: entries, entryCount: entries.length };
  } else {
    throw new Error(\`List folder failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateDropboxFolder(dropboxToken, params, inputData) {
  const path = params.path || params.folderPath;
  
  if (!path) {
    throw new Error('Folder path is required');
  }
  
  const response = UrlFetchApp.fetch('https://api.dropboxapi.com/2/files/create_folder_v2', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${dropboxToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      path: path,
      autorename: params.autorename !== false
    })
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Dropbox folder: \${data.metadata.name}\`);
    return { ...inputData, dropboxFolderCreated: true, folderPath: data.metadata.path_display };
  } else {
    throw new Error(\`Create folder failed: \${response.getResponseCode()}\`);
  }
}

function handleDeleteDropboxFile(dropboxToken, params, inputData) {
  const path = params.path || params.filePath;
  
  if (!path) {
    throw new Error('File path is required for deletion');
  }
  
  const response = UrlFetchApp.fetch('https://api.dropboxapi.com/2/files/delete_v2', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${dropboxToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      path: path
    })
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Deleted Dropbox file: \${data.metadata.name}\`);
    return { ...inputData, dropboxDeleted: true, deletedPath: data.metadata.path_display };
  } else {
    throw new Error(\`Delete failed: \${response.getResponseCode()}\`);
  }
}

function handleDropboxTestConnection(dropboxToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch('https://api.dropboxapi.com/2/users/get_current_account', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${dropboxToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Dropbox connection test successful. User: \${data.email}\`);
      return { ...inputData, connectionTest: 'success', userEmail: data.email, accountId: data.account_id };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Dropbox connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleDropboxTrigger(dropboxToken, params, inputData) {
  // Simulate file monitoring by checking recent changes
  const path = params.path || '';
  const limit = params.limit || 10;
  
  try {
    const response = UrlFetchApp.fetch('https://api.dropboxapi.com/2/files/list_folder', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${dropboxToken}\`,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify({
        path: path,
        limit: limit
      })
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      const recentFiles = data.entries.slice(0, 5); // Get 5 most recent
      
      console.log(\`üìÅ Dropbox trigger found \${recentFiles.length} recent files\`);
      return { ...inputData, dropboxTrigger: recentFiles, triggerCount: recentFiles.length };
    } else {
      throw new Error(\`Trigger check failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Dropbox trigger failed:', error);
    return { ...inputData, dropboxTriggerError: error.toString() };
  }
}`;
}

// Comprehensive Google Calendar implementation
function generateGoogleCalendarFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'list_events';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üìÖ Executing Google Calendar: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const calendarId = params.calendarId || 'primary';
  
  try {
    switch (operation) {
      case 'create_event':
        return handleCreateEvent(calendarId, params, inputData);
      case 'update_event':
        return handleUpdateEvent(calendarId, params, inputData);
      case 'get_event':
        return handleGetEvent(calendarId, params, inputData);
      case 'list_events':
        return handleListEvents(calendarId, params, inputData);
      case 'delete_event':
        return handleDeleteEvent(calendarId, params, inputData);
      case 'list_calendars':
        return handleListCalendars(params, inputData);
      case 'create_calendar':
        return handleCreateCalendar(params, inputData);
      case 'update_calendar':
        return handleUpdateCalendar(calendarId, params, inputData);
      case 'get_freebusy':
        return handleGetFreeBusy(calendarId, params, inputData);
      case 'quick_add':
        return handleQuickAdd(calendarId, params, inputData);
      case 'test_connection':
        return handleCalendarTestConnection(params, inputData);
      case 'watch_events':
      case 'event_created':
      case 'event_updated':
        return handleEventTrigger(calendarId, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Calendar operation: \${operation}\`);
        return { ...inputData, calendarWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Google Calendar \${operation} failed:\`, error);
    return { ...inputData, calendarError: error.toString(), calendarSuccess: false };
  }
}

function handleCreateEvent(calendarId, params, inputData) {
  const calendar = CalendarApp.getCalendarById(calendarId);
  
  const title = params.title || params.summary || 'New Event';
  const startTime = params.startTime ? new Date(params.startTime) : new Date();
  const endTime = params.endTime ? new Date(params.endTime) : new Date(startTime.getTime() + 60 * 60 * 1000); // 1 hour default
  const description = params.description || '';
  const location = params.location || '';
  
  const event = calendar.createEvent(title, startTime, endTime, {
    description: description,
    location: location,
    guests: params.attendees || '',
    sendInvites: params.sendInvites !== false
  });
  
  console.log(\`‚úÖ Created event: \${title} on \${startTime.toISOString()}\`);
  return { ...inputData, calendarEvent: event.getId(), eventTitle: title, eventStart: startTime.toISOString() };
}

function handleUpdateEvent(calendarId, params, inputData) {
  const calendar = CalendarApp.getCalendarById(calendarId);
  const eventId = params.eventId;
  
  if (!eventId) {
    throw new Error('Event ID is required for update operation');
  }
  
  const event = calendar.getEventById(eventId);
  if (!event) {
    throw new Error(\`Event with ID '\${eventId}' not found\`);
  }
  
  if (params.title) event.setTitle(params.title);
  if (params.description) event.setDescription(params.description);
  if (params.location) event.setLocation(params.location);
  if (params.startTime && params.endTime) {
    event.setTime(new Date(params.startTime), new Date(params.endTime));
  }
  
  console.log(\`‚úÖ Updated event: \${eventId}\`);
  return { ...inputData, calendarUpdated: true, eventId: eventId };
}

function handleGetEvent(calendarId, params, inputData) {
  const calendar = CalendarApp.getCalendarById(calendarId);
  const eventId = params.eventId;
  
  if (!eventId) {
    throw new Error('Event ID is required for get operation');
  }
  
  const event = calendar.getEventById(eventId);
  if (!event) {
    throw new Error(\`Event with ID '\${eventId}' not found\`);
  }
  
  const eventData = {
    id: event.getId(),
    title: event.getTitle(),
    start: event.getStartTime().toISOString(),
    end: event.getEndTime().toISOString(),
    description: event.getDescription(),
    location: event.getLocation(),
    creator: event.getCreators()[0] || '',
    attendees: event.getGuestList().map(guest => guest.getEmail())
  };
  
  console.log(\`‚úÖ Retrieved event: \${eventData.title}\`);
  return { ...inputData, calendarEvent: eventData };
}

function handleListEvents(calendarId, params, inputData) {
  const calendar = CalendarApp.getCalendarById(calendarId);
  
  const startTime = params.timeMin ? new Date(params.timeMin) : new Date();
  const endTime = params.timeMax ? new Date(params.timeMax) : new Date(startTime.getTime() + 7 * 24 * 60 * 60 * 1000); // 7 days default
  const maxResults = params.maxResults || 250;
  
  const events = calendar.getEvents(startTime, endTime);
  const limitedEvents = events.slice(0, maxResults);
  
  const eventList = limitedEvents.map(event => ({
    id: event.getId(),
    title: event.getTitle(),
    start: event.getStartTime().toISOString(),
    end: event.getEndTime().toISOString(),
    description: event.getDescription() || '',
    location: event.getLocation() || '',
    attendees: event.getGuestList().map(guest => guest.getEmail())
  }));
  
  console.log(\`‚úÖ Listed \${eventList.length} events from \${calendarId}\`);
  return { ...inputData, calendarEvents: eventList, eventCount: eventList.length };
}

function handleDeleteEvent(calendarId, params, inputData) {
  const calendar = CalendarApp.getCalendarById(calendarId);
  const eventId = params.eventId;
  
  if (!eventId) {
    throw new Error('Event ID is required for delete operation');
  }
  
  const event = calendar.getEventById(eventId);
  if (!event) {
    throw new Error(\`Event with ID '\${eventId}' not found\`);
  }
  
  event.deleteEvent();
  
  console.log(\`‚úÖ Deleted event: \${eventId}\`);
  return { ...inputData, calendarDeleted: true, deletedEventId: eventId };
}

function handleListCalendars(params, inputData) {
  const calendars = CalendarApp.getAllOwnedCalendars();
  
  const calendarList = calendars.map(calendar => ({
    id: calendar.getId(),
    name: calendar.getName(),
    description: calendar.getDescription() || '',
    color: calendar.getColor(),
    timeZone: calendar.getTimeZone()
  }));
  
  console.log(\`‚úÖ Listed \${calendarList.length} calendars\`);
  return { ...inputData, calendars: calendarList, calendarCount: calendarList.length };
}

function handleCreateCalendar(params, inputData) {
  const name = params.name || 'New Calendar';
  const description = params.description || '';
  
  const calendar = CalendarApp.createCalendar(name, {
    summary: description,
    color: params.color || CalendarApp.Color.BLUE
  });
  
  console.log(\`‚úÖ Created calendar: \${name}\`);
  return { ...inputData, calendarCreated: true, calendarId: calendar.getId(), calendarName: name };
}

function handleUpdateCalendar(calendarId, params, inputData) {
  const calendar = CalendarApp.getCalendarById(calendarId);
  
  if (params.name) calendar.setName(params.name);
  if (params.description) calendar.setDescription(params.description);
  if (params.color) calendar.setColor(params.color);
  if (params.timeZone) calendar.setTimeZone(params.timeZone);
  
  console.log(\`‚úÖ Updated calendar: \${calendarId}\`);
  return { ...inputData, calendarUpdated: true, calendarId: calendarId };
}

function handleGetFreeBusy(calendarId, params, inputData) {
  const calendar = CalendarApp.getCalendarById(calendarId);
  const startTime = params.timeMin ? new Date(params.timeMin) : new Date();
  const endTime = params.timeMax ? new Date(params.timeMax) : new Date(startTime.getTime() + 24 * 60 * 60 * 1000);
  
  const events = calendar.getEvents(startTime, endTime);
  const busyTimes = events.map(event => ({
    start: event.getStartTime().toISOString(),
    end: event.getEndTime().toISOString(),
    title: event.getTitle()
  }));
  
  console.log(\`‚úÖ Retrieved free/busy data for \${calendarId}: \${busyTimes.length} busy periods\`);
  return { ...inputData, busyTimes: busyTimes, calendarId: calendarId };
}

function handleQuickAdd(calendarId, params, inputData) {
  const calendar = CalendarApp.getCalendarById(calendarId);
  const text = params.text || params.quickAddText;
  
  if (!text) {
    throw new Error('Text is required for quick add operation');
  }
  
  // Parse simple text like "Meeting tomorrow 2pm" or "Lunch at 12:30"
  const event = calendar.createEventFromDescription(text);
  
  console.log(\`‚úÖ Quick added event from text: \${text}\`);
  return { ...inputData, calendarQuickAdded: true, eventId: event.getId(), originalText: text };
}

function handleCalendarTestConnection(params, inputData) {
  try {
    const user = Session.getActiveUser().getEmail();
    const calendars = CalendarApp.getAllOwnedCalendars();
    
    console.log(\`‚úÖ Google Calendar connection test successful. User: \${user}, Calendars: \${calendars.length}\`);
    return { ...inputData, connectionTest: 'success', userEmail: user, calendarCount: calendars.length };
  } catch (error) {
    console.error('‚ùå Calendar connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleEventTrigger(calendarId, params, inputData) {
  const calendar = CalendarApp.getCalendarById(calendarId);
  const eventType = params.eventType || 'all';
  const daysAhead = params.daysAhead || 7;
  
  const now = new Date();
  const future = new Date(now.getTime() + daysAhead * 24 * 60 * 60 * 1000);
  
  let events = calendar.getEvents(now, future);
  
  // Apply filters based on event type
  if (eventType === 'birthday') {
    events = events.filter(event => 
      event.getTitle().toLowerCase().includes('birthday') || 
      event.getDescription()?.toLowerCase().includes('birthday')
    );
  } else if (eventType === 'meeting') {
    events = events.filter(event => 
      event.getTitle().toLowerCase().includes('meeting') || 
      event.getGuestList().length > 0
    );
  }
  
  const eventData = events.map(event => ({
    id: event.getId(),
    title: event.getTitle(),
    start: event.getStartTime().toISOString(),
    end: event.getEndTime().toISOString(),
    description: event.getDescription() || '',
    location: event.getLocation() || '',
    attendees: event.getGuestList().map(guest => guest.getEmail())
  }));
  
  console.log(\`üìÖ Found \${eventData.length} \${eventType} events in the next \${daysAhead} days\`);
  return { ...inputData, events: eventData, calendarId: calendarId, eventType: eventType };
}`;
}

// Comprehensive Google Drive implementation
function generateGoogleDriveFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'list_files';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üíæ Executing Google Drive: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  
  try {
    switch (operation) {
      case 'create_file':
        return handleCreateFile(params, inputData);
      case 'upload_file':
        return handleUploadFile(params, inputData);
      case 'get_file':
        return handleGetFile(params, inputData);
      case 'download_file':
        return handleDownloadFile(params, inputData);
      case 'list_files':
        return handleListFiles(params, inputData);
      case 'create_folder':
        return handleCreateFolder(params, inputData);
      case 'move_file':
        return handleMoveFile(params, inputData);
      case 'copy_file':
        return handleCopyFile(params, inputData);
      case 'delete_file':
        return handleDeleteFile(params, inputData);
      case 'share_file':
        return handleShareFile(params, inputData);
      case 'get_file_permissions':
        return handleGetFilePermissions(params, inputData);
      case 'update_file_metadata':
        return handleUpdateFileMetadata(params, inputData);
      case 'test_connection':
        return handleDriveTestConnection(params, inputData);
      case 'watch_folder':
      case 'file_created':
      case 'file_updated':
        return handleFileTrigger(params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Drive operation: \${operation}\`);
        return { ...inputData, driveWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Google Drive \${operation} failed:\`, error);
    return { ...inputData, driveError: error.toString(), driveSuccess: false };
  }
}

function handleCreateFile(params, inputData) {
  const name = params.name || params.title || 'New File';
  const content = params.content || params.body || '';
  const mimeType = params.mimeType || 'text/plain';
  const folderId = params.folderId || params.parentId;
  
  let file;
  if (folderId) {
    const folder = DriveApp.getFolderById(folderId);
    file = folder.createFile(name, content, mimeType);
  } else {
    file = DriveApp.createFile(name, content, mimeType);
  }
  
  console.log(\`‚úÖ Created file: \${name} (\${file.getId()})\`);
  return { ...inputData, driveFile: { id: file.getId(), name: name, url: file.getUrl() } };
}

function handleUploadFile(params, inputData) {
  const name = params.name || 'Uploaded File';
  const blob = params.blob;
  const folderId = params.folderId || params.parentId;
  
  if (!blob) {
    throw new Error('File blob is required for upload');
  }
  
  let file;
  if (folderId) {
    const folder = DriveApp.getFolderById(folderId);
    file = folder.createFile(blob);
  } else {
    file = DriveApp.createFile(blob);
  }
  
  if (name !== blob.getName()) {
    file.setName(name);
  }
  
  console.log(\`‚úÖ Uploaded file: \${name} (\${file.getId()})\`);
  return { ...inputData, driveFile: { id: file.getId(), name: file.getName(), size: file.getSize() } };
}

function handleGetFile(params, inputData) {
  const fileId = params.fileId;
  
  if (!fileId) {
    throw new Error('File ID is required');
  }
  
  const file = DriveApp.getFileById(fileId);
  const fileData = {
    id: file.getId(),
    name: file.getName(),
    description: file.getDescription(),
    size: file.getSize(),
    mimeType: file.getBlob().getContentType(),
    createdDate: file.getDateCreated().toISOString(),
    lastUpdated: file.getLastUpdated().toISOString(),
    url: file.getUrl(),
    downloadUrl: file.getDownloadUrl(),
    owners: file.getOwners().map(owner => owner.getEmail())
  };
  
  console.log(\`‚úÖ Retrieved file: \${fileData.name}\`);
  return { ...inputData, driveFile: fileData };
}

function handleDownloadFile(params, inputData) {
  const fileId = params.fileId;
  
  if (!fileId) {
    throw new Error('File ID is required for download');
  }
  
  const file = DriveApp.getFileById(fileId);
  const blob = file.getBlob();
  const content = blob.getDataAsString();
  
  console.log(\`‚úÖ Downloaded file: \${file.getName()} (\${blob.getSize()} bytes)\`);
  return { 
    ...inputData, 
    driveDownload: {
      fileName: file.getName(),
      content: content,
      size: blob.getSize(),
      mimeType: blob.getContentType()
    }
  };
}

function handleListFiles(params, inputData) {
  const query = params.query || params.searchQuery || '';
  const maxResults = params.maxResults || 100;
  const folderId = params.folderId || params.parentId;
  
  let searchQuery = query;
  if (folderId) {
    searchQuery += (searchQuery ? ' and ' : '') + \`'\${folderId}' in parents\`;
  }
  
  let files;
  if (searchQuery) {
    files = DriveApp.searchFiles(searchQuery);
  } else {
    files = DriveApp.getFiles();
  }
  
  const fileList = [];
  let count = 0;
  
  while (files.hasNext() && count < maxResults) {
    const file = files.next();
    fileList.push({
      id: file.getId(),
      name: file.getName(),
      mimeType: file.getBlob().getContentType(),
      size: file.getSize(),
      createdDate: file.getDateCreated().toISOString(),
      url: file.getUrl()
    });
    count++;
  }
  
  console.log(\`‚úÖ Listed \${fileList.length} files\`);
  return { ...inputData, driveFiles: fileList, fileCount: fileList.length };
}

function handleCreateFolder(params, inputData) {
  const name = params.name || params.title || 'New Folder';
  const parentId = params.parentId || params.folderId;
  
  let folder;
  if (parentId) {
    const parentFolder = DriveApp.getFolderById(parentId);
    folder = parentFolder.createFolder(name);
  } else {
    folder = DriveApp.createFolder(name);
  }
  
  console.log(\`‚úÖ Created folder: \${name} (\${folder.getId()})\`);
  return { ...inputData, driveFolder: { id: folder.getId(), name: name, url: folder.getUrl() } };
}

function handleMoveFile(params, inputData) {
  const fileId = params.fileId;
  const targetFolderId = params.targetFolderId || params.destinationFolderId;
  
  if (!fileId || !targetFolderId) {
    throw new Error('File ID and target folder ID are required for move operation');
  }
  
  const file = DriveApp.getFileById(fileId);
  const targetFolder = DriveApp.getFolderById(targetFolderId);
  const currentParents = file.getParents();
  
  // Remove from current parents and add to target folder
  while (currentParents.hasNext()) {
    currentParents.next().removeFile(file);
  }
  targetFolder.addFile(file);
  
  console.log(\`‚úÖ Moved file \${file.getName()} to folder \${targetFolder.getName()}\`);
  return { ...inputData, driveMoved: true, fileId: fileId, targetFolderId: targetFolderId };
}

function handleCopyFile(params, inputData) {
  const fileId = params.fileId;
  const name = params.name || params.copyName;
  
  if (!fileId) {
    throw new Error('File ID is required for copy operation');
  }
  
  const originalFile = DriveApp.getFileById(fileId);
  const copiedFile = originalFile.makeCopy(name || \`Copy of \${originalFile.getName()}\`);
  
  console.log(\`‚úÖ Copied file: \${originalFile.getName()} to \${copiedFile.getName()}\`);
  return { ...inputData, driveCopied: true, originalId: fileId, copyId: copiedFile.getId() };
}

function handleDeleteFile(params, inputData) {
  const fileId = params.fileId;
  
  if (!fileId) {
    throw new Error('File ID is required for delete operation');
  }
  
  const file = DriveApp.getFileById(fileId);
  const fileName = file.getName();
  file.setTrashed(true);
  
  console.log(\`‚úÖ Deleted file: \${fileName}\`);
  return { ...inputData, driveDeleted: true, deletedFileId: fileId, deletedFileName: fileName };
}

function handleShareFile(params, inputData) {
  const fileId = params.fileId;
  const email = params.email || params.userEmail;
  const role = params.role || 'reader'; // reader, writer, owner
  
  if (!fileId || !email) {
    throw new Error('File ID and email are required for sharing');
  }
  
  const file = DriveApp.getFileById(fileId);
  
  switch (role) {
    case 'reader':
      file.addViewer(email);
      break;
    case 'writer':
      file.addEditor(email);
      break;
    case 'owner':
      file.setOwner(email);
      break;
    default:
      file.addViewer(email);
  }
  
  console.log(\`‚úÖ Shared file \${file.getName()} with \${email} as \${role}\`);
  return { ...inputData, driveShared: true, fileId: fileId, sharedWith: email, role: role };
}

function handleGetFilePermissions(params, inputData) {
  const fileId = params.fileId;
  
  if (!fileId) {
    throw new Error('File ID is required');
  }
  
  const file = DriveApp.getFileById(fileId);
  const permissions = {
    viewers: file.getViewers().map(user => user.getEmail()),
    editors: file.getEditors().map(user => user.getEmail()),
    owner: file.getOwner().getEmail(),
    sharingAccess: file.getSharingAccess().toString(),
    sharingPermission: file.getSharingPermission().toString()
  };
  
  console.log(\`‚úÖ Retrieved permissions for file: \${file.getName()}\`);
  return { ...inputData, drivePermissions: permissions, fileId: fileId };
}

function handleUpdateFileMetadata(params, inputData) {
  const fileId = params.fileId;
  
  if (!fileId) {
    throw new Error('File ID is required for metadata update');
  }
  
  const file = DriveApp.getFileById(fileId);
  
  if (params.name) file.setName(params.name);
  if (params.description) file.setDescription(params.description);
  
  console.log(\`‚úÖ Updated metadata for file: \${file.getName()}\`);
  return { ...inputData, driveUpdated: true, fileId: fileId };
}

function handleDriveTestConnection(params, inputData) {
  try {
    const user = Session.getActiveUser().getEmail();
    const rootFolder = DriveApp.getRootFolder();
    
    console.log(\`‚úÖ Google Drive connection test successful. User: \${user}\`);
    return { ...inputData, connectionTest: 'success', userEmail: user, rootFolderId: rootFolder.getId() };
  } catch (error) {
    console.error('‚ùå Drive connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleFileTrigger(params, inputData) {
  const folderId = params.folderId || params.parentId;
  const fileNamePattern = params.fileNamePattern || '';
  const mimeType = params.mimeType || '';
  
  let folder;
  if (folderId) {
    folder = DriveApp.getFolderById(folderId);
  } else {
    folder = DriveApp.getRootFolder();
  }
  
  const files = folder.getFiles();
  const fileList = [];
  
  while (files.hasNext()) {
    const file = files.next();
    
    // Apply filters
    let matchesPattern = true;
    if (fileNamePattern && !file.getName().includes(fileNamePattern)) {
      matchesPattern = false;
    }
    if (mimeType && file.getBlob().getContentType() !== mimeType) {
      matchesPattern = false;
    }
    
    if (matchesPattern) {
      fileList.push({
        id: file.getId(),
        name: file.getName(),
        mimeType: file.getBlob().getContentType(),
        size: file.getSize(),
        createdDate: file.getDateCreated().toISOString(),
        lastUpdated: file.getLastUpdated().toISOString(),
        url: file.getUrl()
      });
    }
  }
  
  console.log(\`üìÅ Found \${fileList.length} files in folder trigger\`);
  return { ...inputData, driveFiles: fileList, triggeredBy: 'file_watcher' };
}`;
}

function generateEmailTransformFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('üîß Executing Email transform: ${node.name || 'Extract Data'}');
  
  const fields = params.fields || ['subject', 'from', 'date'];
  const includeAttachments = params.includeAttachments || false;
  
  try {
    if (!inputData.emails || !Array.isArray(inputData.emails)) {
      console.log('‚ÑπÔ∏è No emails to transform');
      return { ...inputData, transformedEmails: [] };
    }
    
    const transformedEmails = inputData.emails.map(email => {
      const transformed = {};
      
      fields.forEach(field => {
        if (field === 'subject') transformed.subject = email.subject || '';
        if (field === 'from') transformed.from = email.from || '';
        if (field === 'date') transformed.date = email.date || '';
        if (field === 'body') transformed.body = email.body || '';
        if (field === 'threadId') transformed.threadId = email.threadId || '';
      });
      
      if (includeAttachments && email.attachments) {
        transformed.attachments = email.attachments;
      }
      
      return transformed;
    });
    
    console.log(\`üîß Transformed \${transformedEmails.length} emails with fields: \${fields.join(', ')}\`);
    return { ...inputData, transformedEmails, fields };
    
  } catch (error) {
    console.error('‚ùå Email transform failed:', error);
    return { ...inputData, transformError: error.message };
  }
}`;
}

function generateTimeTriggerFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(params) {
  console.log('‚è∞ Executing Time trigger: ${node.name || 'Scheduled Execution'}');
  
  const frequency = params.frequency || 'daily';
  const time = params.time || '09:00';
  
  try {
    const now = new Date();
    const [hours, minutes] = time.split(':').map(Number);
    
    console.log(\`‚è∞ Time trigger executed at \${now.toISOString()}\`);
    console.log(\`üìÖ Schedule: \${frequency} at \${time}\`);
    
    return { 
      triggerTime: now.toISOString(),
      frequency,
      scheduledTime: time,
      message: \`Workflow triggered by \${frequency} schedule at \${time}\`
    };
    
  } catch (error) {
    console.error('‚ùå Time trigger failed:', error);
    throw error;
  }
}`;
}

function generateSystemActionFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('üîß Executing System action: ${node.name || 'Log Activity'}');
  
  const message = params.message || 'Workflow executed';
  const level = params.level || 'info';
  
  try {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      inputData: Object.keys(inputData),
      nodeType: '${node.type}'
    };
    
    // Log to Apps Script console
    if (level === 'error') {
      console.error(\`[SYSTEM] \${message}\`);
    } else if (level === 'warn') {
      console.warn(\`[SYSTEM] \${message}\`);
    } else {
      console.log(\`[SYSTEM] \${message}\`);
    }
    
    // Store in PropertiesService for audit trail
    const logs = PropertiesService.getScriptProperties().getProperty('WORKFLOW_LOGS') || '[]';
    const logArray = JSON.parse(logs);
    logArray.push(logEntry);
    
    // Keep only last 100 logs
    if (logArray.length > 100) {
      logArray.splice(0, logArray.length - 100);
    }
    
    PropertiesService.getScriptProperties().setProperty('WORKFLOW_LOGS', JSON.stringify(logArray));
    
    console.log(\`‚úÖ System action completed: \${message}\`);
    return { ...inputData, systemLogged: true, logEntry };
    
  } catch (error) {
    console.error('‚ùå System action failed:', error);
    return { ...inputData, systemError: error.message };
  }
}`;
}

function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Popular app implementations

function generateShopifyActionFunction(functionName: string, node: WorkflowNode): string {
  return `
function ${functionName}(inputData, params) {
  console.log('üõçÔ∏è Executing Shopify action: ${node.name || 'Shopify Operation'}');
  
  const apiKey = PropertiesService.getScriptProperties().getProperty('SHOPIFY_API_KEY');
  const shopDomain = PropertiesService.getScriptProperties().getProperty('SHOPIFY_SHOP_DOMAIN');
  const apiVersion = '2023-07';
  
  if (!apiKey || !shopDomain) {
    console.warn('‚ö†Ô∏è Shopify API credentials not configured');
    return { ...inputData, shopifySkipped: true, error: 'Missing API credentials' };
  }
  
  try {
    const baseUrl = \`https://\${shopDomain}.myshopify.com/admin/api/\${apiVersion}\`;
    let endpoint = '';
    let method = 'GET';
    let payload = null;
    
    // Handle different Shopify operations
    if (params.operation === 'create_product') {
      endpoint = '/products.json';
      method = 'POST';
      payload = {
        product: {
          title: params.title || 'New Product',
          body_html: params.description || '',
          vendor: params.vendor || '',
          product_type: params.product_type || '',
          tags: params.tags || ''
        }
      };
    } else if (params.operation === 'get_orders') {
      endpoint = '/orders.json';
      method = 'GET';
    } else if (params.operation === 'create_customer') {
      endpoint = '/customers.json';
      method = 'POST';
      payload = {
        customer: {
          first_name: params.first_name || '',
          last_name: params.last_name || '',
          email: params.email || '',
          phone: params.phone || '',
          accepts_marketing: params.accepts_marketing || false
        }
      };
    }
    
    const options = {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'X-Shopify-Access-Token': apiKey
      }
    };
    
    if (payload) {
      options.payload = JSON.stringify(payload);
    }
    
    const response = UrlFetchApp.fetch(baseUrl + endpoint, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode >= 200 && responseCode < 300) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Shopify operation successful: \${params.operation}\`);
      return { ...inputData, shopifyResult: data, shopifySuccess: true };
    } else {
      console.error(\`‚ùå Shopify API error: \${responseCode}\`);
      return { ...inputData, shopifyError: \`API error: \${responseCode}\`, shopifySuccess: false };
    }
    
  } catch (error) {
    console.error('‚ùå Shopify action failed:', error);
    return { ...inputData, shopifyError: error.toString(), shopifySuccess: false };
  }
}`;
}

// Comprehensive Salesforce implementation
function generateSalesforceEnhancedFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'query_records';
  
  return `
function ${functionName}(inputData, params) {
  console.log('‚òÅÔ∏è Executing Salesforce: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('SALESFORCE_ACCESS_TOKEN');
  const instanceUrl = PropertiesService.getScriptProperties().getProperty('SALESFORCE_INSTANCE_URL');
  
  if (!accessToken || !instanceUrl) {
    console.warn('‚ö†Ô∏è Salesforce credentials not configured');
    return { ...inputData, salesforceSkipped: true, error: 'Missing OAuth credentials' };
  }
  
  try {
    switch (operation) {
      case 'query_records':
        return handleQueryRecords(accessToken, instanceUrl, params, inputData);
      case 'create_record':
        return handleCreateRecord(accessToken, instanceUrl, params, inputData);
      case 'update_record':
        return handleUpdateRecord(accessToken, instanceUrl, params, inputData);
      case 'delete_record':
        return handleDeleteRecord(accessToken, instanceUrl, params, inputData);
      case 'get_record':
        return handleGetRecord(accessToken, instanceUrl, params, inputData);
      case 'upsert_record':
        return handleUpsertRecord(accessToken, instanceUrl, params, inputData);
      case 'execute_apex':
        return handleExecuteApex(accessToken, instanceUrl, params, inputData);
      case 'test_connection':
        return handleSalesforceTestConnection(accessToken, instanceUrl, params, inputData);
      case 'record_created':
      case 'record_updated':
        return handleSalesforceTrigger(accessToken, instanceUrl, params, inputData);
      case 'create_lead':
        return handleCreateLead(accessToken, instanceUrl, params, inputData);
      case 'create_contact':
        return handleCreateContact(accessToken, instanceUrl, params, inputData);
      case 'create_opportunity':
        return handleCreateOpportunity(accessToken, instanceUrl, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Salesforce operation: \${operation}\`);
        return { ...inputData, salesforceWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Salesforce \${operation} failed:\`, error);
    return { ...inputData, salesforceError: error.toString(), salesforceSuccess: false };
  }
}

function handleQueryRecords(accessToken, instanceUrl, params, inputData) {
  const soql = params.soql || params.query || 'SELECT Id, Name FROM Account LIMIT 10';
  const endpoint = \`/services/data/v58.0/query/?q=\${encodeURIComponent(soql)}\`;
  
  const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
    method: 'GET',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Salesforce query returned \${data.totalSize} records\`);
    return { ...inputData, salesforceRecords: data.records, totalSize: data.totalSize, done: data.done };
  } else {
    throw new Error(\`Query failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateRecord(accessToken, instanceUrl, params, inputData) {
  const sobjectType = params.sobjectType || params.objectType || 'Lead';
  const fields = params.fields || {};
  
  const endpoint = \`/services/data/v58.0/sobjects/\${sobjectType}/\`;
  
  const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(fields)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Salesforce \${sobjectType} record: \${data.id}\`);
    return { ...inputData, salesforceCreated: true, recordId: data.id, sobjectType: sobjectType };
  } else {
    throw new Error(\`Create failed: \${response.getResponseCode()}\`);
  }
}

function handleUpdateRecord(accessToken, instanceUrl, params, inputData) {
  const sobjectType = params.sobjectType || params.objectType || 'Lead';
  const recordId = params.recordId || params.id;
  const fields = params.fields || {};
  
  if (!recordId) {
    throw new Error('Record ID is required for update');
  }
  
  const endpoint = \`/services/data/v58.0/sobjects/\${sobjectType}/\${recordId}\`;
  
  const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
    method: 'PATCH',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(fields)
  });
  
  if (response.getResponseCode() === 204) {
    console.log(\`‚úÖ Updated Salesforce \${sobjectType} record: \${recordId}\`);
    return { ...inputData, salesforceUpdated: true, recordId: recordId, sobjectType: sobjectType };
  } else {
    throw new Error(\`Update failed: \${response.getResponseCode()}\`);
  }
}

function handleDeleteRecord(accessToken, instanceUrl, params, inputData) {
  const sobjectType = params.sobjectType || params.objectType || 'Lead';
  const recordId = params.recordId || params.id;
  
  if (!recordId) {
    throw new Error('Record ID is required for deletion');
  }
  
  const endpoint = \`/services/data/v58.0/sobjects/\${sobjectType}/\${recordId}\`;
  
  const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
    method: 'DELETE',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`
    }
  });
  
  if (response.getResponseCode() === 204) {
    console.log(\`‚úÖ Deleted Salesforce \${sobjectType} record: \${recordId}\`);
    return { ...inputData, salesforceDeleted: true, recordId: recordId, sobjectType: sobjectType };
  } else {
    throw new Error(\`Delete failed: \${response.getResponseCode()}\`);
  }
}

function handleGetRecord(accessToken, instanceUrl, params, inputData) {
  const sobjectType = params.sobjectType || params.objectType || 'Lead';
  const recordId = params.recordId || params.id;
  const fields = params.fields ? params.fields.join(',') : null;
  
  if (!recordId) {
    throw new Error('Record ID is required');
  }
  
  let endpoint = \`/services/data/v58.0/sobjects/\${sobjectType}/\${recordId}\`;
  if (fields) {
    endpoint += \`?fields=\${fields}\`;
  }
  
  const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
    method: 'GET',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Retrieved Salesforce \${sobjectType} record: \${recordId}\`);
    return { ...inputData, salesforceRecord: data, recordId: recordId, sobjectType: sobjectType };
  } else {
    throw new Error(\`Get record failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateLead(accessToken, instanceUrl, params, inputData) {
  const leadData = {
    FirstName: params.firstName || params.first_name || inputData.firstName || inputData.first_name || '',
    LastName: params.lastName || params.last_name || inputData.lastName || inputData.last_name || 'Unknown',
    Email: params.email || inputData.email || '',
    Company: params.company || inputData.company || 'Unknown Company',
    Phone: params.phone || inputData.phone || '',
    LeadSource: params.leadSource || params.lead_source || 'Website',
    Status: params.status || 'Open - Not Contacted',
    Description: params.description || params.notes || ''
  };
  
  const response = UrlFetchApp.fetch(instanceUrl + '/services/data/v58.0/sobjects/Lead/', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(leadData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Salesforce Lead: \${data.id}\`);
    return { ...inputData, salesforceLeadCreated: true, leadId: data.id, leadData: leadData };
  } else {
    throw new Error(\`Create lead failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateContact(accessToken, instanceUrl, params, inputData) {
  const contactData = {
    FirstName: params.firstName || params.first_name || inputData.firstName || inputData.first_name || '',
    LastName: params.lastName || params.last_name || inputData.lastName || inputData.last_name || 'Unknown',
    Email: params.email || inputData.email || '',
    Phone: params.phone || inputData.phone || '',
    AccountId: params.accountId || params.account_id || null,
    Description: params.description || params.notes || ''
  };
  
  const response = UrlFetchApp.fetch(instanceUrl + '/services/data/v58.0/sobjects/Contact/', {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(contactData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Salesforce Contact: \${data.id}\`);
    return { ...inputData, salesforceContactCreated: true, contactId: data.id, contactData: contactData };
  } else {
    throw new Error(\`Create contact failed: \${response.getResponseCode()}\`);
  }
}

function handleSalesforceTestConnection(accessToken, instanceUrl, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(instanceUrl + '/services/data/', {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Salesforce connection test successful. Available versions: \${data.length}\`);
      return { ...inputData, connectionTest: 'success', availableVersions: data.length, instanceUrl: instanceUrl };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Salesforce connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleSalesforceTrigger(accessToken, instanceUrl, params, inputData) {
  // Simulate record monitoring by querying recent records
  const sobjectType = params.sobjectType || 'Lead';
  const timeFilter = params.timeFilter || 'LAST_N_DAYS:1';
  
  const soql = \`SELECT Id, Name, CreatedDate FROM \${sobjectType} WHERE CreatedDate >= \${timeFilter} ORDER BY CreatedDate DESC LIMIT 10\`;
  const endpoint = \`/services/data/v58.0/query/?q=\${encodeURIComponent(soql)}\`;
  
  try {
    const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`üìä Salesforce trigger found \${data.totalSize} recent \${sobjectType} records\`);
      return { ...inputData, salesforceTrigger: data.records, triggerCount: data.totalSize };
    } else {
      throw new Error(\`Trigger query failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Salesforce trigger failed:', error);
    return { ...inputData, salesforceTriggerError: error.toString() };
  }
}`;
}

// Comprehensive Jira implementation
function generateJiraEnhancedFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_issue';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üéØ Executing Jira: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const baseUrl = PropertiesService.getScriptProperties().getProperty('JIRA_BASE_URL');
  const email = PropertiesService.getScriptProperties().getProperty('JIRA_EMAIL');
  const apiToken = PropertiesService.getScriptProperties().getProperty('JIRA_API_TOKEN');
  
  if (!baseUrl || !email || !apiToken) {
    console.warn('‚ö†Ô∏è Jira credentials not configured');
    return { ...inputData, jiraSkipped: true, error: 'Missing Jira credentials' };
  }
  
  try {
    switch (operation) {
      case 'create_issue':
        return handleCreateIssue(baseUrl, email, apiToken, params, inputData);
      case 'update_issue':
        return handleUpdateIssue(baseUrl, email, apiToken, params, inputData);
      case 'get_issue':
        return handleGetIssue(baseUrl, email, apiToken, params, inputData);
      case 'search_issues':
        return handleSearchIssues(baseUrl, email, apiToken, params, inputData);
      case 'add_comment':
        return handleAddComment(baseUrl, email, apiToken, params, inputData);
      case 'transition_issue':
        return handleTransitionIssue(baseUrl, email, apiToken, params, inputData);
      case 'assign_issue':
        return handleAssignIssue(baseUrl, email, apiToken, params, inputData);
      case 'create_project':
        return handleCreateProject(baseUrl, email, apiToken, params, inputData);
      case 'get_project':
        return handleGetProject(baseUrl, email, apiToken, params, inputData);
      case 'list_projects':
        return handleListProjects(baseUrl, email, apiToken, params, inputData);
      case 'create_version':
        return handleCreateVersion(baseUrl, email, apiToken, params, inputData);
      case 'test_connection':
        return handleJiraTestConnection(baseUrl, email, apiToken, params, inputData);
      case 'issue_created':
      case 'issue_updated':
        return handleJiraTrigger(baseUrl, email, apiToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Jira operation: \${operation}\`);
        return { ...inputData, jiraWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Jira \${operation} failed:\`, error);
    return { ...inputData, jiraError: error.toString(), jiraSuccess: false };
  }
}

function handleCreateIssue(baseUrl, email, apiToken, params, inputData) {
  const issueData = {
    fields: {
      project: { key: params.projectKey || params.project_key || 'PROJ' },
      summary: params.summary || params.title || 'New Issue from Automation',
      description: params.description || params.body || '',
      issuetype: { name: params.issueType || params.issue_type || 'Task' },
      priority: params.priority ? { name: params.priority } : undefined,
      assignee: params.assignee ? { name: params.assignee } : null,
      labels: params.labels ? (Array.isArray(params.labels) ? params.labels : [params.labels]) : [],
      customfield_10000: params.customFields || null // Epic Link or other custom fields
    }
  };
  
  const auth = Utilities.base64Encode(\`\${email}:\${apiToken}\`);
  const response = UrlFetchApp.fetch(baseUrl + '/rest/api/3/issue', {
    method: 'POST',
    headers: {
      'Authorization': \`Basic \${auth}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(issueData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Jira issue: \${data.key}\`);
    return { ...inputData, jiraIssueCreated: true, issueKey: data.key, issueId: data.id };
  } else {
    throw new Error(\`Create issue failed: \${response.getResponseCode()}\`);
  }
}

function handleUpdateIssue(baseUrl, email, apiToken, params, inputData) {
  const issueKey = params.issueKey || params.issue_key;
  const fields = params.fields || {};
  
  if (!issueKey) {
    throw new Error('Issue key is required for update');
  }
  
  const auth = Utilities.base64Encode(\`\${email}:\${apiToken}\`);
  const response = UrlFetchApp.fetch(baseUrl + \`/rest/api/3/issue/\${issueKey}\`, {
    method: 'PUT',
    headers: {
      'Authorization': \`Basic \${auth}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({ fields: fields })
  });
  
  if (response.getResponseCode() === 204) {
    console.log(\`‚úÖ Updated Jira issue: \${issueKey}\`);
    return { ...inputData, jiraIssueUpdated: true, issueKey: issueKey };
  } else {
    throw new Error(\`Update issue failed: \${response.getResponseCode()}\`);
  }
}

function handleGetIssue(baseUrl, email, apiToken, params, inputData) {
  const issueKey = params.issueKey || params.issue_key;
  
  if (!issueKey) {
    throw new Error('Issue key is required');
  }
  
  const auth = Utilities.base64Encode(\`\${email}:\${apiToken}\`);
  const response = UrlFetchApp.fetch(baseUrl + \`/rest/api/3/issue/\${issueKey}\`, {
    method: 'GET',
    headers: {
      'Authorization': \`Basic \${auth}\`,
      'Accept': 'application/json'
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Retrieved Jira issue: \${data.key}\`);
    return { ...inputData, jiraIssue: data, issueKey: data.key, summary: data.fields.summary };
  } else {
    throw new Error(\`Get issue failed: \${response.getResponseCode()}\`);
  }
}

function handleSearchIssues(baseUrl, email, apiToken, params, inputData) {
  const jql = params.jql || params.query || 'project = PROJ ORDER BY created DESC';
  const maxResults = params.maxResults || 50;
  
  const auth = Utilities.base64Encode(\`\${email}:\${apiToken}\`);
  const response = UrlFetchApp.fetch(baseUrl + \`/rest/api/3/search?\` + 
    \`jql=\${encodeURIComponent(jql)}&maxResults=\${maxResults}\`, {
    method: 'GET',
    headers: {
      'Authorization': \`Basic \${auth}\`,
      'Accept': 'application/json'
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Found \${data.total} Jira issues matching query\`);
    return { ...inputData, jiraIssues: data.issues, total: data.total, jql: jql };
  } else {
    throw new Error(\`Search failed: \${response.getResponseCode()}\`);
  }
}

function handleAddComment(baseUrl, email, apiToken, params, inputData) {
  const issueKey = params.issueKey || params.issue_key;
  const comment = params.comment || params.body || 'Comment from automation';
  
  if (!issueKey) {
    throw new Error('Issue key is required for comment');
  }
  
  const auth = Utilities.base64Encode(\`\${email}:\${apiToken}\`);
  const response = UrlFetchApp.fetch(baseUrl + \`/rest/api/3/issue/\${issueKey}/comment\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Basic \${auth}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      body: {
        type: 'doc',
        version: 1,
        content: [{
          type: 'paragraph',
          content: [{
            type: 'text',
            text: comment
          }]
        }]
      }
    })
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Added comment to Jira issue: \${issueKey}\`);
    return { ...inputData, jiraCommentAdded: true, commentId: data.id, issueKey: issueKey };
  } else {
    throw new Error(\`Add comment failed: \${response.getResponseCode()}\`);
  }
}

function handleJiraTestConnection(baseUrl, email, apiToken, params, inputData) {
  try {
    const auth = Utilities.base64Encode(\`\${email}:\${apiToken}\`);
    const response = UrlFetchApp.fetch(baseUrl + '/rest/api/3/myself', {
      method: 'GET',
      headers: {
        'Authorization': \`Basic \${auth}\`,
        'Accept': 'application/json'
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Jira connection test successful. User: \${data.displayName}\`);
      return { ...inputData, connectionTest: 'success', userDisplayName: data.displayName, userEmail: data.emailAddress };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Jira connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleJiraTrigger(baseUrl, email, apiToken, params, inputData) {
  // Simulate issue monitoring by searching for recent issues
  const projectKey = params.projectKey || params.project_key || '';
  const timeFilter = params.timeFilter || 'created >= -1d';
  const jql = projectKey ? 
    \`project = \${projectKey} AND \${timeFilter} ORDER BY created DESC\` :
    \`\${timeFilter} ORDER BY created DESC\`;
  
  try {
    const auth = Utilities.base64Encode(\`\${email}:\${apiToken}\`);
    const response = UrlFetchApp.fetch(baseUrl + \`/rest/api/3/search?jql=\${encodeURIComponent(jql)}&maxResults=10\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Basic \${auth}\`,
        'Accept': 'application/json'
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`üéØ Jira trigger found \${data.total} recent issues\`);
      return { ...inputData, jiraTrigger: data.issues, triggerCount: data.total };
    } else {
      throw new Error(\`Trigger search failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Jira trigger failed:', error);
    return { ...inputData, jiraTriggerError: error.toString() };
  }
}`;
}

// Comprehensive Google Forms implementation
function generateGoogleFormsFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'list_responses';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üìù Executing Google Forms: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const formId = params.formId;
  
  try {
    switch (operation) {
      case 'create_form':
        return handleCreateForm(params, inputData);
      case 'get_form':
        return handleGetForm(formId, params, inputData);
      case 'batch_update':
        return handleBatchUpdate(formId, params, inputData);
      case 'add_question':
        return handleAddQuestion(formId, params, inputData);
      case 'update_form_info':
        return handleUpdateFormInfo(formId, params, inputData);
      case 'delete_item':
        return handleDeleteItem(formId, params, inputData);
      case 'list_responses':
      case 'get_responses':
        return handleListResponses(formId, params, inputData);
      case 'get_response':
        return handleGetResponse(formId, params, inputData);
      case 'test_connection':
        return handleFormsTestConnection(params, inputData);
      case 'form_submit':
      case 'response_submitted':
        return handleFormTrigger(formId, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Forms operation: \${operation}\`);
        return { ...inputData, formsWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Google Forms \${operation} failed:\`, error);
    return { ...inputData, formsError: error.toString(), formsSuccess: false };
  }
}

function handleCreateForm(params, inputData) {
  const title = params.title || 'New Form';
  const description = params.description || '';
  
  const form = FormApp.create(title);
  form.setDescription(description);
  
  // Set additional properties if provided
  if (params.collectEmail !== undefined) form.setCollectEmail(params.collectEmail);
  if (params.allowResponseEdits !== undefined) form.setAllowResponseEdits(params.allowResponseEdits);
  if (params.confirmationMessage) form.setConfirmationMessage(params.confirmationMessage);
  
  console.log(\`‚úÖ Created form: \${title} (\${form.getId()})\`);
  return { ...inputData, formCreated: true, formId: form.getId(), formTitle: title, formUrl: form.getPublishedUrl() };
}

function handleGetForm(formId, params, inputData) {
  if (!formId) {
    throw new Error('Form ID is required');
  }
  
  const form = FormApp.openById(formId);
  const formData = {
    id: form.getId(),
    title: form.getTitle(),
    description: form.getDescription(),
    publishedUrl: form.getPublishedUrl(),
    editUrl: form.getEditUrl(),
    acceptingResponses: form.isAcceptingResponses(),
    collectEmail: form.collectsEmail(),
    allowResponseEdits: form.canEditResponse(),
    confirmationMessage: form.getConfirmationMessage(),
    destinationId: form.getDestinationId(),
    items: form.getItems().map(item => ({
      id: item.getId(),
      title: item.getTitle(),
      type: item.getType().toString(),
      helpText: item.getHelpText()
    }))
  };
  
  console.log(\`‚úÖ Retrieved form: \${formData.title}\`);
  return { ...inputData, formData: formData };
}

function handleBatchUpdate(formId, params, inputData) {
  if (!formId) {
    throw new Error('Form ID is required');
  }
  
  const form = FormApp.openById(formId);
  const requests = params.requests || [];
  
  // Process batch update requests (simplified implementation)
  let updatesApplied = 0;
  
  requests.forEach(request => {
    try {
      if (request.updateFormInfo) {
        const info = request.updateFormInfo;
        if (info.title) form.setTitle(info.title);
        if (info.description) form.setDescription(info.description);
        updatesApplied++;
      }
    } catch (error) {
      console.warn('Failed to apply update request:', error);
    }
  });
  
  console.log(\`‚úÖ Applied \${updatesApplied} batch updates to form\`);
  return { ...inputData, formUpdated: true, updatesApplied: updatesApplied };
}

function handleAddQuestion(formId, params, inputData) {
  if (!formId) {
    throw new Error('Form ID is required');
  }
  
  const form = FormApp.openById(formId);
  const questionType = params.questionType || params.type || 'TEXT';
  const title = params.title || params.question || 'New Question';
  const helpText = params.helpText || params.description || '';
  const required = params.required !== false;
  
  let item;
  
  switch (questionType.toUpperCase()) {
    case 'TEXT':
      item = form.addTextItem();
      break;
    case 'PARAGRAPH_TEXT':
      item = form.addParagraphTextItem();
      break;
    case 'MULTIPLE_CHOICE':
      item = form.addMultipleChoiceItem();
      if (params.choices && Array.isArray(params.choices)) {
        item.setChoiceValues(params.choices);
      }
      break;
    case 'CHECKBOX':
      item = form.addCheckboxItem();
      if (params.choices && Array.isArray(params.choices)) {
        item.setChoiceValues(params.choices);
      }
      break;
    case 'LIST':
      item = form.addListItem();
      if (params.choices && Array.isArray(params.choices)) {
        item.setChoiceValues(params.choices);
      }
      break;
    case 'SCALE':
      item = form.addScaleItem();
      if (params.lowerBound) item.setBounds(params.lowerBound, params.upperBound || 5);
      break;
    case 'DATE':
      item = form.addDateItem();
      break;
    case 'TIME':
      item = form.addTimeItem();
      break;
    case 'DATETIME':
      item = form.addDateTimeItem();
      break;
    default:
      item = form.addTextItem();
  }
  
  item.setTitle(title);
  if (helpText) item.setHelpText(helpText);
  item.setRequired(required);
  
  console.log(\`‚úÖ Added \${questionType} question: \${title}\`);
  return { ...inputData, questionAdded: true, questionId: item.getId(), questionTitle: title };
}

function handleUpdateFormInfo(formId, params, inputData) {
  if (!formId) {
    throw new Error('Form ID is required');
  }
  
  const form = FormApp.openById(formId);
  
  if (params.title) form.setTitle(params.title);
  if (params.description) form.setDescription(params.description);
  if (params.acceptingResponses !== undefined) form.setAcceptingResponses(params.acceptingResponses);
  if (params.collectEmail !== undefined) form.setCollectEmail(params.collectEmail);
  if (params.allowResponseEdits !== undefined) form.setAllowResponseEdits(params.allowResponseEdits);
  if (params.confirmationMessage) form.setConfirmationMessage(params.confirmationMessage);
  
  console.log(\`‚úÖ Updated form info: \${form.getTitle()}\`);
  return { ...inputData, formUpdated: true, formId: formId };
}

function handleDeleteItem(formId, params, inputData) {
  if (!formId) {
    throw new Error('Form ID is required');
  }
  
  const form = FormApp.openById(formId);
  const itemId = params.itemId || params.questionId;
  
  if (!itemId) {
    throw new Error('Item ID is required for deletion');
  }
  
  const items = form.getItems();
  const item = items.find(i => i.getId().toString() === itemId.toString());
  
  if (!item) {
    throw new Error(\`Item with ID \${itemId} not found\`);
  }
  
  form.deleteItem(item);
  
  console.log(\`‚úÖ Deleted form item: \${itemId}\`);
  return { ...inputData, itemDeleted: true, deletedItemId: itemId };
}

function handleListResponses(formId, params, inputData) {
  if (!formId) {
    throw new Error('Form ID is required');
  }
  
  const form = FormApp.openById(formId);
  const responses = form.getResponses();
  const maxResults = params.maxResults || responses.length;
  
  const responseData = responses.slice(0, maxResults).map(response => {
    const itemResponses = response.getItemResponses();
    const answers = {};
    
    itemResponses.forEach(itemResponse => {
      const question = itemResponse.getItem().getTitle();
      answers[question] = itemResponse.getResponse();
    });
    
    return {
      id: response.getId(),
      timestamp: response.getTimestamp().toISOString(),
      respondentEmail: response.getRespondentEmail(),
      answers: answers
    };
  });
  
  console.log(\`‚úÖ Retrieved \${responseData.length} form responses\`);
  return { ...inputData, formResponses: responseData, responseCount: responseData.length };
}

function handleGetResponse(formId, params, inputData) {
  if (!formId) {
    throw new Error('Form ID is required');
  }
  
  const form = FormApp.openById(formId);
  const responseId = params.responseId;
  
  if (!responseId) {
    throw new Error('Response ID is required');
  }
  
  const responses = form.getResponses();
  const response = responses.find(r => r.getId() === responseId);
  
  if (!response) {
    throw new Error(\`Response with ID \${responseId} not found\`);
  }
  
  const itemResponses = response.getItemResponses();
  const answers = {};
  
  itemResponses.forEach(itemResponse => {
    const question = itemResponse.getItem().getTitle();
    answers[question] = itemResponse.getResponse();
  });
  
  const responseData = {
    id: response.getId(),
    timestamp: response.getTimestamp().toISOString(),
    respondentEmail: response.getRespondentEmail(),
    answers: answers
  };
  
  console.log(\`‚úÖ Retrieved specific response: \${responseId}\`);
  return { ...inputData, formResponse: responseData };
}

function handleFormsTestConnection(params, inputData) {
  try {
    const user = Session.getActiveUser().getEmail();
    
    console.log(\`‚úÖ Google Forms connection test successful. User: \${user}\`);
    return { ...inputData, connectionTest: 'success', userEmail: user };
  } catch (error) {
    console.error('‚ùå Forms connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleFormTrigger(formId, params, inputData) {
  if (!formId) {
    throw new Error('Form ID is required for trigger');
  }
  
  const form = FormApp.openById(formId);
  const responses = form.getResponses();
  
  // Get the most recent responses (for trigger simulation)
  const recentResponses = responses.slice(-5); // Last 5 responses
  
  const triggerData = recentResponses.map(response => {
    const itemResponses = response.getItemResponses();
    const answers = {};
    
    itemResponses.forEach(itemResponse => {
      const question = itemResponse.getItem().getTitle();
      answers[question] = itemResponse.getResponse();
    });
    
    return {
      id: response.getId(),
      timestamp: response.getTimestamp().toISOString(),
      respondentEmail: response.getRespondentEmail(),
      answers: answers,
      triggeredBy: 'form_submission'
    };
  });
  
  console.log(\`üìù Form trigger detected \${triggerData.length} recent responses\`);
  return { ...inputData, formTrigger: triggerData, formId: formId };
}`;
}

// Comprehensive Mailchimp implementation
function generateMailchimpEnhancedFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'add_subscriber';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üìß Executing Mailchimp: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const apiKey = PropertiesService.getScriptProperties().getProperty('MAILCHIMP_API_KEY');
  
  if (!apiKey) {
    console.warn('‚ö†Ô∏è Mailchimp API key not configured');
    return { ...inputData, mailchimpSkipped: true, error: 'Missing API key' };
  }
  
  try {
    const datacenter = apiKey.split('-')[1];
    const baseUrl = \`https://\${datacenter}.api.mailchimp.com/3.0\`;
    
    switch (operation) {
      case 'add_subscriber':
      case 'create_member':
        return handleAddSubscriber(baseUrl, apiKey, params, inputData);
      case 'update_subscriber':
        return handleUpdateSubscriber(baseUrl, apiKey, params, inputData);
      case 'get_subscriber':
        return handleGetSubscriber(baseUrl, apiKey, params, inputData);
      case 'remove_subscriber':
        return handleRemoveSubscriber(baseUrl, apiKey, params, inputData);
      case 'get_lists':
      case 'list_audiences':
        return handleGetLists(baseUrl, apiKey, params, inputData);
      case 'create_campaign':
        return handleCreateCampaign(baseUrl, apiKey, params, inputData);
      case 'send_campaign':
        return handleSendCampaign(baseUrl, apiKey, params, inputData);
      case 'test_connection':
        return handleMailchimpTestConnection(baseUrl, apiKey, params, inputData);
      case 'subscriber_added':
      case 'campaign_sent':
        return handleMailchimpTrigger(baseUrl, apiKey, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Mailchimp operation: \${operation}\`);
        return { ...inputData, mailchimpWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Mailchimp \${operation} failed:\`, error);
    return { ...inputData, mailchimpError: error.toString(), mailchimpSuccess: false };
  }
}

function handleAddSubscriber(baseUrl, apiKey, params, inputData) {
  const listId = params.listId || params.list_id || params.audienceId;
  const email = params.email || inputData.email;
  
  if (!listId || !email) {
    throw new Error('List ID and email are required');
  }
  
  const subscriberData = {
    email_address: email,
    status: params.status || 'subscribed',
    merge_fields: {
      FNAME: params.firstName || params.first_name || inputData.firstName || inputData.first_name || '',
      LNAME: params.lastName || params.last_name || inputData.lastName || inputData.last_name || ''
    },
    interests: params.interests || {},
    tags: params.tags ? (Array.isArray(params.tags) ? params.tags : params.tags.split(',')) : []
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/lists/\${listId}/members\`, {
    method: 'POST',
    headers: {
      'Authorization': \`apikey \${apiKey}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(subscriberData)
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Added subscriber to Mailchimp: \${email}\`);
    return { ...inputData, mailchimpSubscribed: true, subscriberId: data.id, email: email };
  } else {
    throw new Error(\`Add subscriber failed: \${response.getResponseCode()}\`);
  }
}

function handleGetLists(baseUrl, apiKey, params, inputData) {
  const count = params.count || params.limit || 10;
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/lists?count=\${count}\`, {
    method: 'GET',
    headers: {
      'Authorization': \`apikey \${apiKey}\`
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Retrieved \${data.lists.length} Mailchimp lists\`);
    return { ...inputData, mailchimpLists: data.lists, listCount: data.lists.length };
  } else {
    throw new Error(\`Get lists failed: \${response.getResponseCode()}\`);
  }
}

function handleMailchimpTestConnection(baseUrl, apiKey, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/ping\`, {
      method: 'GET',
      headers: {
        'Authorization': \`apikey \${apiKey}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Mailchimp connection test successful. Account: \${data.account_name}\`);
      return { ...inputData, connectionTest: 'success', accountName: data.account_name };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Mailchimp connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive HubSpot implementation  
function generateHubspotEnhancedFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_contact';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üéØ Executing HubSpot: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('HUBSPOT_ACCESS_TOKEN');
  
  if (!accessToken) {
    console.warn('‚ö†Ô∏è HubSpot access token not configured');
    return { ...inputData, hubspotSkipped: true, error: 'Missing access token' };
  }
  
  try {
    const baseUrl = 'https://api.hubapi.com';
    
    switch (operation) {
      case 'create_contact':
        return handleCreateHubSpotContact(baseUrl, accessToken, params, inputData);
      case 'update_contact':
        return handleUpdateHubSpotContact(baseUrl, accessToken, params, inputData);
      case 'get_contact':
        return handleGetHubSpotContact(baseUrl, accessToken, params, inputData);
      case 'search_contacts':
        return handleSearchHubSpotContacts(baseUrl, accessToken, params, inputData);
      case 'create_deal':
        return handleCreateHubSpotDeal(baseUrl, accessToken, params, inputData);
      case 'update_deal':
        return handleUpdateHubSpotDeal(baseUrl, accessToken, params, inputData);
      case 'create_company':
        return handleCreateHubSpotCompany(baseUrl, accessToken, params, inputData);
      case 'create_task':
        return handleCreateHubSpotTask(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleHubSpotTestConnection(baseUrl, accessToken, params, inputData);
      case 'contact_created':
      case 'deal_updated':
        return handleHubSpotTrigger(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown HubSpot operation: \${operation}\`);
        return { ...inputData, hubspotWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå HubSpot \${operation} failed:\`, error);
    return { ...inputData, hubspotError: error.toString(), hubspotSuccess: false };
  }
}

function handleCreateHubSpotContact(baseUrl, accessToken, params, inputData) {
  const contactData = {
    properties: {
      firstname: params.firstName || params.first_name || inputData.firstName || inputData.first_name || '',
      lastname: params.lastName || params.last_name || inputData.lastName || inputData.last_name || '',
      email: params.email || inputData.email || '',
      company: params.company || inputData.company || '',
      phone: params.phone || inputData.phone || '',
      website: params.website || inputData.website || '',
      jobtitle: params.jobTitle || params.job_title || inputData.jobTitle || '',
      lifecyclestage: params.lifecycleStage || 'lead'
    }
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/crm/v3/objects/contacts\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(contactData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created HubSpot contact: \${data.id}\`);
    return { ...inputData, hubspotContactCreated: true, contactId: data.id, email: contactData.properties.email };
  } else {
    throw new Error(\`Create contact failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateHubSpotDeal(baseUrl, accessToken, params, inputData) {
  const dealData = {
    properties: {
      dealname: params.dealName || params.deal_name || 'New Deal from Automation',
      amount: params.amount || '0',
      dealstage: params.dealStage || params.deal_stage || 'appointmentscheduled',
      pipeline: params.pipeline || 'default',
      closedate: params.closeDate || params.close_date || null,
      dealtype: params.dealType || params.deal_type || 'newbusiness'
    }
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/crm/v3/objects/deals\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(dealData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created HubSpot deal: \${data.id}\`);
    return { ...inputData, hubspotDealCreated: true, dealId: data.id, dealName: dealData.properties.dealname };
  } else {
    throw new Error(\`Create deal failed: \${response.getResponseCode()}\`);
  }
}

function handleHubSpotTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/crm/v3/owners\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ HubSpot connection test successful. Found \${data.results.length} owners\`);
      return { ...inputData, connectionTest: 'success', ownerCount: data.results.length };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå HubSpot connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive Pipedrive implementation
function generatePipedriveFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'get_deals';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üíº Executing Pipedrive: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const apiToken = PropertiesService.getScriptProperties().getProperty('PIPEDRIVE_API_TOKEN');
  const companyDomain = PropertiesService.getScriptProperties().getProperty('PIPEDRIVE_COMPANY_DOMAIN');
  
  if (!apiToken || !companyDomain) {
    console.warn('‚ö†Ô∏è Pipedrive credentials not configured');
    return { ...inputData, pipedriveSkipped: true, error: 'Missing API token or company domain' };
  }
  
  try {
    const baseUrl = \`https://\${companyDomain}.pipedrive.com/api/v1\`;
    
    switch (operation) {
      case 'get_deals':
        return handleGetDeals(baseUrl, apiToken, params, inputData);
      case 'create_deal':
        return handleCreateDeal(baseUrl, apiToken, params, inputData);
      case 'update_deal':
        return handleUpdateDeal(baseUrl, apiToken, params, inputData);
      case 'get_persons':
        return handleGetPersons(baseUrl, apiToken, params, inputData);
      case 'create_person':
        return handleCreatePerson(baseUrl, apiToken, params, inputData);
      case 'get_organizations':
        return handleGetOrganizations(baseUrl, apiToken, params, inputData);
      case 'create_organization':
        return handleCreateOrganization(baseUrl, apiToken, params, inputData);
      case 'get_activities':
        return handleGetActivities(baseUrl, apiToken, params, inputData);
      case 'create_activity':
        return handleCreateActivity(baseUrl, apiToken, params, inputData);
      case 'test_connection':
        return handlePipedriveTestConnection(baseUrl, apiToken, params, inputData);
      case 'deal_created':
      case 'deal_updated':
        return handlePipedriveTrigger(baseUrl, apiToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Pipedrive operation: \${operation}\`);
        return { ...inputData, pipedriveWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Pipedrive \${operation} failed:\`, error);
    return { ...inputData, pipedriveError: error.toString(), pipedriveSuccess: false };
  }
}

function handleGetDeals(baseUrl, apiToken, params, inputData) {
  const status = params.status || 'all_not_deleted';
  const limit = params.limit || 100;
  const userId = params.user_id || null;
  
  let endpoint = \`/deals?api_token=\${apiToken}&status=\${status}&limit=\${limit}\`;
  if (userId) endpoint += \`&user_id=\${userId}\`;
  
  const response = UrlFetchApp.fetch(baseUrl + endpoint, {
    method: 'GET',
    headers: {
      'Accept': 'application/json'
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Retrieved \${data.data?.length || 0} Pipedrive deals\`);
    return { ...inputData, pipedriveDeals: data.data, dealCount: data.data?.length || 0 };
  } else {
    throw new Error(\`Get deals failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateDeal(baseUrl, apiToken, params, inputData) {
  const dealData = {
    title: params.title || params.deal_name || 'New Deal from Automation',
    value: params.value || params.amount || 0,
    currency: params.currency || 'USD',
    user_id: params.user_id || null,
    person_id: params.person_id || null,
    org_id: params.org_id || params.organization_id || null,
    stage_id: params.stage_id || null,
    status: params.status || 'open',
    expected_close_date: params.expected_close_date || null,
    probability: params.probability || null,
    lost_reason: params.lost_reason || null,
    visible_to: params.visible_to || '3' // Owner & followers
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/deals?api_token=\${apiToken}\`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    payload: JSON.stringify(dealData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Pipedrive deal: \${data.data.title} (ID: \${data.data.id})\`);
    return { ...inputData, pipedriveDealCreated: true, dealId: data.data.id, dealTitle: data.data.title };
  } else {
    throw new Error(\`Create deal failed: \${response.getResponseCode()}\`);
  }
}

function handleCreatePerson(baseUrl, apiToken, params, inputData) {
  const personData = {
    name: params.name || \`\${params.first_name || inputData.first_name || ''} \${params.last_name || inputData.last_name || ''}\`.trim() || 'Unknown Person',
    email: [{ value: params.email || inputData.email || '', primary: true }],
    phone: params.phone || inputData.phone ? [{ value: params.phone || inputData.phone, primary: true }] : [],
    org_id: params.org_id || params.organization_id || null,
    owner_id: params.owner_id || params.user_id || null,
    visible_to: params.visible_to || '3'
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/persons?api_token=\${apiToken}\`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    payload: JSON.stringify(personData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Pipedrive person: \${data.data.name} (ID: \${data.data.id})\`);
    return { ...inputData, pipedrivePersonCreated: true, personId: data.data.id, personName: data.data.name };
  } else {
    throw new Error(\`Create person failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateOrganization(baseUrl, apiToken, params, inputData) {
  const orgData = {
    name: params.name || params.company_name || inputData.company || 'New Organization',
    owner_id: params.owner_id || params.user_id || null,
    visible_to: params.visible_to || '3',
    address: params.address || '',
    address_subpremise: params.address_subpremise || '',
    address_street_number: params.address_street_number || '',
    address_route: params.address_route || '',
    address_sublocality: params.address_sublocality || '',
    address_locality: params.address_locality || '',
    address_admin_area_level_1: params.address_admin_area_level_1 || '',
    address_admin_area_level_2: params.address_admin_area_level_2 || '',
    address_country: params.address_country || '',
    address_postal_code: params.address_postal_code || ''
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/organizations?api_token=\${apiToken}\`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    payload: JSON.stringify(orgData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Pipedrive organization: \${data.data.name} (ID: \${data.data.id})\`);
    return { ...inputData, pipedriveOrgCreated: true, orgId: data.data.id, orgName: data.data.name };
  } else {
    throw new Error(\`Create organization failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateActivity(baseUrl, apiToken, params, inputData) {
  const activityData = {
    subject: params.subject || params.title || 'New Activity from Automation',
    type: params.type || 'call',
    due_date: params.due_date || new Date().toISOString().split('T')[0],
    due_time: params.due_time || '09:00',
    duration: params.duration || '01:00',
    deal_id: params.deal_id || null,
    person_id: params.person_id || null,
    org_id: params.org_id || null,
    note: params.note || params.description || '',
    done: params.done || '0',
    user_id: params.user_id || null
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/activities?api_token=\${apiToken}\`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    payload: JSON.stringify(activityData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Pipedrive activity: \${data.data.subject} (ID: \${data.data.id})\`);
    return { ...inputData, pipedriveActivityCreated: true, activityId: data.data.id, activitySubject: data.data.subject };
  } else {
    throw new Error(\`Create activity failed: \${response.getResponseCode()}\`);
  }
}

function handlePipedriveTestConnection(baseUrl, apiToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/users/me?api_token=\${apiToken}\`, {
      method: 'GET',
      headers: {
        'Accept': 'application/json'
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Pipedrive connection test successful. User: \${data.data.name}\`);
      return { ...inputData, connectionTest: 'success', userName: data.data.name, userEmail: data.data.email };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Pipedrive connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handlePipedriveTrigger(baseUrl, apiToken, params, inputData) {
  // Simulate deal monitoring by getting recent deals
  const sinceDate = new Date();
  sinceDate.setHours(sinceDate.getHours() - 24); // Last 24 hours
  const since = sinceDate.toISOString().split('T')[0];
  
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/deals?api_token=\${apiToken}&status=all_not_deleted&start=0&limit=50\`, {
      method: 'GET',
      headers: {
        'Accept': 'application/json'
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      const recentDeals = (data.data || []).filter(deal => {
        const addTime = new Date(deal.add_time);
        return addTime >= sinceDate;
      });
      
      console.log(\`üíº Pipedrive trigger found \${recentDeals.length} recent deals\`);
      return { ...inputData, pipedriveTrigger: recentDeals, triggerCount: recentDeals.length };
    } else {
      throw new Error(\`Trigger check failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Pipedrive trigger failed:', error);
    return { ...inputData, pipedriveTriggerError: error.toString() };
  }
}`;
}

// Comprehensive Zoho CRM implementation
function generateZohoCRMFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_record';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üè¢ Executing Zoho CRM: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('ZOHO_CRM_ACCESS_TOKEN');
  const orgId = PropertiesService.getScriptProperties().getProperty('ZOHO_CRM_ORG_ID');
  
  if (!accessToken) {
    console.warn('‚ö†Ô∏è Zoho CRM access token not configured');
    return { ...inputData, zohoCrmSkipped: true, error: 'Missing access token' };
  }
  
  try {
    const baseUrl = 'https://www.zohoapis.com/crm/v2';
    
    switch (operation) {
      case 'create_record':
        return handleCreateZohoRecord(baseUrl, accessToken, params, inputData);
      case 'get_record':
        return handleGetZohoRecord(baseUrl, accessToken, params, inputData);
      case 'update_record':
        return handleUpdateZohoRecord(baseUrl, accessToken, params, inputData);
      case 'delete_record':
        return handleDeleteZohoRecord(baseUrl, accessToken, params, inputData);
      case 'search_records':
        return handleSearchZohoRecords(baseUrl, accessToken, params, inputData);
      case 'list_records':
        return handleListZohoRecords(baseUrl, accessToken, params, inputData);
      case 'convert_lead':
        return handleConvertZohoLead(baseUrl, accessToken, params, inputData);
      case 'upload_attachment':
        return handleUploadZohoAttachment(baseUrl, accessToken, params, inputData);
      case 'add_note':
        return handleAddZohoNote(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleZohoCRMTestConnection(baseUrl, accessToken, params, inputData);
      case 'record_created':
      case 'record_updated':
        return handleZohoCRMTrigger(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Zoho CRM operation: \${operation}\`);
        return { ...inputData, zohoCrmWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Zoho CRM \${operation} failed:\`, error);
    return { ...inputData, zohoCrmError: error.toString(), zohoCrmSuccess: false };
  }
}

function handleCreateZohoRecord(baseUrl, accessToken, params, inputData) {
  const module = params.module || 'Leads';
  const recordData = {
    data: [{
      Company: params.company || inputData.company || 'Unknown Company',
      Last_Name: params.lastName || params.last_name || inputData.last_name || 'Unknown',
      First_Name: params.firstName || params.first_name || inputData.first_name || '',
      Email: params.email || inputData.email || '',
      Phone: params.phone || inputData.phone || '',
      Lead_Source: params.leadSource || params.lead_source || 'Website',
      Lead_Status: params.leadStatus || params.lead_status || 'Not Contacted',
      Description: params.description || params.notes || ''
    }]
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/\${module}\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Zoho-oauthtoken \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(recordData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    const record = data.data[0];
    console.log(\`‚úÖ Created Zoho CRM \${module} record: \${record.details.id}\`);
    return { ...inputData, zohoCrmRecordCreated: true, recordId: record.details.id, module: module };
  } else {
    throw new Error(\`Create record failed: \${response.getResponseCode()}\`);
  }
}

function handleGetZohoRecord(baseUrl, accessToken, params, inputData) {
  const module = params.module || 'Leads';
  const recordId = params.recordId || params.record_id;
  
  if (!recordId) {
    throw new Error('Record ID is required');
  }
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/\${module}/\${recordId}\`, {
    method: 'GET',
    headers: {
      'Authorization': \`Zoho-oauthtoken \${accessToken}\`
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Retrieved Zoho CRM \${module} record: \${recordId}\`);
    return { ...inputData, zohoCrmRecord: data.data[0], recordId: recordId, module: module };
  } else {
    throw new Error(\`Get record failed: \${response.getResponseCode()}\`);
  }
}

function handleListZohoRecords(baseUrl, accessToken, params, inputData) {
  const module = params.module || 'Leads';
  const page = params.page || 1;
  const perPage = params.per_page || params.limit || 200;
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/\${module}?page=\${page}&per_page=\${perPage}\`, {
    method: 'GET',
    headers: {
      'Authorization': \`Zoho-oauthtoken \${accessToken}\`
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Listed \${data.data?.length || 0} Zoho CRM \${module} records\`);
    return { ...inputData, zohoCrmRecords: data.data, recordCount: data.data?.length || 0, module: module };
  } else {
    throw new Error(\`List records failed: \${response.getResponseCode()}\`);
  }
}

function handleZohoCRMTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/settings/users?type=CurrentUser\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Zoho-oauthtoken \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      const user = data.users[0];
      console.log(\`‚úÖ Zoho CRM connection test successful. User: \${user.full_name}\`);
      return { ...inputData, connectionTest: 'success', userName: user.full_name, userEmail: user.email };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Zoho CRM connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleZohoCRMTrigger(baseUrl, accessToken, params, inputData) {
  const module = params.module || 'Leads';
  const converted = params.converted || 'false';
  
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/\${module}?converted=\${converted}&page=1&per_page=10\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Zoho-oauthtoken \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`üè¢ Zoho CRM trigger found \${data.data?.length || 0} recent \${module} records\`);
      return { ...inputData, zohoCrmTrigger: data.data, triggerCount: data.data?.length || 0 };
    } else {
      throw new Error(\`Trigger check failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Zoho CRM trigger failed:', error);
    return { ...inputData, zohoCrmTriggerError: error.toString() };
  }
}`;
}

// Comprehensive Microsoft Dynamics 365 implementation
function generateDynamics365Function(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_account';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üè¨ Executing Microsoft Dynamics 365: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('DYNAMICS365_ACCESS_TOKEN');
  const instanceUrl = PropertiesService.getScriptProperties().getProperty('DYNAMICS365_INSTANCE_URL');
  
  if (!accessToken || !instanceUrl) {
    console.warn('‚ö†Ô∏è Dynamics 365 credentials not configured');
    return { ...inputData, dynamics365Skipped: true, error: 'Missing access token or instance URL' };
  }
  
  try {
    const baseUrl = \`\${instanceUrl}/api/data/v9.2\`;
    
    switch (operation) {
      case 'create_account':
        return handleCreateD365Account(baseUrl, accessToken, params, inputData);
      case 'get_account':
        return handleGetD365Account(baseUrl, accessToken, params, inputData);
      case 'update_account':
        return handleUpdateD365Account(baseUrl, accessToken, params, inputData);
      case 'list_accounts':
        return handleListD365Accounts(baseUrl, accessToken, params, inputData);
      case 'create_contact':
        return handleCreateD365Contact(baseUrl, accessToken, params, inputData);
      case 'create_lead':
        return handleCreateD365Lead(baseUrl, accessToken, params, inputData);
      case 'create_opportunity':
        return handleCreateD365Opportunity(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleDynamics365TestConnection(baseUrl, accessToken, params, inputData);
      case 'account_created':
      case 'lead_created':
      case 'opportunity_won':
        return handleDynamics365Trigger(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Dynamics 365 operation: \${operation}\`);
        return { ...inputData, dynamics365Warning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Dynamics 365 \${operation} failed:\`, error);
    return { ...inputData, dynamics365Error: error.toString(), dynamics365Success: false };
  }
}

function handleCreateD365Account(baseUrl, accessToken, params, inputData) {
  const accountData = {
    name: params.name || params.company_name || inputData.company || 'New Account',
    websiteurl: params.website || inputData.website || '',
    telephone1: params.phone || inputData.phone || '',
    emailaddress1: params.email || inputData.email || '',
    address1_line1: params.address1 || '',
    address1_city: params.city || '',
    address1_stateorprovince: params.state || '',
    address1_postalcode: params.postalcode || '',
    address1_country: params.country || '',
    description: params.description || ''
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/accounts\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json',
      'OData-MaxVersion': '4.0',
      'OData-Version': '4.0'
    },
    payload: JSON.stringify(accountData)
  });
  
  if (response.getResponseCode() === 204) {
    const location = response.getHeaders()['OData-EntityId'] || response.getHeaders()['Location'];
    const accountId = location ? location.match(/\(([^)]+)\)/)?.[1] : 'unknown';
    console.log(\`‚úÖ Created Dynamics 365 account: \${accountData.name} (ID: \${accountId})\`);
    return { ...inputData, dynamics365AccountCreated: true, accountId: accountId, accountName: accountData.name };
  } else {
    throw new Error(\`Create account failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateD365Contact(baseUrl, accessToken, params, inputData) {
  const contactData = {
    firstname: params.firstName || params.first_name || inputData.first_name || '',
    lastname: params.lastName || params.last_name || inputData.last_name || 'Unknown',
    emailaddress1: params.email || inputData.email || '',
    telephone1: params.phone || inputData.phone || '',
    jobtitle: params.jobTitle || params.job_title || '',
    description: params.description || ''
  };
  
  // Link to account if provided
  if (params.parentaccountid || params.account_id) {
    contactData['parentcustomerid_account@odata.bind'] = \`/accounts(\${params.parentaccountid || params.account_id})\`;
  }
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/contacts\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json',
      'OData-MaxVersion': '4.0',
      'OData-Version': '4.0'
    },
    payload: JSON.stringify(contactData)
  });
  
  if (response.getResponseCode() === 204) {
    const location = response.getHeaders()['OData-EntityId'] || response.getHeaders()['Location'];
    const contactId = location ? location.match(/\(([^)]+)\)/)?.[1] : 'unknown';
    console.log(\`‚úÖ Created Dynamics 365 contact: \${contactData.firstname} \${contactData.lastname} (ID: \${contactId})\`);
    return { ...inputData, dynamics365ContactCreated: true, contactId: contactId, contactName: \`\${contactData.firstname} \${contactData.lastname}\` };
  } else {
    throw new Error(\`Create contact failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateD365Lead(baseUrl, accessToken, params, inputData) {
  const leadData = {
    subject: params.subject || params.title || 'New Lead from Automation',
    firstname: params.firstName || params.first_name || inputData.first_name || '',
    lastname: params.lastName || params.last_name || inputData.last_name || 'Unknown',
    emailaddress1: params.email || inputData.email || '',
    telephone1: params.phone || inputData.phone || '',
    companyname: params.company || inputData.company || '',
    websiteurl: params.website || inputData.website || '',
    leadsourcecode: 1, // Web
    description: params.description || ''
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/leads\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json',
      'OData-MaxVersion': '4.0',
      'OData-Version': '4.0'
    },
    payload: JSON.stringify(leadData)
  });
  
  if (response.getResponseCode() === 204) {
    const location = response.getHeaders()['OData-EntityId'] || response.getHeaders()['Location'];
    const leadId = location ? location.match(/\(([^)]+)\)/)?.[1] : 'unknown';
    console.log(\`‚úÖ Created Dynamics 365 lead: \${leadData.subject} (ID: \${leadId})\`);
    return { ...inputData, dynamics365LeadCreated: true, leadId: leadId, leadSubject: leadData.subject };
  } else {
    throw new Error(\`Create lead failed: \${response.getResponseCode()}\`);
  }
}

function handleDynamics365TestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/WhoAmI\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`,
        'OData-MaxVersion': '4.0',
        'OData-Version': '4.0'
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Dynamics 365 connection test successful. User ID: \${data.UserId}\`);
      return { ...inputData, connectionTest: 'success', userId: data.UserId, businessUnitId: data.BusinessUnitId };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Dynamics 365 connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleDynamics365Trigger(baseUrl, accessToken, params, inputData) {
  const entity = params.entity || 'leads';
  const filter = params.filter || '';
  
  try {
    let endpoint = \`\${baseUrl}/\${entity}?\`;
    if (filter) endpoint += \`$filter=\${encodeURIComponent(filter)}&\`;
    endpoint += '$top=10&$orderby=createdon desc';
    
    const response = UrlFetchApp.fetch(endpoint, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`,
        'OData-MaxVersion': '4.0',
        'OData-Version': '4.0'
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`üè¨ Dynamics 365 trigger found \${data.value?.length || 0} recent \${entity} records\`);
      return { ...inputData, dynamics365Trigger: data.value, triggerCount: data.value?.length || 0 };
    } else {
      throw new Error(\`Trigger check failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Dynamics 365 trigger failed:', error);
    return { ...inputData, dynamics365TriggerError: error.toString() };
  }
}`;
}

// Comprehensive Google Contacts implementation
function generateGoogleContactsFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_contact';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üìá Executing Google Contacts: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  
  try {
    switch (operation) {
      case 'create_contact':
        return handleCreateGoogleContact(params, inputData);
      case 'get_contact':
        return handleGetGoogleContact(params, inputData);
      case 'update_contact':
        return handleUpdateGoogleContact(params, inputData);
      case 'delete_contact':
        return handleDeleteGoogleContact(params, inputData);
      case 'list_contacts':
        return handleListGoogleContacts(params, inputData);
      case 'search_contacts':
        return handleSearchGoogleContacts(params, inputData);
      case 'create_contact_group':
        return handleCreateContactGroup(params, inputData);
      case 'list_contact_groups':
        return handleListContactGroups(params, inputData);
      case 'test_connection':
        return handleGoogleContactsTestConnection(params, inputData);
      case 'contact_created':
      case 'contact_updated':
        return handleGoogleContactsTrigger(params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Google Contacts operation: \${operation}\`);
        return { ...inputData, googleContactsWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Google Contacts \${operation} failed:\`, error);
    return { ...inputData, googleContactsError: error.toString(), googleContactsSuccess: false };
  }
}

function handleCreateGoogleContact(params, inputData) {
  const contact = ContactsApp.createContact(
    params.firstName || params.first_name || inputData.first_name || '',
    params.lastName || params.last_name || inputData.last_name || 'Unknown'
  );
  
  // Add additional fields
  if (params.email || inputData.email) {
    contact.addEmail(params.email || inputData.email);
  }
  
  if (params.phone || inputData.phone) {
    contact.addPhone(ContactsApp.Field.MOBILE_PHONE, params.phone || inputData.phone);
  }
  
  if (params.company || inputData.company) {
    contact.addCompany(params.company || inputData.company, params.jobTitle || params.job_title || '');
  }
  
  if (params.address) {
    contact.addAddress(ContactsApp.Field.HOME_ADDRESS, params.address);
  }
  
  if (params.notes || params.description) {
    contact.setNotes(params.notes || params.description);
  }
  
  console.log(\`‚úÖ Created Google contact: \${contact.getFullName()}\`);
  return { 
    ...inputData, 
    googleContactCreated: true, 
    contactId: contact.getId(), 
    contactName: contact.getFullName(),
    contactEmail: contact.getEmails()[0]?.getAddress() || ''
  };
}

function handleGetGoogleContact(params, inputData) {
  const contactId = params.contactId || params.contact_id;
  
  if (!contactId) {
    throw new Error('Contact ID is required');
  }
  
  const contact = ContactsApp.getContact(contactId);
  
  const contactData = {
    id: contact.getId(),
    fullName: contact.getFullName(),
    givenName: contact.getGivenName(),
    familyName: contact.getFamilyName(),
    emails: contact.getEmails().map(email => email.getAddress()),
    phones: contact.getPhones().map(phone => phone.getPhoneNumber()),
    companies: contact.getCompanies().map(company => company.getCompanyName()),
    addresses: contact.getAddresses().map(addr => addr.getAddress()),
    notes: contact.getNotes()
  };
  
  console.log(\`‚úÖ Retrieved Google contact: \${contactData.fullName}\`);
  return { ...inputData, googleContact: contactData };
}

function handleListGoogleContacts(params, inputData) {
  const maxResults = params.maxResults || params.limit || 100;
  const query = params.query || '';
  
  let contacts;
  if (query) {
    contacts = ContactsApp.getContactsByName(query);
  } else {
    contacts = ContactsApp.getContacts();
  }
  
  const contactList = contacts.slice(0, maxResults).map(contact => ({
    id: contact.getId(),
    fullName: contact.getFullName(),
    primaryEmail: contact.getEmails()[0]?.getAddress() || '',
    primaryPhone: contact.getPhones()[0]?.getPhoneNumber() || '',
    company: contact.getCompanies()[0]?.getCompanyName() || ''
  }));
  
  console.log(\`‚úÖ Listed \${contactList.length} Google contacts\`);
  return { ...inputData, googleContacts: contactList, contactCount: contactList.length };
}

function handleGoogleContactsTestConnection(params, inputData) {
  try {
    const user = Session.getActiveUser().getEmail();
    const contacts = ContactsApp.getContacts();
    
    console.log(\`‚úÖ Google Contacts connection test successful. User: \${user}, Contacts available: \${contacts.length}\`);
    return { ...inputData, connectionTest: 'success', userEmail: user, totalContacts: contacts.length };
  } catch (error) {
    console.error('‚ùå Google Contacts connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleGoogleContactsTrigger(params, inputData) {
  // Simulate contact monitoring by getting recently updated contacts
  const maxResults = params.maxResults || 10;
  
  try {
    const contacts = ContactsApp.getContacts();
    
    // Get the most recently created/updated contacts (simulate by taking first N)
    const recentContacts = contacts.slice(0, maxResults).map(contact => ({
      id: contact.getId(),
      fullName: contact.getFullName(),
      email: contact.getEmails()[0]?.getAddress() || '',
      phone: contact.getPhones()[0]?.getPhoneNumber() || '',
      company: contact.getCompanies()[0]?.getCompanyName() || '',
      triggeredBy: 'contact_watcher'
    }));
    
    console.log(\`üìá Google Contacts trigger found \${recentContacts.length} recent contacts\`);
    return { ...inputData, googleContactsTrigger: recentContacts, triggerCount: recentContacts.length };
  } catch (error) {
    console.error('‚ùå Google Contacts trigger failed:', error);
    return { ...inputData, googleContactsTriggerError: error.toString() };
  }
}`;
}

// Comprehensive Microsoft Teams implementation
function generateMicrosoftTeamsFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'send_message';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üë• Executing Microsoft Teams: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('MICROSOFT_TEAMS_ACCESS_TOKEN');
  
  if (!accessToken) {
    console.warn('‚ö†Ô∏è Microsoft Teams access token not configured');
    return { ...inputData, teamsSkipped: true, error: 'Missing access token' };
  }
  
  try {
    const baseUrl = 'https://graph.microsoft.com/v1.0';
    
    switch (operation) {
      case 'send_message':
        return handleSendTeamsMessage(baseUrl, accessToken, params, inputData);
      case 'send_chat_message':
        return handleSendTeamsChatMessage(baseUrl, accessToken, params, inputData);
      case 'create_team':
        return handleCreateTeam(baseUrl, accessToken, params, inputData);
      case 'create_channel':
        return handleCreateTeamsChannel(baseUrl, accessToken, params, inputData);
      case 'list_teams':
        return handleListTeams(baseUrl, accessToken, params, inputData);
      case 'list_channels':
        return handleListTeamsChannels(baseUrl, accessToken, params, inputData);
      case 'add_team_member':
        return handleAddTeamMember(baseUrl, accessToken, params, inputData);
      case 'create_meeting':
        return handleCreateTeamsMeeting(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleTeamsTestConnection(baseUrl, accessToken, params, inputData);
      case 'message_posted':
        return handleTeamsTrigger(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Microsoft Teams operation: \${operation}\`);
        return { ...inputData, teamsWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Microsoft Teams \${operation} failed:\`, error);
    return { ...inputData, teamsError: error.toString(), teamsSuccess: false };
  }
}

function handleSendTeamsMessage(baseUrl, accessToken, params, inputData) {
  const teamId = params.teamId || params.team_id;
  const channelId = params.channelId || params.channel_id;
  const message = params.message || params.text || inputData.message || 'Message from automation';
  
  if (!teamId || !channelId) {
    throw new Error('Team ID and Channel ID are required');
  }
  
  const messageData = {
    body: {
      contentType: 'text',
      content: message
    }
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/teams/\${teamId}/channels/\${channelId}/messages\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(messageData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Sent Teams message to channel \${channelId}\`);
    return { ...inputData, teamsMessageSent: true, messageId: data.id, teamId: teamId, channelId: channelId };
  } else {
    throw new Error(\`Send message failed: \${response.getResponseCode()}\`);
  }
}

function handleCreateTeam(baseUrl, accessToken, params, inputData) {
  const teamData = {
    'template@odata.bind': 'https://graph.microsoft.com/v1.0/teamsTemplates/standard',
    displayName: params.displayName || params.name || 'New Team from Automation',
    description: params.description || 'Team created by automation'
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/teams\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(teamData)
  });
  
  if (response.getResponseCode() === 202) {
    console.log(\`‚úÖ Teams creation initiated: \${teamData.displayName}\`);
    return { ...inputData, teamsCreated: true, teamName: teamData.displayName };
  } else {
    throw new Error(\`Create team failed: \${response.getResponseCode()}\`);
  }
}

function handleListTeams(baseUrl, accessToken, params, inputData) {
  const response = UrlFetchApp.fetch(\`\${baseUrl}/me/joinedTeams\`, {
    method: 'GET',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    const teams = data.value.map(team => ({
      id: team.id,
      displayName: team.displayName,
      description: team.description,
      webUrl: team.webUrl
    }));
    
    console.log(\`‚úÖ Listed \${teams.length} Teams\`);
    return { ...inputData, teamsListed: teams, teamCount: teams.length };
  } else {
    throw new Error(\`List teams failed: \${response.getResponseCode()}\`);
  }
}

function handleTeamsTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/me\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Microsoft Teams connection test successful. User: \${data.displayName}\`);
      return { ...inputData, connectionTest: 'success', userName: data.displayName, userEmail: data.mail };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Microsoft Teams connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleTeamsTrigger(baseUrl, accessToken, params, inputData) {
  const teamId = params.teamId || params.team_id;
  const channelId = params.channelId || params.channel_id;
  
  if (!teamId || !channelId) {
    console.warn('‚ö†Ô∏è Team ID and Channel ID required for message monitoring');
    return { ...inputData, teamsTrigger: [], triggerCount: 0 };
  }
  
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/teams/\${teamId}/channels/\${channelId}/messages?$top=10\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`üë• Teams trigger found \${data.value?.length || 0} recent messages\`);
      return { ...inputData, teamsTrigger: data.value, triggerCount: data.value?.length || 0 };
    } else {
      throw new Error(\`Trigger check failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Microsoft Teams trigger failed:', error);
    return { ...inputData, teamsTriggerError: error.toString() };
  }
}`;
}

// Comprehensive Stripe implementation
function generateStripeFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_customer';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üí≥ Executing Stripe: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const apiKey = PropertiesService.getScriptProperties().getProperty('STRIPE_SECRET_KEY');
  
  if (!apiKey) {
    console.warn('‚ö†Ô∏è Stripe secret key not configured');
    return { ...inputData, stripeSkipped: true, error: 'Missing secret key' };
  }
  
  try {
    const baseUrl = 'https://api.stripe.com/v1';
    
    switch (operation) {
      case 'create_customer':
        return handleCreateStripeCustomer(baseUrl, apiKey, params, inputData);
      case 'create_payment_intent':
        return handleCreatePaymentIntent(baseUrl, apiKey, params, inputData);
      case 'create_subscription':
        return handleCreateSubscription(baseUrl, apiKey, params, inputData);
      case 'create_refund':
        return handleCreateRefund(baseUrl, apiKey, params, inputData);
      case 'retrieve_customer':
        return handleRetrieveCustomer(baseUrl, apiKey, params, inputData);
      case 'list_payment_intents':
        return handleListPaymentIntents(baseUrl, apiKey, params, inputData);
      case 'update_subscription':
        return handleUpdateSubscription(baseUrl, apiKey, params, inputData);
      case 'test_connection':
        return handleStripeTestConnection(baseUrl, apiKey, params, inputData);
      case 'payment_succeeded':
      case 'payment_failed':
      case 'subscription_created':
        return handleStripeTrigger(baseUrl, apiKey, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Stripe operation: \${operation}\`);
        return { ...inputData, stripeWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Stripe \${operation} failed:\`, error);
    return { ...inputData, stripeError: error.toString(), stripeSuccess: false };
  }
}

function handleCreateStripeCustomer(baseUrl, apiKey, params, inputData) {
  const customerData = {
    name: params.name || \`\${params.first_name || inputData.first_name || ''} \${params.last_name || inputData.last_name || ''}\`.trim() || 'Unknown Customer',
    email: params.email || inputData.email || '',
    phone: params.phone || inputData.phone || '',
    description: params.description || 'Customer created by automation',
    metadata: params.metadata || {}
  };
  
  // Convert to form data for Stripe API
  const formData = Object.entries(customerData)
    .filter(([key, value]) => value !== '' && value !== null && value !== undefined)
    .map(([key, value]) => \`\${key}=\${encodeURIComponent(typeof value === 'object' ? JSON.stringify(value) : value)}\`)
    .join('&');
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/customers\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${apiKey}\`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    payload: formData
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Stripe customer: \${data.name || data.email} (ID: \${data.id})\`);
    return { ...inputData, stripeCustomerCreated: true, customerId: data.id, customerEmail: data.email };
  } else {
    throw new Error(\`Create customer failed: \${response.getResponseCode()}\`);
  }
}

function handleCreatePaymentIntent(baseUrl, apiKey, params, inputData) {
  const amount = params.amount || 1000; // Amount in cents
  const currency = params.currency || 'usd';
  const customerId = params.customer_id || params.customerId;
  
  const paymentData = {
    amount: amount,
    currency: currency,
    automatic_payment_methods: JSON.stringify({ enabled: true }),
    description: params.description || 'Payment from automation'
  };
  
  if (customerId) {
    paymentData.customer = customerId;
  }
  
  const formData = Object.entries(paymentData)
    .map(([key, value]) => \`\${key}=\${encodeURIComponent(value)}\`)
    .join('&');
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/payment_intents\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${apiKey}\`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    payload: formData
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Stripe payment intent: \${data.id} for \${amount} \${currency.toUpperCase()}\`);
    return { ...inputData, stripePaymentCreated: true, paymentIntentId: data.id, amount: amount, currency: currency };
  } else {
    throw new Error(\`Create payment intent failed: \${response.getResponseCode()}\`);
  }
}

function handleStripeTestConnection(baseUrl, apiKey, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/account\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${apiKey}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Stripe connection test successful. Account: \${data.display_name || data.id}\`);
      return { ...inputData, connectionTest: 'success', accountId: data.id, accountName: data.display_name };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Stripe connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleStripeTrigger(baseUrl, apiKey, params, inputData) {
  // Simulate payment monitoring by getting recent payments
  const limit = params.limit || 10;
  
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/payment_intents?limit=\${limit}\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${apiKey}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`üí≥ Stripe trigger found \${data.data?.length || 0} recent payment intents\`);
      return { ...inputData, stripeTrigger: data.data, triggerCount: data.data?.length || 0 };
    } else {
      throw new Error(\`Trigger check failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Stripe trigger failed:', error);
    return { ...inputData, stripeTriggerError: error.toString() };
  }
}`;
}

// Comprehensive Twilio implementation
function generateTwilioFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'send_sms';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üì± Executing Twilio: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accountSid = PropertiesService.getScriptProperties().getProperty('TWILIO_ACCOUNT_SID');
  const authToken = PropertiesService.getScriptProperties().getProperty('TWILIO_AUTH_TOKEN');
  const fromNumber = PropertiesService.getScriptProperties().getProperty('TWILIO_FROM_NUMBER');
  
  if (!accountSid || !authToken) {
    console.warn('‚ö†Ô∏è Twilio credentials not configured');
    return { ...inputData, twilioSkipped: true, error: 'Missing account SID or auth token' };
  }
  
  try {
    const baseUrl = \`https://api.twilio.com/2010-04-01/Accounts/\${accountSid}\`;
    
    switch (operation) {
      case 'send_sms':
        return handleSendSMS(baseUrl, accountSid, authToken, fromNumber, params, inputData);
      case 'send_mms':
        return handleSendMMS(baseUrl, accountSid, authToken, fromNumber, params, inputData);
      case 'make_call':
        return handleMakeCall(baseUrl, accountSid, authToken, fromNumber, params, inputData);
      case 'send_whatsapp':
        return handleSendWhatsApp(baseUrl, accountSid, authToken, params, inputData);
      case 'lookup_phone':
        return handleLookupPhone(baseUrl, accountSid, authToken, params, inputData);
      case 'list_messages':
        return handleListTwilioMessages(baseUrl, accountSid, authToken, params, inputData);
      case 'get_call_logs':
        return handleGetCallLogs(baseUrl, accountSid, authToken, params, inputData);
      case 'test_connection':
        return handleTwilioTestConnection(baseUrl, accountSid, authToken, params, inputData);
      case 'sms_received':
      case 'call_completed':
        return handleTwilioTrigger(baseUrl, accountSid, authToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Twilio operation: \${operation}\`);
        return { ...inputData, twilioWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Twilio \${operation} failed:\`, error);
    return { ...inputData, twilioError: error.toString(), twilioSuccess: false };
  }
}

function handleSendSMS(baseUrl, accountSid, authToken, fromNumber, params, inputData) {
  const to = params.to || params.phone || inputData.phone;
  const body = params.body || params.message || inputData.message || 'Message from automation';
  const from = params.from || fromNumber;
  
  if (!to || !from) {
    throw new Error('To and From phone numbers are required');
  }
  
  const auth = Utilities.base64Encode(\`\${accountSid}:\${authToken}\`);
  const formData = \`To=\${encodeURIComponent(to)}&From=\${encodeURIComponent(from)}&Body=\${encodeURIComponent(body)}\`;
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/Messages.json\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Basic \${auth}\`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    payload: formData
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Sent SMS via Twilio to \${to}: \${data.sid}\`);
    return { ...inputData, twilioSmsSent: true, messageSid: data.sid, to: to, body: body };
  } else {
    throw new Error(\`Send SMS failed: \${response.getResponseCode()}\`);
  }
}

function handleMakeCall(baseUrl, accountSid, authToken, fromNumber, params, inputData) {
  const to = params.to || params.phone || inputData.phone;
  const from = params.from || fromNumber;
  const twiml = params.twiml || \`<Response><Say>Hello from automation</Say></Response>\`;
  
  if (!to || !from) {
    throw new Error('To and From phone numbers are required');
  }
  
  const auth = Utilities.base64Encode(\`\${accountSid}:\${authToken}\`);
  const formData = \`To=\${encodeURIComponent(to)}&From=\${encodeURIComponent(from)}&Twiml=\${encodeURIComponent(twiml)}\`;
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/Calls.json\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Basic \${auth}\`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    payload: formData
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Initiated call via Twilio to \${to}: \${data.sid}\`);
    return { ...inputData, twilioCallInitiated: true, callSid: data.sid, to: to };
  } else {
    throw new Error(\`Make call failed: \${response.getResponseCode()}\`);
  }
}

function handleTwilioTestConnection(baseUrl, accountSid, authToken, params, inputData) {
  try {
    const auth = Utilities.base64Encode(\`\${accountSid}:\${authToken}\`);
    const response = UrlFetchApp.fetch(\`https://api.twilio.com/2010-04-01/Accounts/\${accountSid}.json\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Basic \${auth}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Twilio connection test successful. Account: \${data.friendly_name}\`);
      return { ...inputData, connectionTest: 'success', accountSid: data.sid, accountName: data.friendly_name };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Twilio connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive PayPal implementation
function generatePayPalFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_order';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üí∞ Executing PayPal: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const clientId = PropertiesService.getScriptProperties().getProperty('PAYPAL_CLIENT_ID');
  const clientSecret = PropertiesService.getScriptProperties().getProperty('PAYPAL_CLIENT_SECRET');
  const sandbox = PropertiesService.getScriptProperties().getProperty('PAYPAL_SANDBOX') === 'true';
  
  if (!clientId || !clientSecret) {
    console.warn('‚ö†Ô∏è PayPal credentials not configured');
    return { ...inputData, paypalSkipped: true, error: 'Missing client ID or secret' };
  }
  
  try {
    const baseUrl = sandbox ? 'https://api.sandbox.paypal.com' : 'https://api.paypal.com';
    
    // Get access token first
    const accessToken = getPayPalAccessToken(baseUrl, clientId, clientSecret);
    if (!accessToken) {
      throw new Error('Failed to obtain PayPal access token');
    }
    
    switch (operation) {
      case 'create_order':
        return handleCreatePayPalOrder(baseUrl, accessToken, params, inputData);
      case 'capture_order':
        return handleCapturePayPalOrder(baseUrl, accessToken, params, inputData);
      case 'get_order':
        return handleGetPayPalOrder(baseUrl, accessToken, params, inputData);
      case 'refund_capture':
        return handleRefundCapture(baseUrl, accessToken, params, inputData);
      case 'create_payment':
        return handleCreatePayPalPayment(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handlePayPalTestConnection(baseUrl, accessToken, params, inputData);
      case 'payment_sale_completed':
      case 'payment_sale_refunded':
        return handlePayPalTrigger(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown PayPal operation: \${operation}\`);
        return { ...inputData, paypalWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå PayPal \${operation} failed:\`, error);
    return { ...inputData, paypalError: error.toString(), paypalSuccess: false };
  }
}

function getPayPalAccessToken(baseUrl, clientId, clientSecret) {
  const auth = Utilities.base64Encode(\`\${clientId}:\${clientSecret}\`);
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/v1/oauth2/token\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Basic \${auth}\`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    payload: 'grant_type=client_credentials'
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    return data.access_token;
  }
  
  return null;
}

function handleCreatePayPalOrder(baseUrl, accessToken, params, inputData) {
  const amount = params.amount || '10.00';
  const currency = params.currency || 'USD';
  
  const orderData = {
    intent: 'CAPTURE',
    purchase_units: [{
      amount: {
        currency_code: currency,
        value: amount.toString()
      },
      description: params.description || 'Order from automation'
    }]
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/v2/checkout/orders\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(orderData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created PayPal order: \${data.id} for \${amount} \${currency}\`);
    return { ...inputData, paypalOrderCreated: true, orderId: data.id, amount: amount, currency: currency };
  } else {
    throw new Error(\`Create order failed: \${response.getResponseCode()}\`);
  }
}

function handlePayPalTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/v1/identity/oauth2/userinfo?schema=paypalv1.1\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ PayPal connection test successful. User: \${data.name}\`);
      return { ...inputData, connectionTest: 'success', userName: data.name, userEmail: data.email };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå PayPal connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive Zoom Enhanced implementation
function generateZoomEnhancedFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_meeting';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üé• Executing Zoom Enhanced: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('ZOOM_ACCESS_TOKEN');
  
  if (!accessToken) {
    console.warn('‚ö†Ô∏è Zoom access token not configured');
    return { ...inputData, zoomSkipped: true, error: 'Missing access token' };
  }
  
  try {
    const baseUrl = 'https://api.zoom.us/v2';
    
    switch (operation) {
      case 'create_meeting':
        return handleCreateZoomMeeting(baseUrl, accessToken, params, inputData);
      case 'get_meeting':
        return handleGetZoomMeeting(baseUrl, accessToken, params, inputData);
      case 'update_meeting':
        return handleUpdateZoomMeeting(baseUrl, accessToken, params, inputData);
      case 'delete_meeting':
        return handleDeleteZoomMeeting(baseUrl, accessToken, params, inputData);
      case 'list_meetings':
        return handleListZoomMeetings(baseUrl, accessToken, params, inputData);
      case 'create_webinar':
        return handleCreateZoomWebinar(baseUrl, accessToken, params, inputData);
      case 'get_recording':
        return handleGetZoomRecording(baseUrl, accessToken, params, inputData);
      case 'list_recordings':
        return handleListZoomRecordings(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleZoomTestConnection(baseUrl, accessToken, params, inputData);
      case 'meeting_started':
        return handleZoomTrigger(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Zoom operation: \${operation}\`);
        return { ...inputData, zoomWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Zoom \${operation} failed:\`, error);
    return { ...inputData, zoomError: error.toString(), zoomSuccess: false };
  }
}

function handleCreateZoomMeeting(baseUrl, accessToken, params, inputData) {
  const userId = params.userId || 'me';
  
  const meetingData = {
    topic: params.topic || params.title || 'Meeting from Automation',
    type: params.type || 2, // Scheduled meeting
    start_time: params.start_time || new Date(Date.now() + 3600000).toISOString(), // 1 hour from now
    duration: params.duration || 60,
    timezone: params.timezone || 'UTC',
    agenda: params.agenda || params.description || '',
    password: params.password || '',
    settings: {
      host_video: params.host_video || true,
      participant_video: params.participant_video || true,
      join_before_host: params.join_before_host || false,
      mute_upon_entry: params.mute_upon_entry || false,
      waiting_room: params.waiting_room || false
    }
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/users/\${userId}/meetings\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(meetingData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Zoom meeting: \${data.topic} (ID: \${data.id})\`);
    return { 
      ...inputData, 
      zoomMeetingCreated: true, 
      meetingId: data.id, 
      meetingUrl: data.join_url,
      meetingPassword: data.password,
      meetingTopic: data.topic
    };
  } else {
    throw new Error(\`Create meeting failed: \${response.getResponseCode()}\`);
  }
}

function handleZoomTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/users/me\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Zoom connection test successful. User: \${data.display_name}\`);
      return { ...inputData, connectionTest: 'success', userName: data.display_name, userEmail: data.email };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Zoom connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive Google Chat implementation  
function generateGoogleChatFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'send_message';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üí¨ Executing Google Chat: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('GOOGLE_CHAT_ACCESS_TOKEN');
  
  if (!accessToken) {
    console.warn('‚ö†Ô∏è Google Chat access token not configured');
    return { ...inputData, googleChatSkipped: true, error: 'Missing access token' };
  }
  
  try {
    const baseUrl = 'https://chat.googleapis.com/v1';
    
    switch (operation) {
      case 'send_message':
        return handleSendGoogleChatMessage(baseUrl, accessToken, params, inputData);
      case 'create_space':
        return handleCreateGoogleChatSpace(baseUrl, accessToken, params, inputData);
      case 'list_spaces':
        return handleListGoogleChatSpaces(baseUrl, accessToken, params, inputData);
      case 'get_space':
        return handleGetGoogleChatSpace(baseUrl, accessToken, params, inputData);
      case 'list_members':
        return handleListGoogleChatMembers(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleGoogleChatTestConnection(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Google Chat operation: \${operation}\`);
        return { ...inputData, googleChatWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Google Chat \${operation} failed:\`, error);
    return { ...inputData, googleChatError: error.toString(), googleChatSuccess: false };
  }
}

function handleSendGoogleChatMessage(baseUrl, accessToken, params, inputData) {
  const spaceName = params.spaceName || params.space_name;
  const message = params.message || params.text || inputData.message || 'Message from automation';
  
  if (!spaceName) {
    throw new Error('Space name is required');
  }
  
  const messageData = {
    text: message
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/\${spaceName}/messages\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(messageData)
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Sent Google Chat message to \${spaceName}\`);
    return { ...inputData, googleChatMessageSent: true, messageId: data.name, spaceName: spaceName };
  } else {
    throw new Error(\`Send message failed: \${response.getResponseCode()}\`);
  }
}

function handleGoogleChatTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/spaces\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Google Chat connection test successful. Spaces available: \${data.spaces?.length || 0}\`);
      return { ...inputData, connectionTest: 'success', spacesCount: data.spaces?.length || 0 };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Google Chat connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive Google Meet implementation
function generateGoogleMeetFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_space';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üìπ Executing Google Meet: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('GOOGLE_MEET_ACCESS_TOKEN');
  
  if (!accessToken) {
    console.warn('‚ö†Ô∏è Google Meet access token not configured');
    return { ...inputData, googleMeetSkipped: true, error: 'Missing access token' };
  }
  
  try {
    const baseUrl = 'https://meet.googleapis.com/v2';
    
    switch (operation) {
      case 'create_space':
        return handleCreateGoogleMeetSpace(baseUrl, accessToken, params, inputData);
      case 'get_space':
        return handleGetGoogleMeetSpace(baseUrl, accessToken, params, inputData);
      case 'end_active_conference':
        return handleEndActiveConference(baseUrl, accessToken, params, inputData);
      case 'list_conference_records':
        return handleListConferenceRecords(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleGoogleMeetTestConnection(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Google Meet operation: \${operation}\`);
        return { ...inputData, googleMeetWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Google Meet \${operation} failed:\`, error);
    return { ...inputData, googleMeetError: error.toString(), googleMeetSuccess: false };
  }
}

function handleCreateGoogleMeetSpace(baseUrl, accessToken, params, inputData) {
  const spaceData = {};
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/spaces\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(spaceData)
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Google Meet space: \${data.name}\`);
    return { ...inputData, googleMeetSpaceCreated: true, spaceName: data.name, meetingUri: data.meetingUri };
  } else {
    throw new Error(\`Create space failed: \${response.getResponseCode()}\`);
  }
}

function handleGoogleMeetTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/spaces\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      console.log(\`‚úÖ Google Meet connection test successful\`);
      return { ...inputData, connectionTest: 'success' };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Google Meet connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive RingCentral implementation
function generateRingCentralFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'send_sms';
  
  return `
function ${functionName}(inputData, params) {
  console.log('‚òéÔ∏è Executing RingCentral: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('RINGCENTRAL_ACCESS_TOKEN');
  const serverUrl = PropertiesService.getScriptProperties().getProperty('RINGCENTRAL_SERVER_URL') || 'https://platform.ringcentral.com';
  
  if (!accessToken) {
    console.warn('‚ö†Ô∏è RingCentral access token not configured');
    return { ...inputData, ringcentralSkipped: true, error: 'Missing access token' };
  }
  
  try {
    const baseUrl = \`\${serverUrl}/restapi/v1.0\`;
    
    switch (operation) {
      case 'send_sms':
        return handleSendRingCentralSMS(baseUrl, accessToken, params, inputData);
      case 'get_messages':
        return handleGetRingCentralMessages(baseUrl, accessToken, params, inputData);
      case 'get_call_log':
        return handleGetRingCentralCallLog(baseUrl, accessToken, params, inputData);
      case 'make_call':
        return handleMakeRingCentralCall(baseUrl, accessToken, params, inputData);
      case 'create_meeting':
        return handleCreateRingCentralMeeting(baseUrl, accessToken, params, inputData);
      case 'get_account_info':
        return handleGetRingCentralAccount(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleRingCentralTestConnection(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown RingCentral operation: \${operation}\`);
        return { ...inputData, ringcentralWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå RingCentral \${operation} failed:\`, error);
    return { ...inputData, ringcentralError: error.toString(), ringcentralSuccess: false };
  }
}

function handleSendRingCentralSMS(baseUrl, accessToken, params, inputData) {
  const accountId = params.accountId || '~';
  const extensionId = params.extensionId || '~';
  const to = params.to || params.phone || inputData.phone;
  const text = params.text || params.message || inputData.message || 'Message from automation';
  const from = params.from || PropertiesService.getScriptProperties().getProperty('RINGCENTRAL_FROM_NUMBER');
  
  if (!to || !from) {
    throw new Error('To and From phone numbers are required');
  }
  
  const messageData = {
    from: { phoneNumber: from },
    to: [{ phoneNumber: to }],
    text: text
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/account/\${accountId}/extension/\${extensionId}/sms\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(messageData)
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Sent SMS via RingCentral to \${to}: \${data.id}\`);
    return { ...inputData, ringcentralSmsSent: true, messageId: data.id, to: to };
  } else {
    throw new Error(\`Send SMS failed: \${response.getResponseCode()}\`);
  }
}

function handleRingCentralTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/account/~/extension/~\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ RingCentral connection test successful. Extension: \${data.name}\`);
      return { ...inputData, connectionTest: 'success', extensionName: data.name };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå RingCentral connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive Cisco Webex implementation
function generateWebexFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_room';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üè¢ Executing Cisco Webex: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('WEBEX_ACCESS_TOKEN');
  
  if (!accessToken) {
    console.warn('‚ö†Ô∏è Webex access token not configured');
    return { ...inputData, webexSkipped: true, error: 'Missing access token' };
  }
  
  try {
    const baseUrl = 'https://webexapis.com/v1';
    
    switch (operation) {
      case 'create_room':
        return handleCreateWebexRoom(baseUrl, accessToken, params, inputData);
      case 'get_room':
        return handleGetWebexRoom(baseUrl, accessToken, params, inputData);
      case 'list_rooms':
        return handleListWebexRooms(baseUrl, accessToken, params, inputData);
      case 'send_message':
        return handleSendWebexMessage(baseUrl, accessToken, params, inputData);
      case 'create_meeting':
        return handleCreateWebexMeeting(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleWebexTestConnection(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Webex operation: \${operation}\`);
        return { ...inputData, webexWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Webex \${operation} failed:\`, error);
    return { ...inputData, webexError: error.toString(), webexSuccess: false };
  }
}

function handleCreateWebexRoom(baseUrl, accessToken, params, inputData) {
  const roomData = {
    title: params.title || params.name || 'Room from Automation',
    type: params.type || 'group'
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/rooms\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(roomData)
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Webex room: \${data.title} (ID: \${data.id})\`);
    return { ...inputData, webexRoomCreated: true, roomId: data.id, roomTitle: data.title };
  } else {
    throw new Error(\`Create room failed: \${response.getResponseCode()}\`);
  }
}

function handleWebexTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/people/me\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Webex connection test successful. User: \${data.displayName}\`);
      return { ...inputData, connectionTest: 'success', userName: data.displayName, userEmail: data.emails[0] };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Webex connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive BigCommerce implementation
function generateBigCommerceFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_product';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üõçÔ∏è Executing BigCommerce: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('BIGCOMMERCE_ACCESS_TOKEN');
  const storeHash = PropertiesService.getScriptProperties().getProperty('BIGCOMMERCE_STORE_HASH');
  
  if (!accessToken || !storeHash) {
    console.warn('‚ö†Ô∏è BigCommerce credentials not configured');
    return { ...inputData, bigcommerceSkipped: true, error: 'Missing access token or store hash' };
  }
  
  try {
    const baseUrl = \`https://api.bigcommerce.com/stores/\${storeHash}/v3\`;
    
    switch (operation) {
      case 'create_product':
        return handleCreateBigCommerceProduct(baseUrl, accessToken, params, inputData);
      case 'update_product':
        return handleUpdateBigCommerceProduct(baseUrl, accessToken, params, inputData);
      case 'get_product':
        return handleGetBigCommerceProduct(baseUrl, accessToken, params, inputData);
      case 'list_products':
        return handleListBigCommerceProducts(baseUrl, accessToken, params, inputData);
      case 'create_order':
        return handleCreateBigCommerceOrder(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleBigCommerceTestConnection(baseUrl, accessToken, params, inputData);
      case 'order_created':
      case 'product_updated':
        return handleBigCommerceTrigger(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown BigCommerce operation: \${operation}\`);
        return { ...inputData, bigcommerceWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå BigCommerce \${operation} failed:\`, error);
    return { ...inputData, bigcommerceError: error.toString(), bigcommerceSuccess: false };
  }
}

function handleCreateBigCommerceProduct(baseUrl, accessToken, params, inputData) {
  const productData = {
    name: params.name || params.product_name || 'New Product from Automation',
    type: params.type || 'physical',
    sku: params.sku || '',
    description: params.description || '',
    price: params.price || 0,
    categories: params.categories || [],
    brand_id: params.brand_id || 0,
    inventory_level: params.inventory_level || 0,
    weight: params.weight || 0
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/catalog/products\`, {
    method: 'POST',
    headers: {
      'X-Auth-Token': accessToken,
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    payload: JSON.stringify(productData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created BigCommerce product: \${data.data.name} (ID: \${data.data.id})\`);
    return { ...inputData, bigcommerceProductCreated: true, productId: data.data.id, productName: data.data.name };
  } else {
    throw new Error(\`Create product failed: \${response.getResponseCode()}\`);
  }
}

function handleBigCommerceTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/store\`, {
      method: 'GET',
      headers: {
        'X-Auth-Token': accessToken,
        'Accept': 'application/json'
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ BigCommerce connection test successful. Store: \${data.data.name}\`);
      return { ...inputData, connectionTest: 'success', storeName: data.data.name };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå BigCommerce connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive WooCommerce implementation
function generateWooCommerceFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_product';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üõçÔ∏è Executing WooCommerce: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const consumerKey = PropertiesService.getScriptProperties().getProperty('WOOCOMMERCE_CONSUMER_KEY');
  const consumerSecret = PropertiesService.getScriptProperties().getProperty('WOOCOMMERCE_CONSUMER_SECRET');
  const siteUrl = PropertiesService.getScriptProperties().getProperty('WOOCOMMERCE_SITE_URL');
  
  if (!consumerKey || !consumerSecret || !siteUrl) {
    console.warn('‚ö†Ô∏è WooCommerce credentials not configured');
    return { ...inputData, woocommerceSkipped: true, error: 'Missing credentials or site URL' };
  }
  
  try {
    const baseUrl = \`\${siteUrl}/wp-json/wc/v3\`;
    const auth = Utilities.base64Encode(\`\${consumerKey}:\${consumerSecret}\`);
    
    switch (operation) {
      case 'create_product':
        return handleCreateWooCommerceProduct(baseUrl, auth, params, inputData);
      case 'get_product':
        return handleGetWooCommerceProduct(baseUrl, auth, params, inputData);
      case 'update_product':
        return handleUpdateWooCommerceProduct(baseUrl, auth, params, inputData);
      case 'list_products':
        return handleListWooCommerceProducts(baseUrl, auth, params, inputData);
      case 'create_order':
        return handleCreateWooCommerceOrder(baseUrl, auth, params, inputData);
      case 'test_connection':
        return handleWooCommerceTestConnection(baseUrl, auth, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown WooCommerce operation: \${operation}\`);
        return { ...inputData, woocommerceWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå WooCommerce \${operation} failed:\`, error);
    return { ...inputData, woocommerceError: error.toString(), woocommerceSuccess: false };
  }
}

function handleCreateWooCommerceProduct(baseUrl, auth, params, inputData) {
  const productData = {
    name: params.name || params.product_name || 'New Product from Automation',
    type: params.type || 'simple',
    regular_price: params.price || params.regular_price || '0',
    description: params.description || '',
    short_description: params.short_description || '',
    sku: params.sku || '',
    manage_stock: params.manage_stock || false,
    stock_quantity: params.stock_quantity || 0,
    in_stock: params.in_stock || true,
    categories: params.categories || []
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/products\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Basic \${auth}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(productData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created WooCommerce product: \${data.name} (ID: \${data.id})\`);
    return { ...inputData, woocommerceProductCreated: true, productId: data.id, productName: data.name };
  } else {
    throw new Error(\`Create product failed: \${response.getResponseCode()}\`);
  }
}

function handleWooCommerceTestConnection(baseUrl, auth, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/system_status\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Basic \${auth}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ WooCommerce connection test successful. Version: \${data.settings?.version}\`);
      return { ...inputData, connectionTest: 'success', version: data.settings?.version };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå WooCommerce connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive Magento implementation
function generateMagentoFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_product';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üõçÔ∏è Executing Magento: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('MAGENTO_ACCESS_TOKEN');
  const baseUrl = PropertiesService.getScriptProperties().getProperty('MAGENTO_BASE_URL');
  
  if (!accessToken || !baseUrl) {
    console.warn('‚ö†Ô∏è Magento credentials not configured');
    return { ...inputData, magentoSkipped: true, error: 'Missing access token or base URL' };
  }
  
  try {
    const apiUrl = \`\${baseUrl}/rest/V1\`;
    
    switch (operation) {
      case 'create_product':
        return handleCreateMagentoProduct(apiUrl, accessToken, params, inputData);
      case 'get_product':
        return handleGetMagentoProduct(apiUrl, accessToken, params, inputData);
      case 'update_product':
        return handleUpdateMagentoProduct(apiUrl, accessToken, params, inputData);
      case 'search_products':
        return handleSearchMagentoProducts(apiUrl, accessToken, params, inputData);
      case 'create_order':
        return handleCreateMagentoOrder(apiUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleMagentoTestConnection(apiUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Magento operation: \${operation}\`);
        return { ...inputData, magentoWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Magento \${operation} failed:\`, error);
    return { ...inputData, magentoError: error.toString(), magentoSuccess: false };
  }
}

function handleMagentoTestConnection(apiUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${apiUrl}/modules\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      console.log('‚úÖ Magento connection test successful');
      return { ...inputData, connectionTest: 'success' };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Magento connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive Square implementation
function generateSquareFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_payment';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üí≥ Executing Square: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const accessToken = PropertiesService.getScriptProperties().getProperty('SQUARE_ACCESS_TOKEN');
  const applicationId = PropertiesService.getScriptProperties().getProperty('SQUARE_APPLICATION_ID');
  const environment = PropertiesService.getScriptProperties().getProperty('SQUARE_ENVIRONMENT') || 'sandbox';
  
  if (!accessToken || !applicationId) {
    console.warn('‚ö†Ô∏è Square credentials not configured');
    return { ...inputData, squareSkipped: true, error: 'Missing access token or application ID' };
  }
  
  try {
    const baseUrl = environment === 'production' ? 'https://connect.squareup.com' : 'https://connect.squareupsandbox.com';
    
    switch (operation) {
      case 'create_payment':
        return handleCreateSquarePayment(baseUrl, accessToken, params, inputData);
      case 'get_payment':
        return handleGetSquarePayment(baseUrl, accessToken, params, inputData);
      case 'list_payments':
        return handleListSquarePayments(baseUrl, accessToken, params, inputData);
      case 'create_refund':
        return handleCreateSquareRefund(baseUrl, accessToken, params, inputData);
      case 'create_customer':
        return handleCreateSquareCustomer(baseUrl, accessToken, params, inputData);
      case 'get_customer':
        return handleGetSquareCustomer(baseUrl, accessToken, params, inputData);
      case 'create_order':
        return handleCreateSquareOrder(baseUrl, accessToken, params, inputData);
      case 'test_connection':
        return handleSquareTestConnection(baseUrl, accessToken, params, inputData);
      case 'payment_created':
        return handleSquareTrigger(baseUrl, accessToken, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Square operation: \${operation}\`);
        return { ...inputData, squareWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Square \${operation} failed:\`, error);
    return { ...inputData, squareError: error.toString(), squareSuccess: false };
  }
}

function handleCreateSquarePayment(baseUrl, accessToken, params, inputData) {
  const amount = params.amount || 100; // Amount in cents
  const currency = params.currency || 'USD';
  const sourceId = params.source_id || 'cnon:card-nonce-ok'; // Test nonce
  
  const paymentData = {
    source_id: sourceId,
    amount_money: {
      amount: amount,
      currency: currency
    },
    idempotency_key: Utilities.getUuid()
  };
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/v2/payments\`, {
    method: 'POST',
    headers: {
      'Square-Version': '2023-10-18',
      'Authorization': \`Bearer \${accessToken}\`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(paymentData)
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Square payment: \${data.payment.id} for \${amount} \${currency}\`);
    return { ...inputData, squarePaymentCreated: true, paymentId: data.payment.id, amount: amount };
  } else {
    throw new Error(\`Create payment failed: \${response.getResponseCode()}\`);
  }
}

function handleSquareTestConnection(baseUrl, accessToken, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/v2/locations\`, {
      method: 'GET',
      headers: {
        'Square-Version': '2023-10-18',
        'Authorization': \`Bearer \${accessToken}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Square connection test successful. Locations: \${data.locations?.length || 0}\`);
      return { ...inputData, connectionTest: 'success', locationsCount: data.locations?.length || 0 };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Square connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}

// Comprehensive Stripe Enhanced implementation (with advanced features)
function generateStripeEnhancedFunction(functionName: string, node: WorkflowNode): string {
  const operation = node.params?.operation || node.op?.split('.').pop() || 'create_customer';
  
  return `
function ${functionName}(inputData, params) {
  console.log('üí≥ Executing Stripe Enhanced: ${node.name || operation}');
  
  const operation = params.operation || '${operation}';
  const apiKey = PropertiesService.getScriptProperties().getProperty('STRIPE_SECRET_KEY');
  
  if (!apiKey) {
    console.warn('‚ö†Ô∏è Stripe Enhanced secret key not configured');
    return { ...inputData, stripeEnhancedSkipped: true, error: 'Missing secret key' };
  }
  
  try {
    const baseUrl = 'https://api.stripe.com/v1';
    
    switch (operation) {
      case 'create_customer':
        return handleCreateStripeEnhancedCustomer(baseUrl, apiKey, params, inputData);
      case 'create_subscription':
        return handleCreateStripeSubscription(baseUrl, apiKey, params, inputData);
      case 'create_product':
        return handleCreateStripeProduct(baseUrl, apiKey, params, inputData);
      case 'create_price':
        return handleCreateStripePrice(baseUrl, apiKey, params, inputData);
      case 'create_invoice':
        return handleCreateStripeInvoice(baseUrl, apiKey, params, inputData);
      case 'charge_customer':
        return handleChargeStripeCustomer(baseUrl, apiKey, params, inputData);
      case 'list_invoices':
        return handleListStripeInvoices(baseUrl, apiKey, params, inputData);
      case 'webhook_endpoint':
        return handleStripeWebhook(baseUrl, apiKey, params, inputData);
      case 'test_connection':
        return handleStripeEnhancedTestConnection(baseUrl, apiKey, params, inputData);
      default:
        console.warn(\`‚ö†Ô∏è Unknown Stripe Enhanced operation: \${operation}\`);
        return { ...inputData, stripeEnhancedWarning: \`Unsupported operation: \${operation}\` };
    }
    
  } catch (error) {
    console.error(\`‚ùå Stripe Enhanced \${operation} failed:\`, error);
    return { ...inputData, stripeEnhancedError: error.toString(), stripeEnhancedSuccess: false };
  }
}

function handleCreateStripeSubscription(baseUrl, apiKey, params, inputData) {
  const customerId = params.customer_id || params.customerId;
  const priceId = params.price_id || params.priceId;
  
  if (!customerId || !priceId) {
    throw new Error('Customer ID and Price ID are required');
  }
  
  const subscriptionData = {
    customer: customerId,
    items: [{ price: priceId }],
    payment_behavior: params.payment_behavior || 'default_incomplete',
    payment_settings: {
      save_default_payment_method: 'on_subscription'
    },
    expand: ['latest_invoice.payment_intent']
  };
  
  const formData = Object.entries(subscriptionData)
    .filter(([key, value]) => value !== '' && value !== null && value !== undefined)
    .map(([key, value]) => \`\${key}=\${encodeURIComponent(typeof value === 'object' ? JSON.stringify(value) : value)}\`)
    .join('&');
  
  const response = UrlFetchApp.fetch(\`\${baseUrl}/subscriptions\`, {
    method: 'POST',
    headers: {
      'Authorization': \`Bearer \${apiKey}\`,
      'Content-Type': 'application/x-www-form-urlencoded'
    },
    payload: formData
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(\`‚úÖ Created Stripe subscription: \${data.id}\`);
    return { ...inputData, stripeSubscriptionCreated: true, subscriptionId: data.id, status: data.status };
  } else {
    throw new Error(\`Create subscription failed: \${response.getResponseCode()}\`);
  }
}

function handleStripeEnhancedTestConnection(baseUrl, apiKey, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(\`\${baseUrl}/account\`, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${apiKey}\`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Stripe Enhanced connection test successful. Account: \${data.display_name || data.id}\`);
      return { ...inputData, connectionTest: 'success', accountId: data.id, accountName: data.display_name };
    } else {
      throw new Error(\`Test failed: \${response.getResponseCode()}\`);
    }
  } catch (error) {
    console.error('‚ùå Stripe Enhanced connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}`;
}