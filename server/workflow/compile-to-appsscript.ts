import { CompileResult, WorkflowGraph, WorkflowNode } from '../../common/workflow-types';

export function compileToAppsScript(graph: WorkflowGraph): CompileResult {
  const triggers   = graph.nodes.filter(n => n.type === 'trigger').length;
  const actions    = graph.nodes.filter(n => n.type === 'action').length;
  const transforms = graph.nodes.filter(n => n.type === 'transform').length;

  const code = emitCode(graph);
  const manifest = emitManifest(graph);

  return {
    workflowId: graph.id,
    graph,
    stats: { nodes: graph.nodes.length, triggers, actions, transforms },
    files: [
      { path: 'Code.gs',        content: code },
      { path: 'appsscript.json', content: manifest },
    ],
  };
}

function emitManifest(graph: WorkflowGraph): string {
  // Collect all required scopes from the graph nodes
  const requiredScopes = new Set<string>([
    'https://www.googleapis.com/auth/script.external_request' // Always needed for external APIs
  ]);

  // Add scopes based on node types and apps
  graph.nodes.forEach(node => {
    if (node.app === 'gmail') {
      requiredScopes.add('https://www.googleapis.com/auth/gmail.modify');
    }
    if (node.app === 'sheets') {
      requiredScopes.add('https://www.googleapis.com/auth/spreadsheets');
    }
    if (node.app === 'calendar') {
      requiredScopes.add('https://www.googleapis.com/auth/calendar');
    }
    if (node.app === 'drive') {
      requiredScopes.add('https://www.googleapis.com/auth/drive');
    }
    if (node.app === 'slack') {
      // Slack uses external requests, already covered
    }
    if (node.app === 'dropbox') {
      // Dropbox uses external requests, already covered
    }
  });

  return JSON.stringify({
    timeZone: 'Etc/UTC',
    exceptionLogging: 'STACKDRIVER',
    oauthScopes: Array.from(requiredScopes),
  }, null, 2);
}

function emitCode(graph: WorkflowGraph): string {
  console.log(`üîß Walking graph with ${graph.nodes.length} nodes and ${graph.edges.length} edges`);
  
  // Analyze the graph structure
  const triggerNodes = graph.nodes.filter(n => n.type === 'trigger');
  const actionNodes = graph.nodes.filter(n => n.type === 'action');
  const transformNodes = graph.nodes.filter(n => n.type === 'transform');
  
  console.log(`üìä Graph analysis: ${triggerNodes.length} triggers, ${actionNodes.length} actions, ${transformNodes.length} transforms`);
  
  // Generate code by walking execution path
  let codeBlocks: string[] = [];
  
  // Add header
  codeBlocks.push(`
/**
 * Generated by Apps Script Studio - Intelligent Workflow
 * Prompt: ${graph.meta?.prompt || 'Automated workflow'}
 * Nodes: ${graph.nodes.length} | Edges: ${graph.edges.length}
 * Automation Type: ${graph.meta?.automationType || 'generic'}
 */`);
  
  // Generate main function
  codeBlocks.push(generateMainFunction(graph));
  
  // Generate trigger setup if needed
  if (triggerNodes.some(t => t.op.includes('time') || t.op.includes('schedule'))) {
    codeBlocks.push(generateTriggerSetup(triggerNodes));
  }
  
  // Generate helper functions for each node type
  codeBlocks.push(...generateNodeFunctions(graph.nodes));
  
  return codeBlocks.join('\n\n');
}

function generateMainFunction(graph: WorkflowGraph): string {
  // Build execution flow based on graph edges
  const executionOrder = buildExecutionOrder(graph);
  
  let code = `
function main() {
  console.log('üöÄ Starting intelligent workflow...');
  
  try {
    let workflowData = {};
    
    // Execute workflow nodes in order (synchronous style for Apps Script)
${executionOrder.map((nodeId, index) => {
  const node = graph.nodes.find(n => n.id === nodeId);
  if (!node) return '';
  
  const indent = '    ';
  if (index === 0) {
    return `${indent}// ${node.name || node.op}
${indent}workflowData = execute${capitalizeFirst(node.op.split('.').pop() || 'Node')}(${JSON.stringify(node.params)});`;
  } else {
    return `${indent}
${indent}// ${node.name || node.op}
${indent}workflowData = execute${capitalizeFirst(node.op.split('.').pop() || 'Node')}(workflowData, ${JSON.stringify(node.params)});`;
  }
}).join('\n')}
    
    console.log('‚úÖ Workflow completed successfully');
    return workflowData;
    
  } catch (error) {
    console.error('‚ùå Workflow failed:', error);
    throw error;
  }
}`;

  return code;
}

function buildExecutionOrder(graph: WorkflowGraph): string[] {
  // Simple topological sort based on edges
  const visited = new Set<string>();
  const order: string[] = [];
  
  // Find nodes with no incoming edges (triggers)
  const triggerNodes = graph.nodes.filter(n => n.type === 'trigger');
  const actionNodes = graph.nodes.filter(n => n.type === 'action');
  const transformNodes = graph.nodes.filter(n => n.type === 'transform');
  
  // Add triggers first
  triggerNodes.forEach(node => {
    if (!visited.has(node.id)) {
      visited.add(node.id);
      order.push(node.id);
    }
  });
  
  // Add transforms
  transformNodes.forEach(node => {
    if (!visited.has(node.id)) {
      visited.add(node.id);
      order.push(node.id);
    }
  });
  
  // Add actions
  actionNodes.forEach(node => {
    if (!visited.has(node.id)) {
      visited.add(node.id);
      order.push(node.id);
    }
  });
  
  return order;
}

function generateTriggerSetup(triggerNodes: WorkflowNode[]): string {
  return `
function setupTriggers() {
  // Remove existing triggers
  ScriptApp.getProjectTriggers().forEach(tr => {
    if (tr.getHandlerFunction() === 'main') ScriptApp.deleteTrigger(tr);
  });
  
  // Create new triggers based on workflow configuration
${triggerNodes.filter(t => t.op.includes('time') || t.op.includes('schedule')).map(trigger => {
  const params = trigger.params;
  if (params.frequency === 'daily') {
    return `  ScriptApp.newTrigger('main')
    .timeBased()
    .everyDays(1)
    .atHour(9)
    .create();`;
  } else if (params.frequency === 'hourly') {
    return `  ScriptApp.newTrigger('main')
    .timeBased()
    .everyHours(1)
    .create();`;
  } else if (params.frequency === 'weekly') {
    return `  ScriptApp.newTrigger('main')
    .timeBased()
    .everyWeeks(1)
    .onWeekDay(ScriptApp.WeekDay.MONDAY)
    .create();`;
  }
  return '';
}).filter(Boolean).join('\n')}
}`;
}

function generateNodeFunctions(nodes: WorkflowNode[]): string[] {
  const codeBlocks: string[] = [];
  
  // Generate execution functions for each unique node operation
  const nodeOps = new Set(nodes.map(n => n.op));
  
  nodeOps.forEach(nodeOp => {
    const node = nodes.find(n => n.op === nodeOp);
    if (!node) return;
    
    codeBlocks.push(generateNodeExecutionFunction(nodeOp, node));
  });
  
  return codeBlocks;
}

function generateNodeExecutionFunction(nodeOp: string, node: WorkflowNode): string {
  const functionName = `execute${capitalizeFirst(nodeOp.split('.').pop() || 'Node')}`;
  
  if (nodeOp.startsWith('gmail.') || node.app === 'gmail') {
    return generateGmailTriggerFunction(functionName, node);
  } else if (nodeOp.startsWith('sheets.') || node.app === 'sheets') {
    return generateSheetsActionFunction(functionName, node);
  } else if (nodeOp.startsWith('slack.') || node.app === 'slack') {
    return generateSlackActionFunction(functionName, node);
  } else if (nodeOp.startsWith('dropbox.') || node.app === 'dropbox') {
    return generateDropboxActionFunction(functionName, node);
  } else if (nodeOp.startsWith('calendar.') || node.app === 'calendar') {
    return generateCalendarTriggerFunction(functionName, node);
  } else if (nodeOp.startsWith('email.') || node.app === 'email') {
    return generateEmailTransformFunction(functionName, node);
  } else if (nodeOp.startsWith('time.') || node.app === 'time') {
    return generateTimeTriggerFunction(functionName, node);
  } else if (nodeOp.startsWith('system.') || node.app === 'system') {
    return generateSystemActionFunction(functionName, node);
  } else if (nodeOp.startsWith('shopify.') || node.app === 'shopify') {
    return generateShopifyActionFunction(functionName, node);
  } else if (nodeOp.startsWith('salesforce.') || node.app === 'salesforce') {
    return generateSalesforceActionFunction(functionName, node);
  } else if (nodeOp.startsWith('jira.') || node.app === 'jira') {
    return generateJiraActionFunction(functionName, node);
  } else if (nodeOp.startsWith('forms.') || node.app === 'forms') {
    return generateFormsActionFunction(functionName, node);
  } else if (nodeOp.startsWith('mailchimp.') || node.app === 'mailchimp') {
    return generateMailchimpActionFunction(functionName, node);
  } else if (nodeOp.startsWith('hubspot.') || node.app === 'hubspot') {
    return generateHubspotActionFunction(functionName, node);
  }
  
  // Default generic function
  return `
async function ${functionName}(inputData, params) {
  console.log('üîß Executing ${node.name || nodeOp}');
  console.log('üì• Input:', inputData);
  console.log('‚öôÔ∏è Params:', params);
  
  // TODO: Implement ${nodeOp} execution logic
  return { ...inputData, ${nodeOp.replace(/\./g, '_')}: 'executed' };
}`;
}

function generateGmailTriggerFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(params) {
  console.log('üìß Executing Gmail trigger: ${node.name || 'New Email Detection'}');
  
  const query = params.query || 'is:unread';
  const maxResults = params.maxResults || 10;
  
  try {
    const threads = GmailApp.search(query, 0, maxResults);
    const emails = [];
    
    threads.forEach(thread => {
      const messages = thread.getMessages();
      messages.forEach(message => {
        emails.push({
          id: message.getId(),
          subject: message.getSubject(),
          from: message.getFrom(),
          date: message.getDate(),
          body: message.getPlainBody(),
          threadId: thread.getId()
        });
      });
    });
    
    console.log(\`üìß Found \${emails.length} emails matching query: \${query}\`);
    return { emails, query, maxResults };
    
  } catch (error) {
    console.error('‚ùå Gmail trigger failed:', error);
    throw error;
  }
}`;
}

function generateSheetsActionFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('üìä Executing Sheets action: ${node.name || 'Append Row'}');
  
  const spreadsheetId = params.spreadsheetId;
  const sheetName = params.sheetName || 'Sheet1';
  
  if (!spreadsheetId) {
    throw new Error('Spreadsheet ID is required');
  }
  
  try {
    const spreadsheet = SpreadsheetApp.openById(spreadsheetId);
    const sheet = spreadsheet.getSheetByName(sheetName);
    
    if (!sheet) {
      throw new Error(\`Sheet '\${sheetName}' not found in spreadsheet\`);
    }
    
    // Prepare data for insertion
    let rowData = [];
    if (inputData.emails && Array.isArray(inputData.emails)) {
      inputData.emails.forEach(email => {
        rowData.push([
          email.subject || '',
          email.from || '',
          email.date || new Date(),
          email.body || ''
        ]);
      });
    } else {
      // Single row insertion
      rowData.push([
        inputData.subject || '',
        inputData.from || '',
        inputData.date || new Date(),
        inputData.body || ''
      ]);
    }
    
    // Append data to sheet
    if (rowData.length > 0) {
      sheet.getRange(sheet.getLastRow() + 1, 1, rowData.length, rowData[0].length).setValues(rowData);
      console.log(\`‚úÖ Added \${rowData.length} rows to sheet '\${sheetName}'\`);
    }
    
    return { ...inputData, sheetsUpdated: true, rowsAdded: rowData.length };
    
  } catch (error) {
    console.error('‚ùå Sheets action failed:', error);
    throw error;
  }
}`;
}

function generateSlackActionFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('üí¨ Executing Slack action: ${node.name || 'Send Message'}');
  
  const webhookUrl = PropertiesService.getScriptProperties().getProperty('SLACK_WEBHOOK_URL');
  const channel = params.channel || '#general';
  const message = params.message || inputData.message || 'Workflow notification';
  
  if (!webhookUrl) {
    console.warn('‚ö†Ô∏è Slack webhook URL not configured, skipping Slack action');
    return { ...inputData, slackSkipped: true };
  }
  
  try {
    const payload = {
      channel: channel,
      text: message,
      username: 'Apps Script Bot',
      icon_emoji: ':robot_face:'
    };
    
    const response = UrlFetchApp.fetch(webhookUrl, {
      method: 'POST',
      contentType: 'application/json',
      payload: JSON.stringify(payload)
    });
    
    if (response.getResponseCode() === 200) {
      console.log(\`‚úÖ Slack message sent to \${channel}\`);
      return { ...inputData, slackSent: true, channel, message };
    } else {
      console.warn(\`‚ö†Ô∏è Slack message failed with status: \${response.getResponseCode()}\`);
      return { ...inputData, slackFailed: true, status: response.getResponseCode() };
    }
    
  } catch (error) {
    console.error('‚ùå Slack action failed:', error);
    return { ...inputData, slackError: error.message };
  }
}`;
}

function generateDropboxActionFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('‚òÅÔ∏è Executing Dropbox action: ${node.name || 'Upload File'}');
  
  const dropboxToken = PropertiesService.getScriptProperties().getProperty('DROPBOX_TOKEN');
  const destination = params.destination || '/backup';
  
  if (!dropboxToken) {
    console.warn('‚ö†Ô∏è Dropbox token not configured, skipping Dropbox action');
    return { ...inputData, dropboxSkipped: true };
  }
  
  try {
    let filesToUpload = [];
    
    if (inputData.files && Array.isArray(inputData.files)) {
      filesToUpload = inputData.files;
    } else if (inputData.emails && Array.isArray(inputData.emails)) {
      // Convert email data to file-like structure
      filesToUpload = inputData.emails.map((email, index) => ({
        name: \`email_\${index + 1}.txt\`,
        content: \`Subject: \${email.subject}\\nFrom: \${email.from}\\nDate: \${email.date}\\n\\n\${email.body}\`
      }));
    }
    
    if (filesToUpload.length === 0) {
      console.log('‚ÑπÔ∏è No files to upload to Dropbox');
      return { ...inputData, dropboxNoFiles: true };
    }
    
    let uploadedCount = 0;
    
    for (const fileInfo of filesToUpload) {
      try {
        const response = UrlFetchApp.fetch('https://content.dropboxapi.com/2/files/upload', {
          method: 'POST',
          headers: {
            'Authorization': \`Bearer \${dropboxToken}\`,
            'Content-Type': 'application/octet-stream',
            'Dropbox-API-Arg': JSON.stringify({
              path: \`\${destination}/\${fileInfo.name}\`,
              mode: 'add',
              autorename: true
            })
          },
          payload: fileInfo.content || fileInfo.blob || ''
        });
        
        if (response.getResponseCode() === 200) {
          console.log(\`‚úÖ Uploaded \${fileInfo.name} to Dropbox\`);
          uploadedCount++;
        } else {
          console.warn(\`‚ö†Ô∏è Failed to upload \${fileInfo.name}: \${response.getResponseCode()}\`);
        }
      } catch (fileError) {
        console.error(\`‚ùå Error uploading \${fileInfo.name}:\`, fileError);
      }
    }
    
    console.log(\`üì§ Dropbox upload completed: \${uploadedCount}/\${filesToUpload.length} files\`);
    return { ...inputData, dropboxUploaded: uploadedCount, dropboxTotal: filesToUpload.length };
    
  } catch (error) {
    console.error('‚ùå Dropbox action failed:', error);
    return { ...inputData, dropboxError: error.message };
  }
}`;
}

function generateCalendarTriggerFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(params) {
  console.log('üìÖ Executing Calendar trigger: ${node.name || 'Event Detection'}');
  
  const calendarId = params.calendarId || 'primary';
  const eventType = params.eventType || 'birthday';
  const daysAhead = params.daysAhead || 7;
  
  try {
    const calendar = CalendarApp.getCalendarById(calendarId);
    const now = new Date();
    const future = new Date(now.getTime() + daysAhead * 24 * 60 * 60 * 1000);
    
    const events = calendar.getEvents(now, future);
    const filteredEvents = events.filter(event => {
      if (eventType === 'birthday') {
        return event.getTitle().toLowerCase().includes('birthday') || 
               event.getDescription()?.toLowerCase().includes('birthday');
      }
      return true;
    });
    
    const eventData = filteredEvents.map(event => ({
      id: event.getId(),
      title: event.getTitle(),
      start: event.getStartTime(),
      end: event.getEndTime(),
      description: event.getDescription(),
      location: event.getLocation(),
      attendees: event.getGuestList().map(guest => guest.getEmail())
    }));
    
    console.log(\`üìÖ Found \${eventData.length} events in the next \${daysAhead} days\`);
    return { events: eventData, calendarId, eventType, daysAhead };
    
  } catch (error) {
    console.error('‚ùå Calendar trigger failed:', error);
    throw error;
  }
}`;
}

function generateEmailTransformFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('üîß Executing Email transform: ${node.name || 'Extract Data'}');
  
  const fields = params.fields || ['subject', 'from', 'date'];
  const includeAttachments = params.includeAttachments || false;
  
  try {
    if (!inputData.emails || !Array.isArray(inputData.emails)) {
      console.log('‚ÑπÔ∏è No emails to transform');
      return { ...inputData, transformedEmails: [] };
    }
    
    const transformedEmails = inputData.emails.map(email => {
      const transformed = {};
      
      fields.forEach(field => {
        if (field === 'subject') transformed.subject = email.subject || '';
        if (field === 'from') transformed.from = email.from || '';
        if (field === 'date') transformed.date = email.date || '';
        if (field === 'body') transformed.body = email.body || '';
        if (field === 'threadId') transformed.threadId = email.threadId || '';
      });
      
      if (includeAttachments && email.attachments) {
        transformed.attachments = email.attachments;
      }
      
      return transformed;
    });
    
    console.log(\`üîß Transformed \${transformedEmails.length} emails with fields: \${fields.join(', ')}\`);
    return { ...inputData, transformedEmails, fields };
    
  } catch (error) {
    console.error('‚ùå Email transform failed:', error);
    return { ...inputData, transformError: error.message };
  }
}`;
}

function generateTimeTriggerFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(params) {
  console.log('‚è∞ Executing Time trigger: ${node.name || 'Scheduled Execution'}');
  
  const frequency = params.frequency || 'daily';
  const time = params.time || '09:00';
  
  try {
    const now = new Date();
    const [hours, minutes] = time.split(':').map(Number);
    
    console.log(\`‚è∞ Time trigger executed at \${now.toISOString()}\`);
    console.log(\`üìÖ Schedule: \${frequency} at \${time}\`);
    
    return { 
      triggerTime: now.toISOString(),
      frequency,
      scheduledTime: time,
      message: \`Workflow triggered by \${frequency} schedule at \${time}\`
    };
    
  } catch (error) {
    console.error('‚ùå Time trigger failed:', error);
    throw error;
  }
}`;
}

function generateSystemActionFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('üîß Executing System action: ${node.name || 'Log Activity'}');
  
  const message = params.message || 'Workflow executed';
  const level = params.level || 'info';
  
  try {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      inputData: Object.keys(inputData),
      nodeType: '${node.type}'
    };
    
    // Log to Apps Script console
    if (level === 'error') {
      console.error(\`[SYSTEM] \${message}\`);
    } else if (level === 'warn') {
      console.warn(\`[SYSTEM] \${message}\`);
    } else {
      console.log(\`[SYSTEM] \${message}\`);
    }
    
    // Store in PropertiesService for audit trail
    const logs = PropertiesService.getScriptProperties().getProperty('WORKFLOW_LOGS') || '[]';
    const logArray = JSON.parse(logs);
    logArray.push(logEntry);
    
    // Keep only last 100 logs
    if (logArray.length > 100) {
      logArray.splice(0, logArray.length - 100);
    }
    
    PropertiesService.getScriptProperties().setProperty('WORKFLOW_LOGS', JSON.stringify(logArray));
    
    console.log(\`‚úÖ System action completed: \${message}\`);
    return { ...inputData, systemLogged: true, logEntry };
    
  } catch (error) {
    console.error('‚ùå System action failed:', error);
    return { ...inputData, systemError: error.message };
  }
}`;
}

function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Popular app implementations

function generateShopifyActionFunction(functionName: string, node: WorkflowNode): string {
  return `
function ${functionName}(inputData, params) {
  console.log('üõçÔ∏è Executing Shopify action: ${node.name || 'Shopify Operation'}');
  
  const apiKey = PropertiesService.getScriptProperties().getProperty('SHOPIFY_API_KEY');
  const shopDomain = PropertiesService.getScriptProperties().getProperty('SHOPIFY_SHOP_DOMAIN');
  const apiVersion = '2023-07';
  
  if (!apiKey || !shopDomain) {
    console.warn('‚ö†Ô∏è Shopify API credentials not configured');
    return { ...inputData, shopifySkipped: true, error: 'Missing API credentials' };
  }
  
  try {
    const baseUrl = \`https://\${shopDomain}.myshopify.com/admin/api/\${apiVersion}\`;
    let endpoint = '';
    let method = 'GET';
    let payload = null;
    
    // Handle different Shopify operations
    if (params.operation === 'create_product') {
      endpoint = '/products.json';
      method = 'POST';
      payload = {
        product: {
          title: params.title || 'New Product',
          body_html: params.description || '',
          vendor: params.vendor || '',
          product_type: params.product_type || '',
          tags: params.tags || ''
        }
      };
    } else if (params.operation === 'get_orders') {
      endpoint = '/orders.json';
      method = 'GET';
    } else if (params.operation === 'create_customer') {
      endpoint = '/customers.json';
      method = 'POST';
      payload = {
        customer: {
          first_name: params.first_name || '',
          last_name: params.last_name || '',
          email: params.email || '',
          phone: params.phone || '',
          accepts_marketing: params.accepts_marketing || false
        }
      };
    }
    
    const options = {
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'X-Shopify-Access-Token': apiKey
      }
    };
    
    if (payload) {
      options.payload = JSON.stringify(payload);
    }
    
    const response = UrlFetchApp.fetch(baseUrl + endpoint, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode >= 200 && responseCode < 300) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Shopify operation successful: \${params.operation}\`);
      return { ...inputData, shopifyResult: data, shopifySuccess: true };
    } else {
      console.error(\`‚ùå Shopify API error: \${responseCode}\`);
      return { ...inputData, shopifyError: \`API error: \${responseCode}\`, shopifySuccess: false };
    }
    
  } catch (error) {
    console.error('‚ùå Shopify action failed:', error);
    return { ...inputData, shopifyError: error.toString(), shopifySuccess: false };
  }
}`;
}

function generateSalesforceActionFunction(functionName: string, node: WorkflowNode): string {
  return `
function ${functionName}(inputData, params) {
  console.log('‚òÅÔ∏è Executing Salesforce action: ${node.name || 'Salesforce Operation'}');
  
  const accessToken = PropertiesService.getScriptProperties().getProperty('SALESFORCE_ACCESS_TOKEN');
  const instanceUrl = PropertiesService.getScriptProperties().getProperty('SALESFORCE_INSTANCE_URL');
  
  if (!accessToken || !instanceUrl) {
    console.warn('‚ö†Ô∏è Salesforce credentials not configured');
    return { ...inputData, salesforceSkipped: true, error: 'Missing OAuth credentials' };
  }
  
  try {
    let endpoint = '';
    let method = 'GET';
    let payload = null;
    
    // Handle different Salesforce operations
    if (params.operation === 'create_lead') {
      endpoint = '/services/data/v58.0/sobjects/Lead/';
      method = 'POST';
      payload = {
        FirstName: params.first_name || '',
        LastName: params.last_name || '',
        Email: params.email || '',
        Company: params.company || '',
        LeadSource: params.lead_source || 'Website',
        Status: params.status || 'Open - Not Contacted'
      };
    } else if (params.operation === 'create_contact') {
      endpoint = '/services/data/v58.0/sobjects/Contact/';
      method = 'POST';
      payload = {
        FirstName: params.first_name || '',
        LastName: params.last_name || '',
        Email: params.email || '',
        AccountId: params.account_id || null
      };
    } else if (params.operation === 'query_records') {
      endpoint = \`/services/data/v58.0/query/?q=\${encodeURIComponent(params.soql || 'SELECT Id FROM Lead LIMIT 10')}\`;
      method = 'GET';
    }
    
    const options = {
      method: method,
      headers: {
        'Authorization': \`Bearer \${accessToken}\`,
        'Content-Type': 'application/json'
      }
    };
    
    if (payload) {
      options.payload = JSON.stringify(payload);
    }
    
    const response = UrlFetchApp.fetch(instanceUrl + endpoint, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode >= 200 && responseCode < 300) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Salesforce operation successful: \${params.operation}\`);
      return { ...inputData, salesforceResult: data, salesforceSuccess: true };
    } else {
      console.error(\`‚ùå Salesforce API error: \${responseCode}\`);
      return { ...inputData, salesforceError: \`API error: \${responseCode}\`, salesforceSuccess: false };
    }
    
  } catch (error) {
    console.error('‚ùå Salesforce action failed:', error);
    return { ...inputData, salesforceError: error.toString(), salesforceSuccess: false };
  }
}`;
}

function generateJiraActionFunction(functionName: string, node: WorkflowNode): string {
  return `
function ${functionName}(inputData, params) {
  console.log('üéØ Executing Jira action: ${node.name || 'Jira Operation'}');
  
  const baseUrl = PropertiesService.getScriptProperties().getProperty('JIRA_BASE_URL');
  const email = PropertiesService.getScriptProperties().getProperty('JIRA_EMAIL');
  const apiToken = PropertiesService.getScriptProperties().getProperty('JIRA_API_TOKEN');
  
  if (!baseUrl || !email || !apiToken) {
    console.warn('‚ö†Ô∏è Jira credentials not configured');
    return { ...inputData, jiraSkipped: true, error: 'Missing Jira credentials' };
  }
  
  try {
    let endpoint = '';
    let method = 'GET';
    let payload = null;
    
    // Handle different Jira operations
    if (params.operation === 'create_issue') {
      endpoint = '/rest/api/3/issue';
      method = 'POST';
      payload = {
        fields: {
          project: { key: params.project_key || 'PROJ' },
          summary: params.summary || 'New Issue',
          description: params.description || '',
          issuetype: { name: params.issue_type || 'Task' },
          assignee: params.assignee ? { name: params.assignee } : null
        }
      };
    } else if (params.operation === 'get_issue') {
      endpoint = \`/rest/api/3/issue/\${params.issue_key}\`;
      method = 'GET';
    } else if (params.operation === 'search_issues') {
      endpoint = \`/rest/api/3/search?jql=\${encodeURIComponent(params.jql || 'project = PROJ')}\`;
      method = 'GET';
    }
    
    const auth = Utilities.base64Encode(\`\${email}:\${apiToken}\`);
    const options = {
      method: method,
      headers: {
        'Authorization': \`Basic \${auth}\`,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    };
    
    if (payload) {
      options.payload = JSON.stringify(payload);
    }
    
    const response = UrlFetchApp.fetch(baseUrl + endpoint, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode >= 200 && responseCode < 300) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Jira operation successful: \${params.operation}\`);
      return { ...inputData, jiraResult: data, jiraSuccess: true };
    } else {
      console.error(\`‚ùå Jira API error: \${responseCode}\`);
      return { ...inputData, jiraError: \`API error: \${responseCode}\`, jiraSuccess: false };
    }
    
  } catch (error) {
    console.error('‚ùå Jira action failed:', error);
    return { ...inputData, jiraError: error.toString(), jiraSuccess: false };
  }
}`;
}

function generateFormsActionFunction(functionName: string, node: WorkflowNode): string {
  return `
function ${functionName}(inputData, params) {
  console.log('üìù Executing Forms action: ${node.name || 'Form Operation'}');
  
  try {
    // Handle form triggers (Google Forms integration)
    if (params.operation === 'get_responses') {
      const formId = params.formId;
      if (!formId) {
        throw new Error('Form ID is required');
      }
      
      const form = FormApp.openById(formId);
      const responses = form.getResponses();
      const formData = [];
      
      responses.forEach(response => {
        const itemResponses = response.getItemResponses();
        const responseData = {
          id: response.getId(),
          timestamp: response.getTimestamp(),
          respondentEmail: response.getRespondentEmail(),
          answers: {}
        };
        
        itemResponses.forEach(itemResponse => {
          const question = itemResponse.getItem().getTitle();
          responseData.answers[question] = itemResponse.getResponse();
        });
        
        formData.push(responseData);
      });
      
      console.log(\`‚úÖ Retrieved \${formData.length} form responses\`);
      return { ...inputData, formResponses: formData, formSuccess: true };
    }
    
    // Default form processing
    return { ...inputData, formProcessed: true };
    
  } catch (error) {
    console.error('‚ùå Forms action failed:', error);
    return { ...inputData, formError: error.toString(), formSuccess: false };
  }
}`;
}

function generateMailchimpActionFunction(functionName: string, node: WorkflowNode): string {
  return `
function ${functionName}(inputData, params) {
  console.log('üìß Executing Mailchimp action: ${node.name || 'Mailchimp Operation'}');
  
  const apiKey = PropertiesService.getScriptProperties().getProperty('MAILCHIMP_API_KEY');
  if (!apiKey) {
    console.warn('‚ö†Ô∏è Mailchimp API key not configured');
    return { ...inputData, mailchimpSkipped: true, error: 'Missing API key' };
  }
  
  try {
    const datacenter = apiKey.split('-')[1];
    const baseUrl = \`https://\${datacenter}.api.mailchimp.com/3.0\`;
    
    let endpoint = '';
    let method = 'GET';
    let payload = null;
    
    // Handle different Mailchimp operations
    if (params.operation === 'add_subscriber') {
      const listId = params.list_id || params.listId;
      endpoint = \`/lists/\${listId}/members\`;
      method = 'POST';
      payload = {
        email_address: params.email || inputData.email,
        status: 'subscribed',
        merge_fields: {
          FNAME: params.first_name || inputData.first_name || '',
          LNAME: params.last_name || inputData.last_name || ''
        },
        tags: params.tags ? params.tags.split(',') : []
      };
    } else if (params.operation === 'get_lists') {
      endpoint = '/lists';
      method = 'GET';
    }
    
    const options = {
      method: method,
      headers: {
        'Authorization': \`apikey \${apiKey}\`,
        'Content-Type': 'application/json'
      }
    };
    
    if (payload) {
      options.payload = JSON.stringify(payload);
    }
    
    const response = UrlFetchApp.fetch(baseUrl + endpoint, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode >= 200 && responseCode < 300) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ Mailchimp operation successful: \${params.operation}\`);
      return { ...inputData, mailchimpResult: data, mailchimpSuccess: true };
    } else {
      console.error(\`‚ùå Mailchimp API error: \${responseCode}\`);
      return { ...inputData, mailchimpError: \`API error: \${responseCode}\`, mailchimpSuccess: false };
    }
    
  } catch (error) {
    console.error('‚ùå Mailchimp action failed:', error);
    return { ...inputData, mailchimpError: error.toString(), mailchimpSuccess: false };
  }
}`;
}

function generateHubspotActionFunction(functionName: string, node: WorkflowNode): string {
  return `
function ${functionName}(inputData, params) {
  console.log('üéØ Executing HubSpot action: ${node.name || 'HubSpot Operation'}');
  
  const accessToken = PropertiesService.getScriptProperties().getProperty('HUBSPOT_ACCESS_TOKEN');
  if (!accessToken) {
    console.warn('‚ö†Ô∏è HubSpot access token not configured');
    return { ...inputData, hubspotSkipped: true, error: 'Missing access token' };
  }
  
  try {
    const baseUrl = 'https://api.hubapi.com';
    let endpoint = '';
    let method = 'GET';
    let payload = null;
    
    // Handle different HubSpot operations
    if (params.operation === 'create_contact') {
      endpoint = '/crm/v3/objects/contacts';
      method = 'POST';
      payload = {
        properties: {
          firstname: params.first_name || inputData.first_name || '',
          lastname: params.last_name || inputData.last_name || '',
          email: params.email || inputData.email || '',
          company: params.company || inputData.company || '',
          phone: params.phone || inputData.phone || ''
        }
      };
    } else if (params.operation === 'create_deal') {
      endpoint = '/crm/v3/objects/deals';
      method = 'POST';
      payload = {
        properties: {
          dealname: params.deal_name || 'New Deal',
          amount: params.amount || '0',
          dealstage: params.deal_stage || 'appointmentscheduled',
          pipeline: params.pipeline || 'default'
        }
      };
    } else if (params.operation === 'get_contacts') {
      endpoint = '/crm/v3/objects/contacts';
      method = 'GET';
    }
    
    const options = {
      method: method,
      headers: {
        'Authorization': \`Bearer \${accessToken}\`,
        'Content-Type': 'application/json'
      }
    };
    
    if (payload) {
      options.payload = JSON.stringify(payload);
    }
    
    const response = UrlFetchApp.fetch(baseUrl + endpoint, options);
    const responseCode = response.getResponseCode();
    
    if (responseCode >= 200 && responseCode < 300) {
      const data = JSON.parse(response.getContentText());
      console.log(\`‚úÖ HubSpot operation successful: \${params.operation}\`);
      return { ...inputData, hubspotResult: data, hubspotSuccess: true };
    } else {
      console.error(\`‚ùå HubSpot API error: \${responseCode}\`);
      return { ...inputData, hubspotError: \`API error: \${responseCode}\`, hubspotSuccess: false };
    }
    
  } catch (error) {
    console.error('‚ùå HubSpot action failed:', error);
    return { ...inputData, hubspotError: error.toString(), hubspotSuccess: false };
  }
}`;