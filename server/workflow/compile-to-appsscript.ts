import { CompileResult, WorkflowGraph } from '../../common/workflow-types';

export function compileToAppsScript(graph: WorkflowGraph): CompileResult {
  const triggers   = graph.nodes.filter(n => n.type === 'trigger').length;
  const actions    = graph.nodes.filter(n => n.type === 'action').length;
  const transforms = graph.nodes.filter(n => n.type === 'transform').length;

  const code = emitCode(graph);
  const manifest = emitManifest();

  return {
    workflowId: graph.id,
    graph,
    stats: { nodes: graph.nodes.length, triggers, actions, transforms },
    files: [
      { path: 'Code.gs',        content: code },
      { path: 'appsscript.json', content: manifest },
    ],
  };
}

function emitManifest(): string {
  return JSON.stringify({
    timeZone: 'Etc/UTC',
    exceptionLogging: 'STACKDRIVER',
    oauthScopes: [
      'https://www.googleapis.com/auth/gmail.modify',
      'https://www.googleapis.com/auth/spreadsheets',
      'https://www.googleapis.com/auth/script.external_request',
      'https://www.googleapis.com/auth/calendar',
      'https://www.googleapis.com/auth/drive'
    ],
  }, null, 2);
}

function emitCode(graph: WorkflowGraph): string {
  console.log(`🔧 Walking graph with ${graph.nodes.length} nodes and ${graph.edges.length} edges`);
  
  // Walk the graph to generate proper code
  const triggerNodes = graph.nodes.filter(n => n.type === 'trigger');
  const actionNodes = graph.nodes.filter(n => n.type === 'action');
  const transformNodes = graph.nodes.filter(n => n.type === 'transform');
  
  console.log(`📊 Graph analysis: ${triggerNodes.length} triggers, ${actionNodes.length} actions, ${transformNodes.length} transforms`);
  
  // Generate code by walking execution path
  let codeBlocks: string[] = [];
  
  // Add header
  codeBlocks.push(`
/**
 * Generated by Apps Script Studio - Intelligent Workflow
 * Prompt: ${graph.meta?.prompt || 'Automated workflow'}
 * Nodes: ${graph.nodes.length} | Edges: ${graph.edges.length}
 */`);
  
  // Generate main function
  codeBlocks.push(generateMainFunction(graph, triggerNodes, transformNodes, actionNodes));
  
  // Generate trigger setup if needed
  if (triggerNodes.some(t => t.op.includes('time') || t.op.includes('schedule'))) {
    codeBlocks.push(generateTriggerSetup(triggerNodes));
  }
  
  // Generate helper functions for each node type
  codeBlocks.push(...generateNodeFunctions(graph.nodes));
  
  return codeBlocks.join('\n\n');
}

function generateDriveBackupCode(graph: WorkflowGraph, meta: any): string {
  const triggerNode = graph.nodes.find(n => n.type === 'trigger');
  const actionNode = graph.nodes.find(n => n.type === 'action');
  
  const source = meta?.source || 'Drive folder';
  const destination = meta?.destination || 'Dropbox folder';
  const frequency = meta?.frequency || 5;
  
  return `
/**
 * Generated by Apps Script Studio
 * Workflow: ${meta?.prompt || 'Drive to Dropbox backup'}
 */
function main() {
  console.log('🚀 Starting Drive backup workflow...');
  
  try {
    // Get files from Drive folder
    console.log('📂 Scanning ${source} for files...');
    const folder = DriveApp.getFolderById('${triggerNode?.params?.folderId || 'your-folder-id'}');
    const files = folder.getFiles();
    
    const filesToBackup = [];
    while (files.hasNext()) {
      const file = files.next();
      filesToBackup.push({
        name: file.getName(),
        id: file.getId(),
        size: file.getSize(),
        mimeType: file.getBlob().getContentType()
      });
    }
    
    console.log(\`Found \${filesToBackup.length} files to backup\`);
    
    if (filesToBackup.length === 0) {
      console.log('No files found to backup');
      return;
    }
    
    // Backup to Dropbox (using UrlFetchApp)
    filesToBackup.forEach(fileInfo => {
      console.log(\`📤 Backing up: \${fileInfo.name}\`);
      
      const file = DriveApp.getFileById(fileInfo.id);
      const fileBlob = file.getBlob();
      
      // Note: This requires Dropbox API token in PropertiesService
      const dropboxToken = PropertiesService.getScriptProperties().getProperty('DROPBOX_TOKEN');
      
      if (dropboxToken) {
        const response = UrlFetchApp.fetch('https://content.dropboxapi.com/2/files/upload', {
          method: 'POST',
          headers: {
            'Authorization': \`Bearer \${dropboxToken}\`,
            'Content-Type': 'application/octet-stream',
            'Dropbox-API-Arg': JSON.stringify({
              path: \`${destination}/\${fileInfo.name}\`,
              mode: 'add',
              autorename: true
            })
          },
          payload: fileBlob.getBytes()
        });
        
        if (response.getResponseCode() === 200) {
          console.log(\`✅ Successfully backed up: \${fileInfo.name}\`);
        } else {
          console.error(\`❌ Failed to backup: \${fileInfo.name}\`);
        }
      } else {
        console.error('❌ Dropbox token not configured in PropertiesService');
      }
    });
    
    console.log('✅ Backup workflow completed');
    
  } catch (error) {
    console.error('❌ Backup workflow failed:', error);
    throw error;
  }
}

function setupTriggers() {
  ScriptApp.getProjectTriggers().forEach(tr => {
    if (tr.getHandlerFunction() === 'main') ScriptApp.deleteTrigger(tr);
  });
  
  ScriptApp.newTrigger('main')
    .timeBased()
    .everyWeeks(1)
    .onWeekDay(ScriptApp.WeekDay.SUNDAY)
    .create();
    
  console.log('⏰ Trigger set up to run weekly on Sunday');
}

function testWorkflow() {
  console.log('🧪 Testing backup workflow manually...');
  main();
}
`.trim();
}

function generateCalendarNotificationCode(graph: WorkflowGraph, meta: any): string {
  const actionNode = graph.nodes.find(n => n.type === 'action');
  
  const channel = actionNode?.params?.channel || 'general';
  const message = actionNode?.params?.message || 'Happy Birthday! 🎉';
  
  return `
/**
 * Generated by Apps Script Studio
 * Workflow: ${meta?.prompt || 'Calendar birthday notifications'}
 */
function main() {
  console.log('🚀 Starting birthday notification workflow...');
  
  try {
    const today = new Date();
    const calendar = CalendarApp.getDefaultCalendar();
    const events = calendar.getEventsForDay(today);
    
    console.log(\`📅 Found \${events.length} events for today\`);
    
    const birthdayEvents = events.filter(event => {
      const title = event.getTitle().toLowerCase();
      return title.includes('birthday') || title.includes('bday') || title.includes('🎂');
    });
    
    console.log(\`🎂 Found \${birthdayEvents.length} birthday events\`);
    
    if (birthdayEvents.length === 0) {
      console.log('No birthdays today');
      return;
    }
    
    birthdayEvents.forEach(event => {
      const personName = extractNameFromTitle(event.getTitle());
      const customMessage = \`${message} \${personName}!\`;
      
      console.log(\`📤 Sending birthday message for: \${personName}\`);
      
      const slackWebhook = PropertiesService.getScriptProperties().getProperty('SLACK_WEBHOOK');
      
      if (slackWebhook) {
        const payload = {
          channel: '#${channel}',
          text: customMessage,
          username: 'Birthday Bot',
          icon_emoji: ':birthday:'
        };
        
        const response = UrlFetchApp.fetch(slackWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          payload: JSON.stringify(payload)
        });
        
        if (response.getResponseCode() === 200) {
          console.log(\`✅ Birthday message sent for: \${personName}\`);
        } else {
          console.error(\`❌ Failed to send message for: \${personName}\`);
        }
      } else {
        console.error('❌ Slack webhook not configured');
      }
    });
    
    console.log('✅ Birthday notification workflow completed');
    
  } catch (error) {
    console.error('❌ Birthday workflow failed:', error);
    throw error;
  }
}

function extractNameFromTitle(title) {
  const cleaned = title.replace(/birthday|bday|🎂/gi, '').trim();
  return cleaned || 'Someone';
}

function setupTriggers() {
  ScriptApp.getProjectTriggers().forEach(tr => {
    if (tr.getHandlerFunction() === 'main') ScriptApp.deleteTrigger(tr);
  });
  
  ScriptApp.newTrigger('main')
    .timeBased()
    .everyDays(1)
    .atHour(9)
    .create();
    
  console.log('⏰ Trigger set up to run daily at 9 AM');
}

function testWorkflow() {
  console.log('🧪 Testing birthday workflow manually...');
  main();
}
`.trim();
}

function generateSlackAutomationCode(graph: WorkflowGraph, meta: any): string {
  return generateCalendarNotificationCode(graph, meta);
}

function generateGmailSheetsCode(graph: WorkflowGraph, meta: any): string {
  const triggerNodes = graph.nodes.filter(n => n.type === 'trigger');
  const actionNodes = graph.nodes.filter(n => n.type === 'action');
  const transformNodes = graph.nodes.filter(n => n.type === 'transform');
  
  let mainFunction = `/**
 * Generated by Apps Script Studio
 * Workflow: ${meta?.prompt || 'Gmail to Sheets automation'}
 */
function main() {
  console.log('🚀 Starting Gmail to Sheets workflow...');
  
  try {
`;

  triggerNodes.forEach(trigger => {
    if (trigger.app === 'gmail-enhanced' || trigger.app === 'gmail') {
      const query = trigger.params?.query || 'in:inbox is:unread';
      const maxResults = trigger.params?.maxResults || 50;
      
      mainFunction += `
    console.log('📧 Searching Gmail with query: ${query}');
    const threads = GmailApp.search(${JSON.stringify(query)}, 0, ${maxResults});
    console.log(\`Found \${threads.length} email threads\`);
    
    if (!threads.length) {
      console.log('No emails found matching criteria');
      return;
    }
    
    const emailData = [];
`;
    }
  });

  transformNodes.forEach(transform => {
    if (transform.op === 'extract_fields') {
      const fields = transform.params?.fields || ['subject', 'from', 'date'];
      
      mainFunction += `
    threads.forEach(thread => {
      const messages = thread.getMessages();
      messages.forEach(message => {
        const extractedData = {`;
        
      fields.forEach(field => {
        switch(field) {
          case 'subject':
            mainFunction += `
          subject: message.getSubject() || '',`;
            break;
          case 'from':
            mainFunction += `
          from: message.getFrom() || '',`;
            break;
          case 'date':
            mainFunction += `
          date: Utilities.formatDate(message.getDate(), Session.getScriptTimeZone(), 'yyyy-MM-dd HH:mm'),`;
            break;
          case 'body':
            mainFunction += `
          body: (message.getPlainBody() || '').substring(0, 500),`;
            break;
        }
      });
      
      mainFunction += `
        };
        emailData.push(extractedData);
      });
    });
    
    console.log(\`Extracted data from \${emailData.length} emails\`);
`;
    }
  });

  actionNodes.forEach(action => {
    if (action.app === 'google-sheets-enhanced' || action.app === 'sheets') {
      const sheetId = action.params?.spreadsheetId || meta?.spreadsheetId;
      const sheetName = action.params?.sheet || meta?.sheetName || 'Sheet1';
      
      mainFunction += `
    if (emailData.length > 0) {
      console.log('📊 Writing to Google Sheets...');
      const ss = SpreadsheetApp.openById(${JSON.stringify(sheetId)});
      const sheet = ss.getSheetByName(${JSON.stringify(sheetName)}) || ss.getSheets()[0];
      
      emailData.forEach(data => {
        const row = [
          data.subject || '',
          data.from || '',
          data.date || '',
          data.body || ''
        ];
        sheet.appendRow(row);
        console.log(\`Added row: \${data.subject}\`);
      });
      
      console.log(\`✅ Successfully added \${emailData.length} rows to ${sheetName}\`);
    }
`;
    }
  });

  mainFunction += `
  } catch (error) {
    console.error('❌ Workflow execution failed:', error);
    throw error;
  }
}`;

  const triggerSetup = triggerNodes.map(trigger => {
    if (trigger.params?.frequency) {
      return `
function setupTriggers() {
  ScriptApp.getProjectTriggers().forEach(tr => {
    if (tr.getHandlerFunction() === 'main') {
      ScriptApp.deleteTrigger(tr);
    }
  });
  
  ScriptApp.newTrigger('main')
    .timeBased()
    .everyMinutes(${trigger.params.frequency})
    .create();
    
  console.log('⏰ Trigger set up to run every ${trigger.params.frequency} minutes');
}`;
    }
    return '';
  }).join('');

  const testFunction = `
function testWorkflow() {
  console.log('🧪 Testing Gmail to Sheets workflow manually...');
  main();
}`;

  return (mainFunction + triggerSetup + testFunction).trim();
}

// ===== NEW GRAPH WALKER FUNCTIONS =====

function generateMainFunction(graph: WorkflowGraph, triggerNodes: any[], transformNodes: any[], actionNodes: any[]): string {
  return `
function main() {
  console.log('🚀 Starting workflow execution...');
  
  try {
    let workflowData = {};
    
    // Execute triggers
    ${triggerNodes.map(node => `workflowData = executeNode_${node.id}(workflowData);`).join('\n    ')}
    
    // Execute transforms
    ${transformNodes.map(node => `workflowData = executeNode_${node.id}(workflowData);`).join('\n    ')}
    
    // Execute actions
    ${actionNodes.map(node => `workflowData = executeNode_${node.id}(workflowData);`).join('\n    ')}
    
    console.log('✅ Workflow completed successfully');
    return workflowData;
    
  } catch (error) {
    console.error('❌ Workflow failed:', error);
    throw error;
  }
}`;
}

function generateTriggerSetup(triggerNodes: any[]): string {
  const timeBasedTriggers = triggerNodes.filter(t => t.op.includes('time') || t.op.includes('schedule'));
  
  if (timeBasedTriggers.length === 0) return '';
  
  return `
function setupTriggers() {
  // Clear existing triggers
  ScriptApp.getProjectTriggers().forEach(trigger => {
    if (trigger.getHandlerFunction() === 'main') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  
  // Setup new triggers
  ${timeBasedTriggers.map(trigger => {
    const frequency = trigger.params?.frequency || 5;
    return `ScriptApp.newTrigger('main').timeBased().everyMinutes(${frequency}).create();`;
  }).join('\n  ')}
  
  console.log('⏰ Triggers setup completed');
}`;
}

function generateNodeFunctions(nodes: any[]): string[] {
  return nodes.map(node => {
    const funcName = `executeNode_${node.id}`;
    const code = generateNodeCode(node);
    
    return `
function ${funcName}(inputData) {
  console.log('⚡ Executing ${node.name} (${node.app}.${node.op})');
  
  try {
${code}
  } catch (error) {
    console.error('❌ Node ${node.id} failed:', error);
    throw error;
  }
}`;
  });
}

function generateNodeCode(node: any): string {
  // Map node operations to actual Google Apps Script code
  const { app, op, params } = node;
  
  switch (`${app}.${op}`) {
    // Gmail operations
    case 'gmail.search':
    case 'gmail.watch_inbox':
      return generateGmailSearchCode(params);
    case 'gmail.send_email':
      return generateGmailSendCode(params);
      
    // Google Sheets operations  
    case 'google-sheets.append_row':
    case 'sheets.append_row':
      return generateSheetsAppendCode(params);
    case 'google-sheets.read_data':
    case 'sheets.read_data':
      return generateSheetsReadCode(params);
      
    // Google Drive operations
    case 'google-drive.scan_folder':
    case 'drive.scan_folder':
      return generateDriveScanCode(params);
    case 'google-drive.backup_file':
    case 'drive.backup_file':
      return generateDriveBackupCode(params);
      
    // Calendar operations
    case 'google-calendar.watch_events':
    case 'calendar.watch_events':
      return generateCalendarWatchCode(params);
      
    // Dropbox operations (via API)
    case 'dropbox.upload_file':
      return generateDropboxUploadCode(params);
      
    // Slack operations (via webhook)
    case 'slack.send_message':
    case 'slack-enhanced.send_message':
      return generateSlackSendCode(params);
      
    // Transform operations
    case 'core.pick_fields':
    case 'transform.pick_fields':
      return generatePickFieldsCode(params);
    case 'core.filter_data':
    case 'transform.filter_data':
      return generateFilterDataCode(params);
      
    default:
      console.warn(`⚠️ Unknown operation: ${app}.${op}`);
      return `    // TODO: Implement ${app}.${op}
    console.log('⚠️ Placeholder for ${app}.${op}');
    return inputData;`;
  }
}

// ===== NODE CODE GENERATORS =====

function generateGmailSearchCode(params: any): string {
  const query = params?.query || 'is:unread';
  return `    const threads = GmailApp.search('${query}', 0, 50);
    const emails = [];
    
    threads.forEach(thread => {
      const messages = thread.getMessages();
      messages.forEach(msg => {
        emails.push({
          subject: msg.getSubject(),
          from: msg.getFrom(),
          body: msg.getPlainBody(),
          date: msg.getDate(),
          id: msg.getId()
        });
      });
    });
    
    console.log(\`📧 Found \${emails.length} emails matching query: ${query}\`);
    return { ...inputData, emails };`;
}

function generateGmailSendCode(params: any): string {
  const to = params?.to || 'recipient@example.com';
  const subject = params?.subject || 'Automated Email';
  return `    const recipients = '${to}';
    const emailSubject = '${subject}';
    const body = inputData.message || 'Automated message from workflow';
    
    GmailApp.sendEmail(recipients, emailSubject, body);
    console.log(\`📤 Email sent to \${recipients}\`);
    return { ...inputData, emailSent: true };`;
}

function generateSheetsAppendCode(params: any): string {
  const sheetId = params?.sheetId || 'your-sheet-id';
  const sheetName = params?.sheetName || 'Sheet1';
  return `    const sheet = SpreadsheetApp.openById('${sheetId}').getSheetByName('${sheetName}');
    
    if (inputData.emails && Array.isArray(inputData.emails)) {
      inputData.emails.forEach(email => {
        const row = [
          new Date(),
          email.subject || '',
          email.from || '',
          email.body?.substring(0, 500) || ''
        ];
        sheet.appendRow(row);
      });
      console.log(\`📊 Added \${inputData.emails.length} rows to sheet\`);
    } else {
      const row = [new Date(), JSON.stringify(inputData)];
      sheet.appendRow(row);
      console.log('📊 Added data row to sheet');
    }
    
    return { ...inputData, sheetUpdated: true };`;
}

function generateSheetsReadCode(params: any): string {
  const sheetId = params?.sheetId || 'your-sheet-id';
  const range = params?.range || 'A:Z';
  return `    const sheet = SpreadsheetApp.openById('${sheetId}');
    const values = sheet.getRange('${range}').getValues();
    
    console.log(\`📊 Read \${values.length} rows from sheet\`);
    return { ...inputData, sheetData: values };`;
}

function generateDriveScanCode(params: any): string {
  const folderId = params?.folderId || 'your-folder-id';
  return `    const folder = DriveApp.getFolderById('${folderId}');
    const files = folder.getFiles();
    const fileList = [];
    
    while (files.hasNext()) {
      const file = files.next();
      fileList.push({
        name: file.getName(),
        id: file.getId(),
        size: file.getSize(),
        modified: file.getLastUpdated()
      });
    }
    
    console.log(\`📂 Found \${fileList.length} files in folder\`);
    return { ...inputData, files: fileList };`;
}

function generateDriveBackupCode(params: any): string {
  return `    // Upload files to cloud storage
    if (inputData.files && Array.isArray(inputData.files)) {
      inputData.files.forEach(fileInfo => {
        console.log(\`📤 Backing up: \${fileInfo.name}\`);
        // Backup logic would go here
      });
    }
    
    return { ...inputData, backupCompleted: true };`;
}

function generateCalendarWatchCode(params: any): string {
  const calendarId = params?.calendarId || 'primary';
  return `    const calendar = CalendarApp.getCalendarById('${calendarId}');
    const now = new Date();
    const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);
    const events = calendar.getEvents(now, tomorrow);
    
    const eventData = events.map(event => ({
      title: event.getTitle(),
      start: event.getStartTime(),
      end: event.getEndTime(),
      description: event.getDescription()
    }));
    
    console.log(\`📅 Found \${events.length} upcoming events\`);
    return { ...inputData, events: eventData };`;
}

function generateDropboxUploadCode(params: any): string {
  const destination = params?.destination || '/backup';
  return `    // Upload to Dropbox via API
    if (inputData.files && Array.isArray(inputData.files)) {
      inputData.files.forEach(fileInfo => {
        const file = DriveApp.getFileById(fileInfo.id);
        const blob = file.getBlob();
        
        // Dropbox API call via UrlFetchApp
        const response = UrlFetchApp.fetch('https://content.dropboxapi.com/2/files/upload', {
          method: 'POST',
          headers: {
            'Authorization': 'Bearer YOUR_DROPBOX_TOKEN',
            'Dropbox-API-Arg': JSON.stringify({
              path: '${destination}/' + fileInfo.name,
              mode: 'add',
              autorename: true
            }),
            'Content-Type': 'application/octet-stream'
          },
          payload: blob
        });
        
        console.log(\`📤 Uploaded \${fileInfo.name} to Dropbox\`);
      });
    }
    
    return { ...inputData, dropboxUpload: true };`;
}

function generateSlackSendCode(params: any): string {
  const webhook = params?.webhook || 'YOUR_SLACK_WEBHOOK_URL';
  const channel = params?.channel || '#general';
  return `    const message = inputData.message || 'Workflow notification';
    
    const payload = {
      channel: '${channel}',
      text: message,
      username: 'Apps Script Bot'
    };
    
    UrlFetchApp.fetch('${webhook}', {
      method: 'POST',
      contentType: 'application/json',
      payload: JSON.stringify(payload)
    });
    
    console.log('💬 Slack message sent');
    return { ...inputData, slackSent: true };`;
}

function generatePickFieldsCode(params: any): string {
  const fields = params?.fields || ['subject', 'from', 'date'];
  return `    if (inputData.emails && Array.isArray(inputData.emails)) {
      const picked = inputData.emails.map(email => {
        const result = {};
        ${fields.map(field => `result['${field}'] = email['${field}'];`).join('\n        ')}
        return result;
      });
      
      console.log(\`🔍 Picked fields: ${fields.join(', ')}\`);
      return { ...inputData, emails: picked };
    }
    
    return inputData;`;
}

function generateFilterDataCode(params: any): string {
  const condition = params?.condition || 'item.subject && item.subject.length > 0';
  return `    if (inputData.emails && Array.isArray(inputData.emails)) {
      const filtered = inputData.emails.filter(item => ${condition});
      
      console.log(\`🔍 Filtered from \${inputData.emails.length} to \${filtered.length} items\`);
      return { ...inputData, emails: filtered };
    }
    
    return inputData;`;
}