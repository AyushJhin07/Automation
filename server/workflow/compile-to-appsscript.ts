import { CompileResult, WorkflowGraph, WorkflowNode } from '../../common/workflow-types';

export function compileToAppsScript(graph: WorkflowGraph): CompileResult {
  const triggers   = graph.nodes.filter(n => n.type === 'trigger').length;
  const actions    = graph.nodes.filter(n => n.type === 'action').length;
  const transforms = graph.nodes.filter(n => n.type === 'transform').length;

  const code = emitCode(graph);
  const manifest = emitManifest(graph);

  return {
    workflowId: graph.id,
    graph,
    stats: { nodes: graph.nodes.length, triggers, actions, transforms },
    files: [
      { path: 'Code.gs',        content: code },
      { path: 'appsscript.json', content: manifest },
    ],
  };
}

function emitManifest(graph: WorkflowGraph): string {
  // Collect all required scopes from the graph nodes
  const requiredScopes = new Set<string>([
    'https://www.googleapis.com/auth/script.external_request' // Always needed for external APIs
  ]);

  // Add scopes based on node types and apps
  graph.nodes.forEach(node => {
    if (node.app === 'gmail') {
      requiredScopes.add('https://www.googleapis.com/auth/gmail.modify');
    }
    if (node.app === 'sheets') {
      requiredScopes.add('https://www.googleapis.com/auth/spreadsheets');
    }
    if (node.app === 'calendar') {
      requiredScopes.add('https://www.googleapis.com/auth/calendar');
    }
    if (node.app === 'drive') {
      requiredScopes.add('https://www.googleapis.com/auth/drive');
    }
    if (node.app === 'slack') {
      // Slack uses external requests, already covered
    }
    if (node.app === 'dropbox') {
      // Dropbox uses external requests, already covered
    }
  });

  return JSON.stringify({
    timeZone: 'Etc/UTC',
    exceptionLogging: 'STACKDRIVER',
    oauthScopes: Array.from(requiredScopes),
  }, null, 2);
}

function emitCode(graph: WorkflowGraph): string {
  console.log(`üîß Walking graph with ${graph.nodes.length} nodes and ${graph.edges.length} edges`);
  
  // Analyze the graph structure
  const triggerNodes = graph.nodes.filter(n => n.type === 'trigger');
  const actionNodes = graph.nodes.filter(n => n.type === 'action');
  const transformNodes = graph.nodes.filter(n => n.type === 'transform');
  
  console.log(`üìä Graph analysis: ${triggerNodes.length} triggers, ${actionNodes.length} actions, ${transformNodes.length} transforms`);
  
  // Generate code by walking execution path
  let codeBlocks: string[] = [];
  
  // Add header
  codeBlocks.push(`
/**
 * Generated by Apps Script Studio - Intelligent Workflow
 * Prompt: ${graph.meta?.prompt || 'Automated workflow'}
 * Nodes: ${graph.nodes.length} | Edges: ${graph.edges.length}
 * Automation Type: ${graph.meta?.automationType || 'generic'}
 */`);
  
  // Generate main function
  codeBlocks.push(generateMainFunction(graph));
  
  // Generate trigger setup if needed
  if (triggerNodes.some(t => t.op.includes('time') || t.op.includes('schedule'))) {
    codeBlocks.push(generateTriggerSetup(triggerNodes));
  }
  
  // Generate helper functions for each node type
  codeBlocks.push(...generateNodeFunctions(graph.nodes));
  
  return codeBlocks.join('\n\n');
}

function generateMainFunction(graph: WorkflowGraph): string {
  // Build execution flow based on graph edges
  const executionOrder = buildExecutionOrder(graph);
  
  let code = `
function main() {
  console.log('üöÄ Starting intelligent workflow...');
  
  try {
    let workflowData = {};
    
    // Execute workflow nodes in order
${executionOrder.map((nodeId, index) => {
  const node = graph.nodes.find(n => n.id === nodeId);
  if (!node) return '';
  
  const indent = '    ';
  if (index === 0) {
    return `${indent}// ${node.name || node.op}
${indent}workflowData = await execute${capitalizeFirst(node.op.split('.').pop() || 'Node')}(${JSON.stringify(node.params)});`;
  } else {
    return `${indent}
${indent}// ${node.name || node.op}
${indent}workflowData = await execute${capitalizeFirst(node.op.split('.').pop() || 'Node')}(workflowData, ${JSON.stringify(node.params)});`;
  }
}).join('\n')}
    
    console.log('‚úÖ Workflow completed successfully');
    return workflowData;
    
  } catch (error) {
    console.error('‚ùå Workflow failed:', error);
    throw error;
  }
}`;

  return code;
}

function buildExecutionOrder(graph: WorkflowGraph): string[] {
  // Simple topological sort based on edges
  const visited = new Set<string>();
  const order: string[] = [];
  
  // Find nodes with no incoming edges (triggers)
  const triggerNodes = graph.nodes.filter(n => n.type === 'trigger');
  const actionNodes = graph.nodes.filter(n => n.type === 'action');
  const transformNodes = graph.nodes.filter(n => n.type === 'transform');
  
  // Add triggers first
  triggerNodes.forEach(node => {
    if (!visited.has(node.id)) {
      visited.add(node.id);
      order.push(node.id);
    }
  });
  
  // Add transforms
  transformNodes.forEach(node => {
    if (!visited.has(node.id)) {
      visited.add(node.id);
      order.push(node.id);
    }
  });
  
  // Add actions
  actionNodes.forEach(node => {
    if (!visited.has(node.id)) {
      visited.add(node.id);
      order.push(node.id);
    }
  });
  
  return order;
}

function generateTriggerSetup(triggerNodes: WorkflowNode[]): string {
  return `
function setupTriggers() {
  // Remove existing triggers
  ScriptApp.getProjectTriggers().forEach(tr => {
    if (tr.getHandlerFunction() === 'main') ScriptApp.deleteTrigger(tr);
  });
  
  // Create new triggers based on workflow configuration
${triggerNodes.filter(t => t.op.includes('time') || t.op.includes('schedule')).map(trigger => {
  const params = trigger.params;
  if (params.frequency === 'daily') {
    return `  ScriptApp.newTrigger('main')
    .timeBased()
    .everyDays(1)
    .atHour(9)
    .create();`;
  } else if (params.frequency === 'hourly') {
    return `  ScriptApp.newTrigger('main')
    .timeBased()
    .everyHours(1)
    .create();`;
  } else if (params.frequency === 'weekly') {
    return `  ScriptApp.newTrigger('main')
    .timeBased()
    .everyWeeks(1)
    .onWeekDay(ScriptApp.WeekDay.MONDAY)
    .create();`;
  }
  return '';
}).filter(Boolean).join('\n')}
}`;
}

function generateNodeFunctions(nodes: WorkflowNode[]): string[] {
  const codeBlocks: string[] = [];
  
  // Generate execution functions for each unique node operation
  const nodeOps = new Set(nodes.map(n => n.op));
  
  nodeOps.forEach(nodeOp => {
    const node = nodes.find(n => n.op === nodeOp);
    if (!node) return;
    
    codeBlocks.push(generateNodeExecutionFunction(nodeOp, node));
  });
  
  return codeBlocks;
}

function generateNodeExecutionFunction(nodeOp: string, node: WorkflowNode): string {
  const functionName = `execute${capitalizeFirst(nodeOp.split('.').pop() || 'Node')}`;
  
  if (nodeOp.startsWith('gmail.') || node.app === 'gmail') {
    return generateGmailTriggerFunction(functionName, node);
  } else if (nodeOp.startsWith('sheets.') || node.app === 'sheets') {
    return generateSheetsActionFunction(functionName, node);
  } else if (nodeOp.startsWith('slack.') || node.app === 'slack') {
    return generateSlackActionFunction(functionName, node);
  } else if (nodeOp.startsWith('dropbox.') || node.app === 'dropbox') {
    return generateDropboxActionFunction(functionName, node);
  } else if (nodeOp.startsWith('calendar.') || node.app === 'calendar') {
    return generateCalendarTriggerFunction(functionName, node);
  } else if (nodeOp.startsWith('email.') || node.app === 'email') {
    return generateEmailTransformFunction(functionName, node);
  } else if (nodeOp.startsWith('time.') || node.app === 'time') {
    return generateTimeTriggerFunction(functionName, node);
  } else if (nodeOp.startsWith('system.') || node.app === 'system') {
    return generateSystemActionFunction(functionName, node);
  }
  
  // Default generic function
  return `
async function ${functionName}(inputData, params) {
  console.log('üîß Executing ${node.name || nodeOp}');
  console.log('üì• Input:', inputData);
  console.log('‚öôÔ∏è Params:', params);
  
  // TODO: Implement ${nodeOp} execution logic
  return { ...inputData, ${nodeOp.replace(/\./g, '_')}: 'executed' };
}`;
}

function generateGmailTriggerFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(params) {
  console.log('üìß Executing Gmail trigger: ${node.name || 'New Email Detection'}');
  
  const query = params.query || 'is:unread';
  const maxResults = params.maxResults || 10;
  
  try {
    const threads = GmailApp.search(query, 0, maxResults);
    const emails = [];
    
    threads.forEach(thread => {
      const messages = thread.getMessages();
      messages.forEach(message => {
        emails.push({
          id: message.getId(),
          subject: message.getSubject(),
          from: message.getFrom(),
          date: message.getDate(),
          body: message.getPlainBody(),
          threadId: thread.getId()
        });
      });
    });
    
    console.log(\`üìß Found \${emails.length} emails matching query: \${query}\`);
    return { emails, query, maxResults };
    
  } catch (error) {
    console.error('‚ùå Gmail trigger failed:', error);
    throw error;
  }
}`;
}

function generateSheetsActionFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('üìä Executing Sheets action: ${node.name || 'Append Row'}');
  
  const spreadsheetId = params.spreadsheetId;
  const sheetName = params.sheetName || 'Sheet1';
  
  if (!spreadsheetId) {
    throw new Error('Spreadsheet ID is required');
  }
  
  try {
    const spreadsheet = SpreadsheetApp.openById(spreadsheetId);
    const sheet = spreadsheet.getSheetByName(sheetName);
    
    if (!sheet) {
      throw new Error(\`Sheet '\${sheetName}' not found in spreadsheet\`);
    }
    
    // Prepare data for insertion
    let rowData = [];
    if (inputData.emails && Array.isArray(inputData.emails)) {
      inputData.emails.forEach(email => {
        rowData.push([
          email.subject || '',
          email.from || '',
          email.date || new Date(),
          email.body || ''
        ]);
      });
    } else {
      // Single row insertion
      rowData.push([
        inputData.subject || '',
        inputData.from || '',
        inputData.date || new Date(),
        inputData.body || ''
      ]);
    }
    
    // Append data to sheet
    if (rowData.length > 0) {
      sheet.getRange(sheet.getLastRow() + 1, 1, rowData.length, rowData[0].length).setValues(rowData);
      console.log(\`‚úÖ Added \${rowData.length} rows to sheet '\${sheetName}'\`);
    }
    
    return { ...inputData, sheetsUpdated: true, rowsAdded: rowData.length };
    
  } catch (error) {
    console.error('‚ùå Sheets action failed:', error);
    throw error;
  }
}`;
}

function generateSlackActionFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('üí¨ Executing Slack action: ${node.name || 'Send Message'}');
  
  const webhookUrl = PropertiesService.getScriptProperties().getProperty('SLACK_WEBHOOK_URL');
  const channel = params.channel || '#general';
  const message = params.message || inputData.message || 'Workflow notification';
  
  if (!webhookUrl) {
    console.warn('‚ö†Ô∏è Slack webhook URL not configured, skipping Slack action');
    return { ...inputData, slackSkipped: true };
  }
  
  try {
    const payload = {
      channel: channel,
      text: message,
      username: 'Apps Script Bot',
      icon_emoji: ':robot_face:'
    };
    
    const response = UrlFetchApp.fetch(webhookUrl, {
      method: 'POST',
      contentType: 'application/json',
      payload: JSON.stringify(payload)
    });
    
    if (response.getResponseCode() === 200) {
      console.log(\`‚úÖ Slack message sent to \${channel}\`);
      return { ...inputData, slackSent: true, channel, message };
    } else {
      console.warn(\`‚ö†Ô∏è Slack message failed with status: \${response.getResponseCode()}\`);
      return { ...inputData, slackFailed: true, status: response.getResponseCode() };
    }
    
  } catch (error) {
    console.error('‚ùå Slack action failed:', error);
    return { ...inputData, slackError: error.message };
  }
}`;
}

function generateDropboxActionFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('‚òÅÔ∏è Executing Dropbox action: ${node.name || 'Upload File'}');
  
  const dropboxToken = PropertiesService.getScriptProperties().getProperty('DROPBOX_TOKEN');
  const destination = params.destination || '/backup';
  
  if (!dropboxToken) {
    console.warn('‚ö†Ô∏è Dropbox token not configured, skipping Dropbox action');
    return { ...inputData, dropboxSkipped: true };
  }
  
  try {
    let filesToUpload = [];
    
    if (inputData.files && Array.isArray(inputData.files)) {
      filesToUpload = inputData.files;
    } else if (inputData.emails && Array.isArray(inputData.emails)) {
      // Convert email data to file-like structure
      filesToUpload = inputData.emails.map((email, index) => ({
        name: \`email_\${index + 1}.txt\`,
        content: \`Subject: \${email.subject}\\nFrom: \${email.from}\\nDate: \${email.date}\\n\\n\${email.body}\`
      }));
    }
    
    if (filesToUpload.length === 0) {
      console.log('‚ÑπÔ∏è No files to upload to Dropbox');
      return { ...inputData, dropboxNoFiles: true };
    }
    
    let uploadedCount = 0;
    
    for (const fileInfo of filesToUpload) {
      try {
        const response = UrlFetchApp.fetch('https://content.dropboxapi.com/2/files/upload', {
          method: 'POST',
          headers: {
            'Authorization': \`Bearer \${dropboxToken}\`,
            'Content-Type': 'application/octet-stream',
            'Dropbox-API-Arg': JSON.stringify({
              path: \`\${destination}/\${fileInfo.name}\`,
              mode: 'add',
              autorename: true
            })
          },
          payload: fileInfo.content || fileInfo.blob || ''
        });
        
        if (response.getResponseCode() === 200) {
          console.log(\`‚úÖ Uploaded \${fileInfo.name} to Dropbox\`);
          uploadedCount++;
        } else {
          console.warn(\`‚ö†Ô∏è Failed to upload \${fileInfo.name}: \${response.getResponseCode()}\`);
        }
      } catch (fileError) {
        console.error(\`‚ùå Error uploading \${fileInfo.name}:\`, fileError);
      }
    }
    
    console.log(\`üì§ Dropbox upload completed: \${uploadedCount}/\${filesToUpload.length} files\`);
    return { ...inputData, dropboxUploaded: uploadedCount, dropboxTotal: filesToUpload.length };
    
  } catch (error) {
    console.error('‚ùå Dropbox action failed:', error);
    return { ...inputData, dropboxError: error.message };
  }
}`;
}

function generateCalendarTriggerFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(params) {
  console.log('üìÖ Executing Calendar trigger: ${node.name || 'Event Detection'}');
  
  const calendarId = params.calendarId || 'primary';
  const eventType = params.eventType || 'birthday';
  const daysAhead = params.daysAhead || 7;
  
  try {
    const calendar = CalendarApp.getCalendarById(calendarId);
    const now = new Date();
    const future = new Date(now.getTime() + daysAhead * 24 * 60 * 60 * 1000);
    
    const events = calendar.getEvents(now, future);
    const filteredEvents = events.filter(event => {
      if (eventType === 'birthday') {
        return event.getTitle().toLowerCase().includes('birthday') || 
               event.getDescription()?.toLowerCase().includes('birthday');
      }
      return true;
    });
    
    const eventData = filteredEvents.map(event => ({
      id: event.getId(),
      title: event.getTitle(),
      start: event.getStartTime(),
      end: event.getEndTime(),
      description: event.getDescription(),
      location: event.getLocation(),
      attendees: event.getGuestList().map(guest => guest.getEmail())
    }));
    
    console.log(\`üìÖ Found \${eventData.length} events in the next \${daysAhead} days\`);
    return { events: eventData, calendarId, eventType, daysAhead };
    
  } catch (error) {
    console.error('‚ùå Calendar trigger failed:', error);
    throw error;
  }
}`;
}

function generateEmailTransformFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('üîß Executing Email transform: ${node.name || 'Extract Data'}');
  
  const fields = params.fields || ['subject', 'from', 'date'];
  const includeAttachments = params.includeAttachments || false;
  
  try {
    if (!inputData.emails || !Array.isArray(inputData.emails)) {
      console.log('‚ÑπÔ∏è No emails to transform');
      return { ...inputData, transformedEmails: [] };
    }
    
    const transformedEmails = inputData.emails.map(email => {
      const transformed = {};
      
      fields.forEach(field => {
        if (field === 'subject') transformed.subject = email.subject || '';
        if (field === 'from') transformed.from = email.from || '';
        if (field === 'date') transformed.date = email.date || '';
        if (field === 'body') transformed.body = email.body || '';
        if (field === 'threadId') transformed.threadId = email.threadId || '';
      });
      
      if (includeAttachments && email.attachments) {
        transformed.attachments = email.attachments;
      }
      
      return transformed;
    });
    
    console.log(\`üîß Transformed \${transformedEmails.length} emails with fields: \${fields.join(', ')}\`);
    return { ...inputData, transformedEmails, fields };
    
  } catch (error) {
    console.error('‚ùå Email transform failed:', error);
    return { ...inputData, transformError: error.message };
  }
}`;
}

function generateTimeTriggerFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(params) {
  console.log('‚è∞ Executing Time trigger: ${node.name || 'Scheduled Execution'}');
  
  const frequency = params.frequency || 'daily';
  const time = params.time || '09:00';
  
  try {
    const now = new Date();
    const [hours, minutes] = time.split(':').map(Number);
    
    console.log(\`‚è∞ Time trigger executed at \${now.toISOString()}\`);
    console.log(\`üìÖ Schedule: \${frequency} at \${time}\`);
    
    return { 
      triggerTime: now.toISOString(),
      frequency,
      scheduledTime: time,
      message: \`Workflow triggered by \${frequency} schedule at \${time}\`
    };
    
  } catch (error) {
    console.error('‚ùå Time trigger failed:', error);
    throw error;
  }
}`;
}

function generateSystemActionFunction(functionName: string, node: WorkflowNode): string {
  return `
async function ${functionName}(inputData, params) {
  console.log('üîß Executing System action: ${node.name || 'Log Activity'}');
  
  const message = params.message || 'Workflow executed';
  const level = params.level || 'info';
  
  try {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      inputData: Object.keys(inputData),
      nodeType: '${node.type}'
    };
    
    // Log to Apps Script console
    if (level === 'error') {
      console.error(\`[SYSTEM] \${message}\`);
    } else if (level === 'warn') {
      console.warn(\`[SYSTEM] \${message}\`);
    } else {
      console.log(\`[SYSTEM] \${message}\`);
    }
    
    // Store in PropertiesService for audit trail
    const logs = PropertiesService.getScriptProperties().getProperty('WORKFLOW_LOGS') || '[]';
    const logArray = JSON.parse(logs);
    logArray.push(logEntry);
    
    // Keep only last 100 logs
    if (logArray.length > 100) {
      logArray.splice(0, logArray.length - 100);
    }
    
    PropertiesService.getScriptProperties().setProperty('WORKFLOW_LOGS', JSON.stringify(logArray));
    
    console.log(\`‚úÖ System action completed: \${message}\`);
    return { ...inputData, systemLogged: true, logEntry };
    
  } catch (error) {
    console.error('‚ùå System action failed:', error);
    return { ...inputData, systemError: error.message };
  }
}`;
}

function capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}