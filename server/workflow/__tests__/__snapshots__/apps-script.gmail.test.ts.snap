exports[`Apps Script Gmail REAL_OPS builds trigger.gmail:new_email_received 1`] = `

function onGmailNewEmailReceived() {
  return buildPollingWrapper('trigger.gmail:new_email_received', function (runtime) {
    const accessToken = getSecret('GMAIL_ACCESS_TOKEN', { connectorKey: 'gmail' });
    if (!accessToken) {
      logError('gmail_missing_access_token', { operation: 'trigger.gmail:new_email_received' });
      throw new Error('Missing Gmail access token for gmail.new_email_received trigger');
    }

    const interpolationContext = runtime.state && runtime.state.lastPayload ? runtime.state.lastPayload : {};
    const queryTemplate = 'is:unread';
    const query = queryTemplate ? interpolate(queryTemplate, interpolationContext).trim() : '';
    const labelIdsConfig = ["INBOX"];
    const labelIds = [];
    if (Array.isArray(labelIdsConfig)) {
      for (let i = 0; i < labelIdsConfig.length; i++) {
        const value = typeof labelIdsConfig[i] === 'string' ? interpolate(labelIdsConfig[i], interpolationContext).trim() : '';
        if (value) {
          labelIds.push(value);
        }
      }
    }

    const headers = { Authorization: 'Bearer ' + accessToken };
    const baseUrl = 'https://gmail.googleapis.com/gmail/v1/users/me';
    const cursor = (runtime.state && typeof runtime.state.cursor === 'object') ? runtime.state.cursor : {};
    const lastInternalDate = cursor && cursor.internalDate ? Number(cursor.internalDate) : null;
    const afterSeconds = lastInternalDate ? Math.floor(lastInternalDate / 1000) : null;
    const effectiveQuery = afterSeconds ? ((query ? query + ' ' : '') + 'after:' + afterSeconds) : query;
    const messages = [];
    let pageToken = null;
    let pageCount = 0;

    function decodeBase64Url(data) {
      if (!data) {
        return '';
      }
      try {
        const normalized = data.replace(/-/g, '+').replace(/_/g, '/');
        const bytes = Utilities.base64Decode(normalized);
        return Utilities.newBlob(bytes).getDataAsString('UTF-8');
      } catch (error) {
        logWarn('gmail_message_body_decode_failed', {
          message: error && error.message ? error.message : String(error)
        });
        return '';
      }
    }

    function extractHeader(all, name) {
      if (!Array.isArray(all)) {
        return '';
      }
      const target = name.toLowerCase();
      for (let i = 0; i < all.length; i++) {
        const header = all[i];
        if (!header || typeof header.name !== 'string') {
          continue;
        }
        if (header.name.toLowerCase() === target) {
          return header.value || '';
        }
      }
      return '';
    }

    function parseAddressList(value) {
      if (!value) {
        return [];
      }
      return value.split(',').map(part => part.trim()).filter(Boolean);
    }

    function collectAttachments(parts, bucket) {
      if (!Array.isArray(parts)) {
        return;
      }
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (!part) {
          continue;
        }
        if (part.filename && part.body && part.body.attachmentId) {
          bucket.push({
            attachmentId: part.body.attachmentId,
            filename: part.filename,
            mimeType: part.mimeType || 'application/octet-stream',
            size: part.body.size || 0
          });
        }
        if (Array.isArray(part.parts) && part.parts.length) {
          collectAttachments(part.parts, bucket);
        }
      }
    }

    function extractBodies(payload) {
      const result = {};
      if (!payload) {
        return result;
      }

      const queue = [payload];
      while (queue.length > 0) {
        const node = queue.shift();
        if (!node) {
          continue;
        }
        if (node.mimeType === 'text/plain' && node.body && node.body.data) {
          result.plain = decodeBase64Url(node.body.data);
        } else if (node.mimeType === 'text/html' && node.body && node.body.data) {
          result.html = decodeBase64Url(node.body.data);
        }
        if (Array.isArray(node.parts)) {
          for (let p = 0; p < node.parts.length; p++) {
            queue.push(node.parts[p]);
          }
        }
      }

      if (!result.plain && payload.body && payload.body.data) {
        result.plain = decodeBase64Url(payload.body.data);
      }

      return result;
    }

    try {
      do {
        const params = ['maxResults=25'];
        if (effectiveQuery) {
          params.push('q=' + encodeURIComponent(effectiveQuery));
        }
        if (Array.isArray(labelIds) && labelIds.length) {
          for (let i = 0; i < labelIds.length; i++) {
            params.push('labelIds=' + encodeURIComponent(labelIds[i]));
          }
        }
        if (pageToken) {
          params.push('pageToken=' + encodeURIComponent(pageToken));
        }

        const listResponse = rateLimitAware(
          () => fetchJson({
            url: baseUrl + '/messages?' + params.join('&'),
            method: 'GET',
            headers: headers
          }),
          { attempts: 5, backoffMs: 500 }
        );

        const listBody = listResponse.body || {};
        const candidates = Array.isArray(listBody.messages) ? listBody.messages : [];
        for (let i = 0; i < candidates.length; i++) {
          const messageId = candidates[i] && candidates[i].id;
          if (!messageId) {
            continue;
          }

          const messageResponse = rateLimitAware(
            () => fetchJson({
              url: baseUrl + '/messages/' + encodeURIComponent(messageId) + '?format=full',
              method: 'GET',
              headers: headers
            }),
            { attempts: 5, backoffMs: 500 }
          );

          const detail = messageResponse.body || {};
          const payload = detail.payload || {};
          const headersList = payload.headers || [];
          const bodies = extractBodies(payload);
          const attachments = [];
          collectAttachments(payload.parts, attachments);

          const internalDate = detail.internalDate ? Number(detail.internalDate) : null;
          if (lastInternalDate && internalDate && internalDate <= lastInternalDate) {
            continue;
          }

          const from = extractHeader(headersList, 'From');
          const to = parseAddressList(extractHeader(headersList, 'To'));
          const cc = parseAddressList(extractHeader(headersList, 'Cc'));
          const bcc = parseAddressList(extractHeader(headersList, 'Bcc'));
          const replyTo = parseAddressList(extractHeader(headersList, 'Reply-To'));
          const deliveredTo = extractHeader(headersList, 'Delivered-To');
          const subject = extractHeader(headersList, 'Subject') || null;
          const historyId = detail.historyId ? String(detail.historyId) : null;

          const fromName = from && from.indexOf('<') !== -1 ? from.split('<')[0].trim() : null;
          messages.push({
            internalDate: internalDate || Date.now(),
            historyId: historyId,
            payload: {
              id: detail.id || messageId,
              threadId: detail.threadId || null,
              historyId: historyId,
              labelIds: Array.isArray(detail.labelIds) ? detail.labelIds : [],
              subject: subject,
              snippet: detail.snippet || '',
              from: from,
              fromName: fromName,
              to: to,
              cc: cc,
              bcc: bcc,
              replyTo: replyTo,
              deliveredTo: deliveredTo || null,
              receivedAt: internalDate ? new Date(internalDate).toISOString() : new Date().toISOString(),
              sizeEstimate: detail.sizeEstimate || null,
              bodyPlain: bodies.plain || null,
              bodyHtml: bodies.html || null,
              attachments: attachments,
              threadSnippet: detail.snippet || null,
              raw: detail
            }
          });
        }

        if (messages.length >= 50) {
          pageToken = null;
        } else {
          pageToken = listBody.nextPageToken || null;
        }

        pageCount += 1;
      } while (pageToken && pageCount < 5 && messages.length < 50);

      if (messages.length === 0) {
        runtime.summary({
          messagesAttempted: 0,
          messagesDispatched: 0,
          messagesFailed: 0,
      labelCount: labelIds.length,
      query: effectiveQuery,
          labelIds: labelIds,
          lastInternalDate: lastInternalDate || null
        });
        return {
          messagesAttempted: 0,
          messagesDispatched: 0,
          messagesFailed: 0,
      labelCount: labelIds.length,
      query: effectiveQuery,
          labelIds: labelIds,
          lastInternalDate: lastInternalDate || null
        };
      }

      messages.sort(function (a, b) {
        return Number(a.internalDate) - Number(b.internalDate);
      });

      let lastPayloadDispatched = null;
      const batch = runtime.dispatchBatch(messages, function (entry) {
        const payload = {
          id: entry.payload.id,
          threadId: entry.payload.threadId,
          historyId: entry.payload.historyId,
          labelIds: entry.payload.labelIds,
          subject: entry.payload.subject,
          snippet: entry.payload.snippet,
          from: entry.payload.from,
          fromName: entry.payload.fromName,
          to: entry.payload.to,
          cc: entry.payload.cc,
          bcc: entry.payload.bcc,
          replyTo: entry.payload.replyTo,
          deliveredTo: entry.payload.deliveredTo,
          receivedAt: entry.payload.receivedAt,
          sizeEstimate: entry.payload.sizeEstimate,
          bodyPlain: entry.payload.bodyPlain,
          bodyHtml: entry.payload.bodyHtml,
          attachments: entry.payload.attachments,
          threadSnippet: entry.payload.threadSnippet,
          snippet: entry.payload.snippet,
          _meta: { raw: entry.payload.raw || null }
        };
        lastPayloadDispatched = payload;
        return payload;
      });

      runtime.state = runtime.state && typeof runtime.state === 'object' ? runtime.state : {};
      runtime.state.cursor = runtime.state.cursor && typeof runtime.state.cursor === 'object' ? runtime.state.cursor : {};
      runtime.state.cursor.internalDate = messages[messages.length - 1].internalDate;
      runtime.state.lastPayload = lastPayloadDispatched || runtime.state.lastPayload || null;

      runtime.summary({
        messagesAttempted: batch.attempted,
        messagesDispatched: batch.succeeded,
        messagesFailed: batch.failed,
      labelCount: labelIds.length,
      query: effectiveQuery,
        labelIds: labelIds,
        lastInternalDate: runtime.state.cursor.internalDate
      });

      logInfo('gmail_new_email_received_success', {
        dispatched: batch.succeeded,
      labelCount: labelIds.length,
      query: effectiveQuery,
        labelIds: labelIds,
        lastInternalDate: runtime.state.cursor.internalDate
      });

      return {
        messagesAttempted: batch.attempted,
        messagesDispatched: batch.succeeded,
        messagesFailed: batch.failed,
      labelCount: labelIds.length,
      query: effectiveQuery,
        labelIds: labelIds,
        lastInternalDate: runtime.state.cursor.internalDate
      };
    } catch (error) {
      const providerCode = error && error.body && error.body.error ? (error.body.error.status || error.body.error.code || null) : null;
      const providerMessage = error && error.body && error.body.error ? error.body.error.message : null;
      const status = error && typeof error.status === 'number' ? error.status : null;
      const message = providerMessage || (error && error.message ? error.message : String(error));
      logError('gmail_new_email_received_failed', {
        status: status,
        providerCode: providerCode,
        message: message
      });
      throw error;
    }
  });
}
`;

exports[`Apps Script Gmail REAL_OPS builds trigger.gmail:email_received_from 1`] = `

function onGmailEmailReceivedFrom() {
  return buildPollingWrapper('trigger.gmail:email_received_from', function (runtime) {
    const accessToken = getSecret('GMAIL_ACCESS_TOKEN', { connectorKey: 'gmail' });
    if (!accessToken) {
      logError('gmail_missing_access_token', { operation: 'trigger.gmail:email_received_from' });
      throw new Error('Missing Gmail access token for gmail.email_received_from trigger');
    }

    const interpolationContext = runtime.state && runtime.state.lastPayload ? runtime.state.lastPayload : {};
    const fromTemplate = 'alerts@example.com';
    const subjectTemplate = 'Status';
    const fromFilter = fromTemplate ? interpolate(fromTemplate, interpolationContext).trim() : '';
    if (!fromFilter) {
      throw new Error('trigger.gmail:email_received_from requires a fromEmail value before deployment.');
    }
    const subjectFilter = subjectTemplate ? interpolate(subjectTemplate, interpolationContext).trim() : '';
    const labelIds = [];
    const parts = ['from:' + fromFilter];
    if (subjectFilter) {
      parts.push('subject:"' + subjectFilter.replace(/"/g, '\"') + '"');
    }
    const query = parts.join(' ');

    const headers = { Authorization: 'Bearer ' + accessToken };
    const baseUrl = 'https://gmail.googleapis.com/gmail/v1/users/me';
    const cursor = (runtime.state && typeof runtime.state.cursor === 'object') ? runtime.state.cursor : {};
    const lastInternalDate = cursor && cursor.internalDate ? Number(cursor.internalDate) : null;
    const afterSeconds = lastInternalDate ? Math.floor(lastInternalDate / 1000) : null;
    const effectiveQuery = afterSeconds ? ((query ? query + ' ' : '') + 'after:' + afterSeconds) : query;
    const messages = [];
    let pageToken = null;
    let pageCount = 0;

    function decodeBase64Url(data) {
      if (!data) {
        return '';
      }
      try {
        const normalized = data.replace(/-/g, '+').replace(/_/g, '/');
        const bytes = Utilities.base64Decode(normalized);
        return Utilities.newBlob(bytes).getDataAsString('UTF-8');
      } catch (error) {
        logWarn('gmail_message_body_decode_failed', {
          message: error && error.message ? error.message : String(error)
        });
        return '';
      }
    }

    function extractHeader(all, name) {
      if (!Array.isArray(all)) {
        return '';
      }
      const target = name.toLowerCase();
      for (let i = 0; i < all.length; i++) {
        const header = all[i];
        if (!header || typeof header.name !== 'string') {
          continue;
        }
        if (header.name.toLowerCase() === target) {
          return header.value || '';
        }
      }
      return '';
    }

    function parseAddressList(value) {
      if (!value) {
        return [];
      }
      return value.split(',').map(part => part.trim()).filter(Boolean);
    }

    function collectAttachments(parts, bucket) {
      if (!Array.isArray(parts)) {
        return;
      }
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (!part) {
          continue;
        }
        if (part.filename && part.body && part.body.attachmentId) {
          bucket.push({
            attachmentId: part.body.attachmentId,
            filename: part.filename,
            mimeType: part.mimeType || 'application/octet-stream',
            size: part.body.size || 0
          });
        }
        if (Array.isArray(part.parts) && part.parts.length) {
          collectAttachments(part.parts, bucket);
        }
      }
    }

    function extractBodies(payload) {
      const result = {};
      if (!payload) {
        return result;
      }

      const queue = [payload];
      while (queue.length > 0) {
        const node = queue.shift();
        if (!node) {
          continue;
        }
        if (node.mimeType === 'text/plain' && node.body && node.body.data) {
          result.plain = decodeBase64Url(node.body.data);
        } else if (node.mimeType === 'text/html' && node.body && node.body.data) {
          result.html = decodeBase64Url(node.body.data);
        }
        if (Array.isArray(node.parts)) {
          for (let p = 0; p < node.parts.length; p++) {
            queue.push(node.parts[p]);
          }
        }
      }

      if (!result.plain && payload.body && payload.body.data) {
        result.plain = decodeBase64Url(payload.body.data);
      }

      return result;
    }

    try {
      do {
        const params = ['maxResults=25'];
        if (effectiveQuery) {
          params.push('q=' + encodeURIComponent(effectiveQuery));
        }
        if (Array.isArray(labelIds) && labelIds.length) {
          for (let i = 0; i < labelIds.length; i++) {
            params.push('labelIds=' + encodeURIComponent(labelIds[i]));
          }
        }
        if (pageToken) {
          params.push('pageToken=' + encodeURIComponent(pageToken));
        }

        const listResponse = rateLimitAware(
          () => fetchJson({
            url: baseUrl + '/messages?' + params.join('&'),
            method: 'GET',
            headers: headers
          }),
          { attempts: 5, backoffMs: 500 }
        );

        const listBody = listResponse.body || {};
        const candidates = Array.isArray(listBody.messages) ? listBody.messages : [];
        for (let i = 0; i < candidates.length; i++) {
          const messageId = candidates[i] && candidates[i].id;
          if (!messageId) {
            continue;
          }

          const messageResponse = rateLimitAware(
            () => fetchJson({
              url: baseUrl + '/messages/' + encodeURIComponent(messageId) + '?format=full',
              method: 'GET',
              headers: headers
            }),
            { attempts: 5, backoffMs: 500 }
          );

          const detail = messageResponse.body || {};
          const payload = detail.payload || {};
          const headersList = payload.headers || [];
          const bodies = extractBodies(payload);
          const attachments = [];
          collectAttachments(payload.parts, attachments);

          const internalDate = detail.internalDate ? Number(detail.internalDate) : null;
          if (lastInternalDate && internalDate && internalDate <= lastInternalDate) {
            continue;
          }

          const from = extractHeader(headersList, 'From');
          const to = parseAddressList(extractHeader(headersList, 'To'));
          const cc = parseAddressList(extractHeader(headersList, 'Cc'));
          const bcc = parseAddressList(extractHeader(headersList, 'Bcc'));
          const replyTo = parseAddressList(extractHeader(headersList, 'Reply-To'));
          const deliveredTo = extractHeader(headersList, 'Delivered-To');
          const subject = extractHeader(headersList, 'Subject') || null;
          const historyId = detail.historyId ? String(detail.historyId) : null;

          const fromName = from && from.indexOf('<') !== -1 ? from.split('<')[0].trim() : null;
          messages.push({
            internalDate: internalDate || Date.now(),
            historyId: historyId,
            payload: {
              id: detail.id || messageId,
              threadId: detail.threadId || null,
              historyId: historyId,
              labelIds: Array.isArray(detail.labelIds) ? detail.labelIds : [],
              subject: subject,
              snippet: detail.snippet || '',
              from: from,
              fromName: fromName,
              to: to,
              cc: cc,
              bcc: bcc,
              replyTo: replyTo,
              deliveredTo: deliveredTo || null,
              receivedAt: internalDate ? new Date(internalDate).toISOString() : new Date().toISOString(),
              sizeEstimate: detail.sizeEstimate || null,
              bodyPlain: bodies.plain || null,
              bodyHtml: bodies.html || null,
              attachments: attachments,
              threadSnippet: detail.snippet || null,
              raw: detail
            }
          });
        }

        if (messages.length >= 50) {
          pageToken = null;
        } else {
          pageToken = listBody.nextPageToken || null;
        }

        pageCount += 1;
      } while (pageToken && pageCount < 5 && messages.length < 50);

      if (messages.length === 0) {
        runtime.summary({
          messagesAttempted: 0,
          messagesDispatched: 0,
          messagesFailed: 0,
      fromEmail: fromFilter,
      subjectFilter: subjectFilter || null,
      query: effectiveQuery,
          labelIds: labelIds,
          lastInternalDate: lastInternalDate || null
        });
        return {
          messagesAttempted: 0,
          messagesDispatched: 0,
          messagesFailed: 0,
      fromEmail: fromFilter,
      subjectFilter: subjectFilter || null,
      query: effectiveQuery,
          labelIds: labelIds,
          lastInternalDate: lastInternalDate || null
        };
      }

      messages.sort(function (a, b) {
        return Number(a.internalDate) - Number(b.internalDate);
      });

      let lastPayloadDispatched = null;
      const batch = runtime.dispatchBatch(messages, function (entry) {
        const payload = {
          id: entry.payload.id,
          threadId: entry.payload.threadId,
          historyId: entry.payload.historyId,
          labelIds: entry.payload.labelIds,
          subject: entry.payload.subject,
          snippet: entry.payload.snippet,
          from: entry.payload.from,
          fromName: entry.payload.fromName,
          to: entry.payload.to,
          cc: entry.payload.cc,
          bcc: entry.payload.bcc,
          replyTo: entry.payload.replyTo,
          deliveredTo: entry.payload.deliveredTo,
          receivedAt: entry.payload.receivedAt,
          sizeEstimate: entry.payload.sizeEstimate,
          bodyPlain: entry.payload.bodyPlain,
          bodyHtml: entry.payload.bodyHtml,
          attachments: entry.payload.attachments,
          threadSnippet: entry.payload.threadSnippet,
          snippet: entry.payload.snippet,
          _meta: { raw: entry.payload.raw || null }
        };
        lastPayloadDispatched = payload;
        return payload;
      });

      runtime.state = runtime.state && typeof runtime.state === 'object' ? runtime.state : {};
      runtime.state.cursor = runtime.state.cursor && typeof runtime.state.cursor === 'object' ? runtime.state.cursor : {};
      runtime.state.cursor.internalDate = messages[messages.length - 1].internalDate;
      runtime.state.lastPayload = lastPayloadDispatched || runtime.state.lastPayload || null;

      runtime.summary({
        messagesAttempted: batch.attempted,
        messagesDispatched: batch.succeeded,
        messagesFailed: batch.failed,
      fromEmail: fromFilter,
      subjectFilter: subjectFilter || null,
      query: effectiveQuery,
        labelIds: labelIds,
        lastInternalDate: runtime.state.cursor.internalDate
      });

      logInfo('gmail_email_received_from_success', {
        dispatched: batch.succeeded,
      fromEmail: fromFilter,
      subjectFilter: subjectFilter || null,
      query: effectiveQuery,
        labelIds: labelIds,
        lastInternalDate: runtime.state.cursor.internalDate
      });

      return {
        messagesAttempted: batch.attempted,
        messagesDispatched: batch.succeeded,
        messagesFailed: batch.failed,
      fromEmail: fromFilter,
      subjectFilter: subjectFilter || null,
      query: effectiveQuery,
        labelIds: labelIds,
        lastInternalDate: runtime.state.cursor.internalDate
      };
    } catch (error) {
      const providerCode = error && error.body && error.body.error ? (error.body.error.status || error.body.error.code || null) : null;
      const providerMessage = error && error.body && error.body.error ? error.body.error.message : null;
      const status = error && typeof error.status === 'number' ? error.status : null;
      const message = providerMessage || (error && error.message ? error.message : String(error));
      logError('gmail_email_received_from_failed', {
        status: status,
        providerCode: providerCode,
        message: message
      });
      throw error;
    }
  });
}
`;

exports[`Apps Script Gmail REAL_OPS builds trigger.gmail:email_with_attachment 1`] = `

function onGmailEmailWithAttachment() {
  return buildPollingWrapper('trigger.gmail:email_with_attachment', function (runtime) {
    const accessToken = getSecret('GMAIL_ACCESS_TOKEN', { connectorKey: 'gmail' });
    if (!accessToken) {
      logError('gmail_missing_access_token', { operation: 'trigger.gmail:email_with_attachment' });
      throw new Error('Missing Gmail access token for gmail.email_with_attachment trigger');
    }

    const interpolationContext = runtime.state && runtime.state.lastPayload ? runtime.state.lastPayload : {};
    const fileTypesConfig = ["pdf"];
    const fromTemplate = 'finance@example.com';
    const fromFilter = fromTemplate ? interpolate(fromTemplate, interpolationContext).trim() : '';
    const fileTypes = [];
    if (Array.isArray(fileTypesConfig)) {
      for (let i = 0; i < fileTypesConfig.length; i++) {
        const value = typeof fileTypesConfig[i] === 'string' ? interpolate(fileTypesConfig[i], interpolationContext).trim() : '';
        if (value) {
          fileTypes.push(value.toLowerCase());
        }
      }
    }
    const queryParts = ['has:attachment'];
    if (fromFilter) {
      queryParts.push('from:' + fromFilter);
    }
    const query = queryParts.join(' ');
    const labelIds = [];

    const headers = { Authorization: 'Bearer ' + accessToken };
    const baseUrl = 'https://gmail.googleapis.com/gmail/v1/users/me';
    const cursor = (runtime.state && typeof runtime.state.cursor === 'object') ? runtime.state.cursor : {};
    const lastInternalDate = cursor && cursor.internalDate ? Number(cursor.internalDate) : null;
    const afterSeconds = lastInternalDate ? Math.floor(lastInternalDate / 1000) : null;
    const effectiveQuery = afterSeconds ? ((query ? query + ' ' : '') + 'after:' + afterSeconds) : query;
    const messages = [];
    let pageToken = null;
    let pageCount = 0;

    function decodeBase64Url(data) {
      if (!data) {
        return '';
      }
      try {
        const normalized = data.replace(/-/g, '+').replace(/_/g, '/');
        const bytes = Utilities.base64Decode(normalized);
        return Utilities.newBlob(bytes).getDataAsString('UTF-8');
      } catch (error) {
        logWarn('gmail_message_body_decode_failed', {
          message: error && error.message ? error.message : String(error)
        });
        return '';
      }
    }

    function extractHeader(all, name) {
      if (!Array.isArray(all)) {
        return '';
      }
      const target = name.toLowerCase();
      for (let i = 0; i < all.length; i++) {
        const header = all[i];
        if (!header || typeof header.name !== 'string') {
          continue;
        }
        if (header.name.toLowerCase() === target) {
          return header.value || '';
        }
      }
      return '';
    }

    function parseAddressList(value) {
      if (!value) {
        return [];
      }
      return value.split(',').map(part => part.trim()).filter(Boolean);
    }

    function collectAttachments(parts, bucket) {
      if (!Array.isArray(parts)) {
        return;
      }
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (!part) {
          continue;
        }
        if (part.filename && part.body && part.body.attachmentId) {
          bucket.push({
            attachmentId: part.body.attachmentId,
            filename: part.filename,
            mimeType: part.mimeType || 'application/octet-stream',
            size: part.body.size || 0
          });
        }
        if (Array.isArray(part.parts) && part.parts.length) {
          collectAttachments(part.parts, bucket);
        }
      }
    }

    function extractBodies(payload) {
      const result = {};
      if (!payload) {
        return result;
      }

      const queue = [payload];
      while (queue.length > 0) {
        const node = queue.shift();
        if (!node) {
          continue;
        }
        if (node.mimeType === 'text/plain' && node.body && node.body.data) {
          result.plain = decodeBase64Url(node.body.data);
        } else if (node.mimeType === 'text/html' && node.body && node.body.data) {
          result.html = decodeBase64Url(node.body.data);
        }
        if (Array.isArray(node.parts)) {
          for (let p = 0; p < node.parts.length; p++) {
            queue.push(node.parts[p]);
          }
        }
      }

      if (!result.plain && payload.body && payload.body.data) {
        result.plain = decodeBase64Url(payload.body.data);
      }

      return result;
    }

    try {
      do {
        const params = ['maxResults=25'];
        if (effectiveQuery) {
          params.push('q=' + encodeURIComponent(effectiveQuery));
        }
        if (Array.isArray(labelIds) && labelIds.length) {
          for (let i = 0; i < labelIds.length; i++) {
            params.push('labelIds=' + encodeURIComponent(labelIds[i]));
          }
        }
        if (pageToken) {
          params.push('pageToken=' + encodeURIComponent(pageToken));
        }

        const listResponse = rateLimitAware(
          () => fetchJson({
            url: baseUrl + '/messages?' + params.join('&'),
            method: 'GET',
            headers: headers
          }),
          { attempts: 5, backoffMs: 500 }
        );

        const listBody = listResponse.body || {};
        const candidates = Array.isArray(listBody.messages) ? listBody.messages : [];
        for (let i = 0; i < candidates.length; i++) {
          const messageId = candidates[i] && candidates[i].id;
          if (!messageId) {
            continue;
          }

          const messageResponse = rateLimitAware(
            () => fetchJson({
              url: baseUrl + '/messages/' + encodeURIComponent(messageId) + '?format=full',
              method: 'GET',
              headers: headers
            }),
            { attempts: 5, backoffMs: 500 }
          );

          const detail = messageResponse.body || {};
          const payload = detail.payload || {};
          const headersList = payload.headers || [];
          const bodies = extractBodies(payload);
          const attachments = [];
          collectAttachments(payload.parts, attachments);

          const internalDate = detail.internalDate ? Number(detail.internalDate) : null;
          if (lastInternalDate && internalDate && internalDate <= lastInternalDate) {
            continue;
          }

          const from = extractHeader(headersList, 'From');
          const to = parseAddressList(extractHeader(headersList, 'To'));
          const cc = parseAddressList(extractHeader(headersList, 'Cc'));
          const bcc = parseAddressList(extractHeader(headersList, 'Bcc'));
          const replyTo = parseAddressList(extractHeader(headersList, 'Reply-To'));
          const deliveredTo = extractHeader(headersList, 'Delivered-To');
          const subject = extractHeader(headersList, 'Subject') || null;
          const historyId = detail.historyId ? String(detail.historyId) : null;

          const fromName = from && from.indexOf('<') !== -1 ? from.split('<')[0].trim() : null;

        if (!attachments.length) {
          continue;
        }
        if (fileTypes.length) {
          let matchedType = false;
          for (let ft = 0; ft < attachments.length && !matchedType; ft++) {
            const attachment = attachments[ft] || {};
            const filename = (attachment.filename || '').toLowerCase();
            const mimeType = (attachment.mimeType || '').toLowerCase();
            for (let j = 0; j < fileTypes.length; j++) {
              const type = fileTypes[j];
              if (!type) {
                continue;
              }
              if ((filename && filename.endsWith('.' + type)) || (mimeType && mimeType.indexOf(type) !== -1)) {
                matchedType = true;
                break;
              }
            }
          }
          if (!matchedType) {
            continue;
          }
        }
          messages.push({
            internalDate: internalDate || Date.now(),
            historyId: historyId,
            payload: {
              id: detail.id || messageId,
              threadId: detail.threadId || null,
              historyId: historyId,
              labelIds: Array.isArray(detail.labelIds) ? detail.labelIds : [],
              subject: subject,
              snippet: detail.snippet || '',
              from: from,
              fromName: fromName,
              to: to,
              cc: cc,
              bcc: bcc,
              replyTo: replyTo,
              deliveredTo: deliveredTo || null,
              receivedAt: internalDate ? new Date(internalDate).toISOString() : new Date().toISOString(),
              sizeEstimate: detail.sizeEstimate || null,
              bodyPlain: bodies.plain || null,
              bodyHtml: bodies.html || null,
              attachments: attachments,
              threadSnippet: detail.snippet || null,
              raw: detail
            }
          });
        }

        if (messages.length >= 50) {
          pageToken = null;
        } else {
          pageToken = listBody.nextPageToken || null;
        }

        pageCount += 1;
      } while (pageToken && pageCount < 5 && messages.length < 50);

      if (messages.length === 0) {
        runtime.summary({
          messagesAttempted: 0,
          messagesDispatched: 0,
          messagesFailed: 0,
      fromEmail: fromFilter || null,
      fileTypes: fileTypes,
      query: effectiveQuery,
          labelIds: labelIds,
          lastInternalDate: lastInternalDate || null
        });
        return {
          messagesAttempted: 0,
          messagesDispatched: 0,
          messagesFailed: 0,
      fromEmail: fromFilter || null,
      fileTypes: fileTypes,
      query: effectiveQuery,
          labelIds: labelIds,
          lastInternalDate: lastInternalDate || null
        };
      }

      messages.sort(function (a, b) {
        return Number(a.internalDate) - Number(b.internalDate);
      });

      let lastPayloadDispatched = null;
      const batch = runtime.dispatchBatch(messages, function (entry) {
        const payload = {
          id: entry.payload.id,
          threadId: entry.payload.threadId,
          historyId: entry.payload.historyId,
          labelIds: entry.payload.labelIds,
          subject: entry.payload.subject,
          snippet: entry.payload.snippet,
          from: entry.payload.from,
          fromName: entry.payload.fromName,
          to: entry.payload.to,
          cc: entry.payload.cc,
          bcc: entry.payload.bcc,
          replyTo: entry.payload.replyTo,
          deliveredTo: entry.payload.deliveredTo,
          receivedAt: entry.payload.receivedAt,
          sizeEstimate: entry.payload.sizeEstimate,
          bodyPlain: entry.payload.bodyPlain,
          bodyHtml: entry.payload.bodyHtml,
          attachments: entry.payload.attachments,
          threadSnippet: entry.payload.threadSnippet,
          snippet: entry.payload.snippet,
          _meta: { raw: entry.payload.raw || null }
        };
        lastPayloadDispatched = payload;
        return payload;
      });

      runtime.state = runtime.state && typeof runtime.state === 'object' ? runtime.state : {};
      runtime.state.cursor = runtime.state.cursor && typeof runtime.state.cursor === 'object' ? runtime.state.cursor : {};
      runtime.state.cursor.internalDate = messages[messages.length - 1].internalDate;
      runtime.state.lastPayload = lastPayloadDispatched || runtime.state.lastPayload || null;

      runtime.summary({
        messagesAttempted: batch.attempted,
        messagesDispatched: batch.succeeded,
        messagesFailed: batch.failed,
      fromEmail: fromFilter || null,
      fileTypes: fileTypes,
      query: effectiveQuery,
        labelIds: labelIds,
        lastInternalDate: runtime.state.cursor.internalDate
      });

      logInfo('gmail_email_with_attachment_success', {
        dispatched: batch.succeeded,
      fromEmail: fromFilter || null,
      fileTypes: fileTypes,
      query: effectiveQuery,
        labelIds: labelIds,
        lastInternalDate: runtime.state.cursor.internalDate
      });

      return {
        messagesAttempted: batch.attempted,
        messagesDispatched: batch.succeeded,
        messagesFailed: batch.failed,
      fromEmail: fromFilter || null,
      fileTypes: fileTypes,
      query: effectiveQuery,
        labelIds: labelIds,
        lastInternalDate: runtime.state.cursor.internalDate
      };
    } catch (error) {
      const providerCode = error && error.body && error.body.error ? (error.body.error.status || error.body.error.code || null) : null;
      const providerMessage = error && error.body && error.body.error ? error.body.error.message : null;
      const status = error && typeof error.status === 'number' ? error.status : null;
      const message = providerMessage || (error && error.message ? error.message : String(error));
      logError('gmail_email_with_attachment_failed', {
        status: status,
        providerCode: providerCode,
        message: message
      });
      throw error;
    }
  });
}
`;

exports[`Apps Script Gmail REAL_OPS builds action.gmail:test_connection 1`] = `

function step_action_gmail_test_connection(ctx) {
  ctx = ctx || {};
  const accessToken = getSecret('GMAIL_ACCESS_TOKEN', { connectorKey: 'gmail' });
  if (!accessToken) {
    logError('gmail_missing_access_token', { operation: 'action.gmail:test_connection' });
    throw new Error('Missing Gmail access token for gmail.test_connection operation');
  }

  try {
    const profile = rateLimitAware(
      () => fetchJson({
        url: 'https://gmail.googleapis.com/gmail/v1/users/me/profile',
        method: 'GET',
        headers: {
          'Authorization': 'Bearer ' + accessToken,
          'Content-Type': 'application/json'
        }
      }),
      { attempts: 3, backoffMs: 500 }
    );

    const body = profile.body || {};
    ctx.gmailEmailAddress = body.emailAddress || ctx.gmailEmailAddress || null;
    ctx.gmailHistoryId = body.historyId || ctx.gmailHistoryId || null;

    logInfo('gmail_test_connection_success', {
      emailAddress: ctx.gmailEmailAddress || null,
      historyId: ctx.gmailHistoryId || null
    });

    return ctx;
  } catch (error) {
    const providerCode = error && error.body && error.body.error ? (error.body.error.status || error.body.error.code || null) : null;
    const providerMessage = error && error.body && error.body.error ? error.body.error.message : null;
    const status = error && typeof error.status === 'number' ? error.status : null;
    const message = providerMessage || (error && error.message ? error.message : String(error));
    logError('gmail_test_connection_failed', {
      operation: 'action.gmail:test_connection',
      status: status,
      providerCode: providerCode,
      message: message
    });
    throw new Error('Gmail test_connection failed: ' + (providerCode ? providerCode + ' ' : '') + message);
  }
}
`;

exports[`Apps Script Gmail REAL_OPS builds action.gmail:get_email 1`] = `

function step_action_gmail_get_email(ctx) {
  ctx = ctx || {};
  const accessToken = getSecret('GMAIL_ACCESS_TOKEN', { connectorKey: 'gmail' });
  if (!accessToken) {
    logError('gmail_missing_access_token', { operation: 'action.gmail:get_email' });
    throw new Error('Missing Gmail access token for gmail.get_email operation');
  }

  const messageId = interpolate('abc123', ctx).trim();
  const format = interpolate('full', ctx).trim() || 'full';
  if (!messageId) {
    logError('gmail_get_email_missing_param', { field: 'messageId' });
    throw new Error('Missing required Gmail get_email param: messageId');
  }

  try {
    const response = rateLimitAware(
      () => fetchJson({
        url: 'https://gmail.googleapis.com/gmail/v1/users/me/messages/' + encodeURIComponent(messageId) + '?format=' + encodeURIComponent(format),
        method: 'GET',
        headers: {
          'Authorization': 'Bearer ' + accessToken,
          'Content-Type': 'application/json'
        }
      }),
      { attempts: 5, backoffMs: 500 }
    );

    const body = response.body || {};
    ctx.gmailMessageId = body.id || ctx.gmailMessageId || null;
    ctx.gmailThreadId = body.threadId || ctx.gmailThreadId || null;
    ctx.gmailMessage = body;

    const attachments = [];
    function collect(parts) {
      if (!Array.isArray(parts)) {
        return;
      }
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (!part) {
          continue;
        }
        if (part.filename && part.body && part.body.attachmentId) {
          attachments.push({
            attachmentId: part.body.attachmentId,
            filename: part.filename,
            mimeType: part.mimeType || 'application/octet-stream',
            size: part.body.size || 0
          });
        }
        if (Array.isArray(part.parts) && part.parts.length) {
          collect(part.parts);
        }
      }
    }

    collect(body.payload && body.payload.parts);
    ctx.gmailAttachments = attachments;

    logInfo('gmail_get_email_success', {
      messageId: ctx.gmailMessageId || null,
      threadId: ctx.gmailThreadId || null,
      format: format,
      attachments: attachments.length
    });

    return ctx;
  } catch (error) {
    const providerCode = error && error.body && error.body.error ? (error.body.error.status || error.body.error.code || null) : null;
    const providerMessage = error && error.body && error.body.error ? error.body.error.message : null;
    const status = error && typeof error.status === 'number' ? error.status : null;
    const message = providerMessage || (error && error.message ? error.message : String(error));
    logError('gmail_get_email_failed', {
      operation: 'action.gmail:get_email',
      status: status,
      providerCode: providerCode,
      message: message
    });
    throw new Error('Gmail get_email failed: ' + (providerCode ? providerCode + ' ' : '') + message);
  }
}
`;

exports[`Apps Script Gmail REAL_OPS builds action.gmail:send_email 1`] = `

function step_action_gmail_send_email(ctx) {
  ctx = ctx || {};
  const accessToken = getSecret('GMAIL_ACCESS_TOKEN', { connectorKey: 'gmail' });
  if (!accessToken) {
    logError('gmail_missing_access_token', { operation: 'action.gmail:send_email' });
    throw new Error('Missing Gmail access token for gmail.send_email operation');
  }

  const to = interpolate('user@example.com', ctx).trim();
  const subject = interpolate('Hello', ctx).trim();
  const body = interpolate('Hi there', ctx);
  const cc = interpolate('', ctx).trim();
  const bcc = interpolate('', ctx).trim();
  const attachmentsConfig = [];

  function ensureParam(value, field) {
    if (!value) {
      logError('gmail_send_email_missing_param', { field: field });
      throw new Error('Missing required Gmail send_email param: ' + field);
    }
    return value;
  }

  ensureParam(to, 'to');
  ensureParam(subject, 'subject');
  ensureParam(body, 'body');

  const recipients = to.split(',').map(function (entry) { return entry.trim(); }).filter(Boolean);
  const ccList = cc ? cc.split(',').map(function (entry) { return entry.trim(); }).filter(Boolean) : [];
  const bccList = bcc ? bcc.split(',').map(function (entry) { return entry.trim(); }).filter(Boolean) : [];

  const headerLines = ['To: ' + recipients.join(', ')];
  if (ccList.length) {
    headerLines.push('Cc: ' + ccList.join(', '));
  }
  if (bccList.length) {
    headerLines.push('Bcc: ' + bccList.join(', '));
  }
  headerLines.push('Subject: ' + subject);
  headerLines.push('MIME-Version: 1.0');

  const attachments = [];
  if (Array.isArray(attachmentsConfig)) {
    for (let i = 0; i < attachmentsConfig.length; i++) {
      const descriptor = attachmentsConfig[i] || {};
      let filename = descriptor.filename;
      if (typeof filename === 'string') {
        filename = interpolate(filename, ctx).trim();
      }
      let mimeType = descriptor.mimeType || descriptor.contentType || 'application/octet-stream';
      if (typeof mimeType === 'string') {
        mimeType = interpolate(mimeType, ctx).trim() || 'application/octet-stream';
      }
      let content = descriptor.content;
      if (typeof content === 'string') {
        content = interpolate(content, ctx);
      }
      if (!filename || !content) {
        continue;
      }

      let encoded = '';
      try {
        const decoded = Utilities.base64Decode(String(content));
        encoded = Utilities.base64Encode(decoded);
      } catch (error) {
        logWarn('gmail_send_email_attachment_decode_failed', {
          index: i,
          message: error && error.message ? error.message : String(error)
        });
        const fallbackBytes = Utilities.newBlob(String(content)).getBytes();
        encoded = Utilities.base64Encode(fallbackBytes);
      }

      attachments.push({ filename: filename, mimeType: mimeType, data: encoded });
    }
  }

  let messageBody = '';
  if (attachments.length === 0) {
    headerLines.push('Content-Type: text/plain; charset="UTF-8"');
    headerLines.push('Content-Transfer-Encoding: 7bit');
    messageBody = headerLines.join('
') + '

' + body;
  } else {
    const boundary = 'apps-script-gmail-' + Utilities.getUuid();
    headerLines.push('Content-Type: multipart/mixed; boundary="' + boundary + '"');
    const parts = [];
    parts.push('--' + boundary);
    parts.push('Content-Type: text/plain; charset="UTF-8"');
    parts.push('Content-Transfer-Encoding: 7bit');
    parts.push('');
    parts.push(body);
    parts.push('');
    for (let a = 0; a < attachments.length; a++) {
      const attachment = attachments[a];
      parts.push('--' + boundary);
      parts.push('Content-Type: ' + attachment.mimeType);
      parts.push('Content-Disposition: attachment; filename="' + attachment.filename.replace(/"/g, '\"') + '"');
      parts.push('Content-Transfer-Encoding: base64');
      parts.push('');
      parts.push(attachment.data);
      parts.push('');
    }
    parts.push('--' + boundary + '--');
    messageBody = headerLines.join('
') + '

' + parts.join('
');
  }

  const raw = Utilities.base64EncodeWebSafe(messageBody);

  try {
    const response = rateLimitAware(
      () => fetchJson({
        url: 'https://gmail.googleapis.com/gmail/v1/users/me/messages/send',
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + accessToken,
          'Content-Type': 'application/json'
        },
        payload: JSON.stringify({ raw: raw })
      }),
      { attempts: 5, backoffMs: 500 }
    );

    const responseBody = response.body || {};
    ctx.messageId = responseBody.id || ctx.messageId || null;
    ctx.gmailMessageId = responseBody.id || null;
    ctx.gmailThreadId = responseBody.threadId || null;
    ctx.gmailLabelIds = Array.isArray(responseBody.labelIds) ? responseBody.labelIds : [];
    ctx.gmailSendEmailResponse = responseBody;

    logInfo('gmail_send_email_success', {
      messageId: ctx.gmailMessageId || null,
      threadId: ctx.gmailThreadId || null,
      toCount: recipients.length,
      ccCount: ccList.length,
      bccCount: bccList.length,
      attachments: attachments.length
    });

    return ctx;
  } catch (error) {
    const providerCode = error && error.body && error.body.error ? (error.body.error.status || error.body.error.code || null) : null;
    const providerMessage = error && error.body && error.body.error ? error.body.error.message : null;
    const status = error && typeof error.status === 'number' ? error.status : null;
    const message = providerMessage || (error && error.message ? error.message : String(error));
    logError('gmail_send_email_failed', {
      operation: 'action.gmail:send_email',
      status: status,
      providerCode: providerCode,
      message: message
    });
    throw new Error('Gmail send_email failed: ' + (providerCode ? providerCode + ' ' : '') + message);
  }
}
`;

exports[`Apps Script Gmail REAL_OPS builds action.gmail:search_emails 1`] = `

function step_action_gmail_search_emails(ctx) {
  ctx = ctx || {};
  const accessToken = getSecret('GMAIL_ACCESS_TOKEN', { connectorKey: 'gmail' });
  if (!accessToken) {
    logError('gmail_missing_access_token', { operation: 'action.gmail:search_emails' });
    throw new Error('Missing Gmail access token for gmail.search_emails operation');
  }

  const query = interpolate('label:inbox', ctx).trim();
  if (!query) {
    logError('gmail_search_emails_missing_param', { field: 'query' });
    throw new Error('Missing required Gmail search_emails param: query');
  }

  const rawMaxResults = interpolate('', ctx).trim();
  let maxResults = rawMaxResults ? Number(rawMaxResults) : 10;
  if (isNaN(maxResults) || maxResults <= 0) {
    maxResults = 10;
  }
  maxResults = Math.max(1, Math.min(500, Math.floor(maxResults)));

  const includeSpamRaw = interpolate('false', ctx)
    .trim()
    .toLowerCase();
  const includeSpamTrash = includeSpamRaw
    ? includeSpamRaw === 'true' || includeSpamRaw === '1'
    : false;

  const pageToken = ctx.nextPageToken || ctx.gmailNextPageToken || null;
  const params = ['maxResults=' + maxResults, 'q=' + encodeURIComponent(query)];
  if (includeSpamTrash) {
    params.push('includeSpamTrash=true');
  }
  if (pageToken) {
    params.push('pageToken=' + encodeURIComponent(pageToken));
  }

  try {
    const response = rateLimitAware(
      () => fetchJson({
        url: 'https://gmail.googleapis.com/gmail/v1/users/me/messages?' + params.join('&'),
        method: 'GET',
        headers: { Authorization: 'Bearer ' + accessToken }
      }),
      { attempts: 5, backoffMs: 500 }
    );

    const body = response.body || {};
    ctx.gmailMessages = Array.isArray(body.messages) ? body.messages : [];
    ctx.gmailNextPageToken = body.nextPageToken || null;
    ctx.nextPageToken = ctx.gmailNextPageToken;
    ctx.resultSizeEstimate = typeof body.resultSizeEstimate === 'number' ? body.resultSizeEstimate : null;
    ctx.gmailQuery = query;
    ctx.gmailIncludeSpamTrash = includeSpamTrash;
    ctx.gmailSearchResponse = body;

    logInfo('gmail_search_emails_success', {
      query: query,
      returned: ctx.gmailMessages.length,
      includeSpamTrash: includeSpamTrash,
      hasNextPage: Boolean(ctx.gmailNextPageToken)
    });

    return ctx;
  } catch (error) {
    const providerCode = error && error.body && error.body.error ? (error.body.error.status || error.body.error.code || null) : null;
    const providerMessage = error && error.body && error.body.error ? error.body.error.message : null;
    const status = error && typeof error.status === 'number' ? error.status : null;
    const message = providerMessage || (error && error.message ? error.message : String(error));
    logError('gmail_search_emails_failed', {
      operation: 'action.gmail:search_emails',
      status: status,
      providerCode: providerCode,
      message: message
    });
    throw new Error('Gmail search_emails failed: ' + (providerCode ? providerCode + ' ' : '') + message);
  }
}
`;

exports[`Apps Script Gmail REAL_OPS builds action.gmail:mark_as_read 1`] = `

function step_action_gmail_mark_as_read(ctx) {
  ctx = ctx || {};
  const accessToken = getSecret('GMAIL_ACCESS_TOKEN', { connectorKey: 'gmail' });
  if (!accessToken) {
    logError('gmail_missing_access_token', { operation: 'action.gmail:mark_as_read' });
    throw new Error('Missing Gmail access token for gmail.mark_as_read operation');
  }

  const idsConfig = ["id-1","id-2"];
  const messageIds = [];
  if (Array.isArray(idsConfig)) {
    for (let i = 0; i < idsConfig.length; i++) {
      const value = typeof idsConfig[i] === 'string' ? interpolate(idsConfig[i], ctx).trim() : '';
      if (value) {
        messageIds.push(value);
      }
    }
  }

  if (!messageIds.length) {
    logError('gmail_mark_as_read_missing_param', { field: 'messageIds' });
    throw new Error('Missing required Gmail mark_as_read param: messageIds');
  }

  try {
    rateLimitAware(
      () => fetchJson({
        url: 'https://gmail.googleapis.com/gmail/v1/users/me/messages/batchModify',
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + accessToken,
          'Content-Type': 'application/json'
        },
        payload: JSON.stringify({ ids: messageIds, removeLabelIds: ['UNREAD'] })
      }),
      { attempts: 4, backoffMs: 500 }
    );

    ctx.gmailModifiedIds = messageIds;
    logInfo('gmail_mark_as_read_success', { count: messageIds.length });
    return ctx;
  } catch (error) {
    const providerCode = error && error.body && error.body.error ? (error.body.error.status || error.body.error.code || null) : null;
    const providerMessage = error && error.body && error.body.error ? error.body.error.message : null;
    const status = error && typeof error.status === 'number' ? error.status : null;
    const message = providerMessage || (error && error.message ? error.message : String(error));
    logError('gmail_mark_as_read_failed', {
      operation: 'action.gmail:mark_as_read',
      status: status,
      providerCode: providerCode,
      message: message
    });
    throw new Error('Gmail mark_as_read failed: ' + (providerCode ? providerCode + ' ' : '') + message);
  }
}
`;

exports[`Apps Script Gmail REAL_OPS builds action.gmail:add_label 1`] = `

function step_action_gmail_add_label(ctx) {
  ctx = ctx || {};
  const accessToken = getSecret('GMAIL_ACCESS_TOKEN', { connectorKey: 'gmail' });
  if (!accessToken) {
    logError('gmail_missing_access_token', { operation: 'action.gmail:add_label' });
    throw new Error('Missing Gmail access token for gmail.add_label operation');
  }

  const idsConfig = ["id-9"];
  const labelConfig = ["IMPORTANT"];
  const messageIds = [];
  if (Array.isArray(idsConfig)) {
    for (let i = 0; i < idsConfig.length; i++) {
      const value = typeof idsConfig[i] === 'string' ? interpolate(idsConfig[i], ctx).trim() : '';
      if (value) {
        messageIds.push(value);
      }
    }
  }

  const labelIds = [];
  if (Array.isArray(labelConfig)) {
    for (let j = 0; j < labelConfig.length; j++) {
      const value = typeof labelConfig[j] === 'string' ? interpolate(labelConfig[j], ctx).trim() : '';
      if (value) {
        labelIds.push(value);
      }
    }
  }

  if (!messageIds.length) {
    logError('gmail_add_label_missing_param', { field: 'messageIds' });
    throw new Error('Missing required Gmail add_label param: messageIds');
  }

  if (!labelIds.length) {
    logError('gmail_add_label_missing_param', { field: 'labelIds' });
    throw new Error('Missing required Gmail add_label param: labelIds');
  }

  try {
    rateLimitAware(
      () => fetchJson({
        url: 'https://gmail.googleapis.com/gmail/v1/users/me/messages/batchModify',
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + accessToken,
          'Content-Type': 'application/json'
        },
        payload: JSON.stringify({ ids: messageIds, addLabelIds: labelIds })
      }),
      { attempts: 4, backoffMs: 500 }
    );

    ctx.gmailModifiedIds = messageIds;
    ctx.gmailAppliedLabelIds = labelIds;
    logInfo('gmail_add_label_success', {
      messageCount: messageIds.length,
      labelCount: labelIds.length
    });

    return ctx;
  } catch (error) {
    const providerCode = error && error.body && error.body.error ? (error.body.error.status || error.body.error.code || null) : null;
    const providerMessage = error && error.body && error.body.error ? error.body.error.message : null;
    const status = error && typeof error.status === 'number' ? error.status : null;
    const message = providerMessage || (error && error.message ? error.message : String(error));
    logError('gmail_add_label_failed', {
      operation: 'action.gmail:add_label',
      status: status,
      providerCode: providerCode,
      message: message
    });
    throw new Error('Gmail add_label failed: ' + (providerCode ? providerCode + ' ' : '') + message);
  }
}
`;

exports[`Apps Script Gmail REAL_OPS builds action.gmail:send_reply 1`] = `

function step_action_gmail_send_reply(ctx) {
  ctx = ctx || {};
  const accessToken = getSecret('GMAIL_ACCESS_TOKEN', { connectorKey: 'gmail' });
  if (!accessToken) {
    logError('gmail_missing_access_token', { operation: 'action.gmail:send_reply' });
    throw new Error('Missing Gmail access token for gmail.send_reply operation');
  }

  const messageId = interpolate('abc123', ctx).trim();
  if (!messageId) {
    logError('gmail_send_reply_missing_param', { field: 'messageId' });
    throw new Error('Missing required Gmail send_reply param: messageId');
  }

  const bodyTemplate = 'Thanks!';
  const replyBody = interpolate(bodyTemplate, ctx);
  if (!replyBody) {
    logError('gmail_send_reply_missing_param', { field: 'body' });
    throw new Error('Missing required Gmail send_reply param: body');
  }

  let replyAll = true;
  const replyAllTemplate = 'true';
  if (replyAllTemplate) {
    const normalized = replyAllTemplate.trim().toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') {
      replyAll = true;
    } else if (normalized === 'false' || normalized === '0' || normalized === 'no') {
      replyAll = false;
    }
  }

  function parseAddressList(value) {
    if (!value) {
      return [];
    }
    return value.split(',').map(function (entry) { return entry.trim(); }).filter(Boolean);
  }

  function extractHeader(all, name) {
    if (!Array.isArray(all)) {
      return '';
    }
    const target = name.toLowerCase();
    for (let i = 0; i < all.length; i++) {
      const header = all[i];
      if (!header || typeof header.name !== 'string') {
        continue;
      }
      if (header.name.toLowerCase() === target) {
        return header.value || '';
      }
    }
    return '';
  }

  try {
    const messageResponse = rateLimitAware(
      () => fetchJson({
        url: 'https://gmail.googleapis.com/gmail/v1/users/me/messages/' + encodeURIComponent(messageId) + '?format=full',
        method: 'GET',
        headers: { Authorization: 'Bearer ' + accessToken }
      }),
      { attempts: 5, backoffMs: 500 }
    );

    const message = messageResponse.body || {};
    const payload = message.payload || {};
    const headersList = payload.headers || [];

    const fromHeader = extractHeader(headersList, 'From');
    const replyToHeader = extractHeader(headersList, 'Reply-To');
    const toHeader = parseAddressList(extractHeader(headersList, 'To'));
    const ccHeader = parseAddressList(extractHeader(headersList, 'Cc'));

    const baseReplyTo = parseAddressList(replyToHeader);
    const baseRecipients = baseReplyTo.length ? baseReplyTo : parseAddressList(fromHeader);
    const toRecipients = [];
    const ccRecipients = [];
    const seen = {};

    function pushUnique(target, value) {
      const key = value ? value.toLowerCase() : '';
      if (!key || Object.prototype.hasOwnProperty.call(seen, key)) {
        return;
      }
      seen[key] = true;
      target.push(value);
    }

    for (let i = 0; i < baseRecipients.length; i++) {
      pushUnique(toRecipients, baseRecipients[i]);
    }

    if (replyAll) {
      for (let i = 0; i < toHeader.length; i++) {
        pushUnique(toRecipients, toHeader[i]);
      }
      for (let i = 0; i < ccHeader.length; i++) {
        pushUnique(ccRecipients, ccHeader[i]);
      }
    }

    if (!toRecipients.length) {
      logError('gmail_send_reply_unresolved_recipient', { messageId: messageId });
      throw new Error('Unable to resolve reply recipients for Gmail send_reply operation');
    }

    const messageIdHeader = extractHeader(headersList, 'Message-ID') || ('<' + messageId + '>');
    const referencesHeader = extractHeader(headersList, 'References');
    const references = referencesHeader ? referencesHeader + ' ' + messageIdHeader : messageIdHeader;

    const originalSubject = extractHeader(headersList, 'Subject') || '';
    let subject = originalSubject;
    if (!subject) {
      subject = 'Re:';
    } else if (!/^s*re:/i.test(subject)) {
      subject = 'Re: ' + subject;
    }

    const headerLines = ['To: ' + toRecipients.join(', ')];
    if (ccRecipients.length) {
      headerLines.push('Cc: ' + ccRecipients.join(', '));
    }
    headerLines.push('Subject: ' + subject);
    headerLines.push('In-Reply-To: ' + messageIdHeader);
    headerLines.push('References: ' + references);
    headerLines.push('MIME-Version: 1.0');
    headerLines.push('Content-Type: text/plain; charset="UTF-8"');
    headerLines.push('Content-Transfer-Encoding: 7bit');

    const messageBody = headerLines.join('
') + '

' + replyBody;
    const raw = Utilities.base64EncodeWebSafe(Utilities.newBlob(messageBody).getBytes()).replace(/=+$/, '');

    const requestBody = { raw: raw };
    if (message.threadId) {
      requestBody.threadId = message.threadId;
    }

    const sendResponse = rateLimitAware(
      () => fetchJson({
        url: 'https://gmail.googleapis.com/gmail/v1/users/me/messages/send',
        method: 'POST',
        headers: {
          'Authorization': 'Bearer ' + accessToken,
          'Content-Type': 'application/json'
        },
        payload: JSON.stringify(requestBody)
      }),
      { attempts: 5, backoffMs: 500 }
    );

    const responseBody = sendResponse.body || {};
    ctx.gmailMessageId = responseBody.id || ctx.gmailMessageId || null;
    ctx.gmailThreadId = responseBody.threadId || message.threadId || null;
    ctx.gmailLabelIds = Array.isArray(responseBody.labelIds) ? responseBody.labelIds : [];
    ctx.gmailSendReplyResponse = responseBody;
    ctx.gmailReplyRecipients = toRecipients;
    ctx.gmailReplyCc = ccRecipients;

    logInfo('gmail_send_reply_success', {
      messageId: ctx.gmailMessageId || null,
      threadId: ctx.gmailThreadId || null,
      replyAll: replyAll,
      toCount: toRecipients.length,
      ccCount: ccRecipients.length
    });

    return ctx;
  } catch (error) {
    const providerCode = error && error.body && error.body.error ? (error.body.error.status || error.body.error.code || null) : null;
    const providerMessage = error && error.body && error.body.error ? error.body.error.message : null;
    const status = error && typeof error.status === 'number' ? error.status : null;
    const message = providerMessage || (error && error.message ? error.message : String(error));
    logError('gmail_send_reply_failed', {
      operation: 'action.gmail:send_reply',
      status: status,
      providerCode: providerCode,
      message: message
    });
    throw new Error('Gmail send_reply failed: ' + (providerCode ? providerCode + ' ' : '') + message);
  }
}
`;

