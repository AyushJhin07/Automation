exports[`Apps Script Trello Enhanced REAL_OPS builds action.trello-enhanced:create_board 1`] = `
function step_action_trello_enhanced_create_board(ctx) {
  ctx = ctx || {};
  const config = {"name":"Growth Launchpad","desc":"Program board for the {{fiscal_quarter}} expansion roadmap.","idOrganization":"{{org_id}}","prefs_permissionLevel":"org","prefs_voting":"members","prefs_comments":"observers","prefs_background":"blue"};
  const operationKey = 'create_board';
  const apiKey = getSecret('TRELLO_API_KEY', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__api_key', 'apps_script__trello_enhanced__api_key'] });
  const token = getSecret('TRELLO_TOKEN', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__token', 'apps_script__trello_enhanced__token'] });

  if (!apiKey || !token) {
    logWarn('trello_enhanced_missing_credentials', { operation: operationKey });
    throw new Error('Trello Enhanced ' + operationKey + ' requires TRELLO_API_KEY and TRELLO_TOKEN script properties.');
  }

  const rateConfig = { attempts: 5, initialDelayMs: 700, maxDelayMs: 7000, jitter: 0.25 };

  function resolveOptionalString(template, options) {
    options = options || {};
    if (template === undefined || template === null) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return '';
    }

    if (typeof template !== 'string') {
      template = String(template);
    }

    const trimmed = template.trim();
    if (!trimmed) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return options.allowEmpty ? '' : '';
    }

    const resolved = options.skipTrim ? interpolate(trimmed, ctx) : interpolate(trimmed, ctx).trim();
    if (!resolved) {
      if (options.fallbackSecret) {
        try {
          const secret = getSecret(options.fallbackSecret, { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello_enhanced__webhook_callback_url', 'apps_script__trello__webhook_callback_url'] });
          if (secret) {
            return String(secret).trim();
          }
        } catch (error) {
          // Ignore missing fallback secret
        }
      }

      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }

      return options.allowEmpty ? '' : '';
    }

    return options.skipTrim ? resolved : resolved.trim();
  }

  function resolveRequiredString(value, message, options) {
    const resolved = resolveOptionalString(value, options);
    if (!resolved) {
      throw new Error(message);
    }
    return resolved;
  }

  function resolveCommaSeparated(value) {
    if (value === undefined || value === null) {
      return '';
    }
    if (Array.isArray(value)) {
      const parts = [];
      for (let i = 0; i < value.length; i++) {
        const entry = resolveOptionalString(value[i], { allowEmpty: true });
        if (entry) {
          parts.push(entry);
        }
      }
      return parts.join(',');
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return '';
    }
    const items = resolved.split(',').map(part => part.trim()).filter(Boolean);
    return items.join(',');
  }

  function resolveBoolean(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return !!defaultValue;
    }
    if (typeof value === 'boolean') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return !!defaultValue;
    }
    const normalized = resolved.toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') {
      return true;
    }
    if (normalized === 'false' || normalized === '0' || normalized === 'no') {
      return false;
    }
    return !!defaultValue;
  }

  function resolveNumber(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    if (typeof value === 'number') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    const numeric = Number(resolved);
    if (isNaN(numeric)) {
      throw new Error('Expected a numeric value but received "' + resolved + '".');
    }
    return numeric;
  }

  function buildQuery(params) {
    const parts = [];
    for (const key in params) {
      if (!Object.prototype.hasOwnProperty.call(params, key)) {
        continue;
      }
      const value = params[key];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const entry = value[i];
          if (entry === undefined || entry === null || entry === '') {
            continue;
          }
          parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(entry)));
        }
        continue;
      }
      const stringValue = String(value);
      if (!stringValue && stringValue !== '0') {
        continue;
      }
      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(stringValue));
    }
    return parts.join('&');
  }

  function callTrello(path, options) {
    options = options || {};
    const query = options.query ? Object.assign({}, options.query) : {};
    query.key = apiKey;
    query.token = token;
    const queryString = buildQuery(query);
    const url = 'https://api.trello.com/1' + path + (queryString ? '?' + queryString : '');
    const request = {
      url: url,
      method: options.method || 'GET',
      headers: options.headers || {},
      payload: options.payload,
      contentType: options.contentType,
      muteHttpExceptions: true,
    };
    return rateLimitAware(() => fetchJson(request), rateConfig);
  }

  function handleTrelloEnhancedError(error, metadata) {
    metadata = metadata || {};
    const status = error && typeof error.status === 'number' ? error.status : null;
    const payload = error && Object.prototype.hasOwnProperty.call(error, 'body') ? error.body : null;
    const details = [];
    if (metadata.boardId) {
      details.push('board ' + metadata.boardId);
    }
    if (metadata.listId) {
      details.push('list ' + metadata.listId);
    }
    if (metadata.cardId) {
      details.push('card ' + metadata.cardId);
    }
    if (metadata.modelId) {
      details.push('model ' + metadata.modelId);
    }
    if (status) {
      details.push('status ' + status);
    }
    if (payload && typeof payload === 'object') {
      if (payload.message) {
        details.push(String(payload.message));
      }
      if (payload.error) {
        details.push(String(payload.error));
      }
    }
    const context = details.length ? ' (' + details.join('; ') + ')' : '';
    const message = 'Trello Enhanced ' + (metadata.operation || operationKey) + ' failed' + context + '.';
    const wrapped = new Error(message);
    if (status !== null) {
      wrapped.status = status;
    }
    if (payload !== undefined) {
      wrapped.body = payload;
    }
    wrapped.cause = error;
    throw wrapped;
  }

  const boardName = resolveRequiredString(config && config.name, 'Trello Enhanced create_board requires a board name.');
  const boardDescription = resolveOptionalString(config && config.desc, { allowEmpty: true });
  const organizationId = resolveOptionalString(config && (config.idOrganization || config.organizationId), { allowEmpty: true });
  const permissionLevel = resolveOptionalString(config && (config.prefs_permissionLevel || config.permissionLevel), { allowEmpty: true, defaultValue: 'private' }) || 'private';
  const votingLevel = resolveOptionalString(config && config.prefs_voting, { allowEmpty: true, defaultValue: 'disabled' }) || 'disabled';
  const commentLevel = resolveOptionalString(config && config.prefs_comments, { allowEmpty: true, defaultValue: 'members' }) || 'members';
  const background = resolveOptionalString(config && config.prefs_background, { allowEmpty: true });
  try {
    const response = callTrello('/boards', {
      method: 'POST',
      query: {
        name: boardName,
        desc: boardDescription || undefined,
        idOrganization: organizationId || undefined,
        prefs_permissionLevel: permissionLevel || undefined,
        prefs_voting: votingLevel || undefined,
        prefs_comments: commentLevel || undefined,
        prefs_background: background || undefined
      }
    });
    const board = response.body || {};
    const boardId = board.id || null;
    ctx.trelloEnhancedBoard = board;
    ctx.trelloEnhancedBoardId = boardId;
    if (!ctx.boardId && boardId) {
      ctx.boardId = boardId;
    }
    logInfo('trello_enhanced_create_board_success', { boardId: boardId });
    return ctx;
  } catch (error) {
    handleTrelloEnhancedError(error, { operation: 'create_board' });
  }
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds action.trello-enhanced:create_card 1`] = `
function step_action_trello_enhanced_create_card(ctx) {
  ctx = ctx || {};
  const config = {"idList":"{{list_id}}","name":"Draft launch announcement","desc":"Coordinate copy review and legal approval.","pos":"bottom","due":"{{due_at}}","dueComplete":false,"idMembers":["{{comms_owner}}","6430a62bca1efc1a9b456700"],"idLabels":"launch,{{priority_label}}","idChecklists":["{{qa_checklist}}"],"address":"135 Townsend St, San Francisco, CA 94107","locationName":"Headquarters","coordinates":"37.781,-122.396"};
  const operationKey = 'create_card';
  const apiKey = getSecret('TRELLO_API_KEY', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__api_key', 'apps_script__trello_enhanced__api_key'] });
  const token = getSecret('TRELLO_TOKEN', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__token', 'apps_script__trello_enhanced__token'] });

  if (!apiKey || !token) {
    logWarn('trello_enhanced_missing_credentials', { operation: operationKey });
    throw new Error('Trello Enhanced ' + operationKey + ' requires TRELLO_API_KEY and TRELLO_TOKEN script properties.');
  }

  const rateConfig = { attempts: 5, initialDelayMs: 700, maxDelayMs: 7000, jitter: 0.25 };

  function resolveOptionalString(template, options) {
    options = options || {};
    if (template === undefined || template === null) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return '';
    }

    if (typeof template !== 'string') {
      template = String(template);
    }

    const trimmed = template.trim();
    if (!trimmed) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return options.allowEmpty ? '' : '';
    }

    const resolved = options.skipTrim ? interpolate(trimmed, ctx) : interpolate(trimmed, ctx).trim();
    if (!resolved) {
      if (options.fallbackSecret) {
        try {
          const secret = getSecret(options.fallbackSecret, { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello_enhanced__webhook_callback_url', 'apps_script__trello__webhook_callback_url'] });
          if (secret) {
            return String(secret).trim();
          }
        } catch (error) {
          // Ignore missing fallback secret
        }
      }

      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }

      return options.allowEmpty ? '' : '';
    }

    return options.skipTrim ? resolved : resolved.trim();
  }

  function resolveRequiredString(value, message, options) {
    const resolved = resolveOptionalString(value, options);
    if (!resolved) {
      throw new Error(message);
    }
    return resolved;
  }

  function resolveCommaSeparated(value) {
    if (value === undefined || value === null) {
      return '';
    }
    if (Array.isArray(value)) {
      const parts = [];
      for (let i = 0; i < value.length; i++) {
        const entry = resolveOptionalString(value[i], { allowEmpty: true });
        if (entry) {
          parts.push(entry);
        }
      }
      return parts.join(',');
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return '';
    }
    const items = resolved.split(',').map(part => part.trim()).filter(Boolean);
    return items.join(',');
  }

  function resolveBoolean(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return !!defaultValue;
    }
    if (typeof value === 'boolean') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return !!defaultValue;
    }
    const normalized = resolved.toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') {
      return true;
    }
    if (normalized === 'false' || normalized === '0' || normalized === 'no') {
      return false;
    }
    return !!defaultValue;
  }

  function resolveNumber(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    if (typeof value === 'number') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    const numeric = Number(resolved);
    if (isNaN(numeric)) {
      throw new Error('Expected a numeric value but received "' + resolved + '".');
    }
    return numeric;
  }

  function buildQuery(params) {
    const parts = [];
    for (const key in params) {
      if (!Object.prototype.hasOwnProperty.call(params, key)) {
        continue;
      }
      const value = params[key];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const entry = value[i];
          if (entry === undefined || entry === null || entry === '') {
            continue;
          }
          parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(entry)));
        }
        continue;
      }
      const stringValue = String(value);
      if (!stringValue && stringValue !== '0') {
        continue;
      }
      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(stringValue));
    }
    return parts.join('&');
  }

  function callTrello(path, options) {
    options = options || {};
    const query = options.query ? Object.assign({}, options.query) : {};
    query.key = apiKey;
    query.token = token;
    const queryString = buildQuery(query);
    const url = 'https://api.trello.com/1' + path + (queryString ? '?' + queryString : '');
    const request = {
      url: url,
      method: options.method || 'GET',
      headers: options.headers || {},
      payload: options.payload,
      contentType: options.contentType,
      muteHttpExceptions: true,
    };
    return rateLimitAware(() => fetchJson(request), rateConfig);
  }

  function handleTrelloEnhancedError(error, metadata) {
    metadata = metadata || {};
    const status = error && typeof error.status === 'number' ? error.status : null;
    const payload = error && Object.prototype.hasOwnProperty.call(error, 'body') ? error.body : null;
    const details = [];
    if (metadata.boardId) {
      details.push('board ' + metadata.boardId);
    }
    if (metadata.listId) {
      details.push('list ' + metadata.listId);
    }
    if (metadata.cardId) {
      details.push('card ' + metadata.cardId);
    }
    if (metadata.modelId) {
      details.push('model ' + metadata.modelId);
    }
    if (status) {
      details.push('status ' + status);
    }
    if (payload && typeof payload === 'object') {
      if (payload.message) {
        details.push(String(payload.message));
      }
      if (payload.error) {
        details.push(String(payload.error));
      }
    }
    const context = details.length ? ' (' + details.join('; ') + ')' : '';
    const message = 'Trello Enhanced ' + (metadata.operation || operationKey) + ' failed' + context + '.';
    const wrapped = new Error(message);
    if (status !== null) {
      wrapped.status = status;
    }
    if (payload !== undefined) {
      wrapped.body = payload;
    }
    wrapped.cause = error;
    throw wrapped;
  }

  let listId = resolveOptionalString(config && (config.idList || config.list_id || config.listId), { allowEmpty: true });
  if (!listId && ctx.listId) {
    listId = String(ctx.listId);
  }
  if (!listId && ctx.trelloListId) {
    listId = String(ctx.trelloListId);
  }
  if (!listId) {
    throw new Error('Trello Enhanced create_card requires a list ID. Configure the List field or provide a template that resolves to a Trello list identifier.');
  }
  const cardName = resolveRequiredString(config && config.name, 'Trello Enhanced create_card requires a card name.');
  const cardDescription = resolveOptionalString(config && (config.desc || config.description), { allowEmpty: true });
  const cardPosition = resolveOptionalString(config && config.pos, { allowEmpty: true });
  const dueDate = resolveOptionalString(config && config.due, { allowEmpty: true });
  const dueComplete = resolveBoolean(config && config.dueComplete, false);
  const memberIds = resolveCommaSeparated(config && config.idMembers);
  const labelIds = resolveCommaSeparated(config && config.idLabels);
  const checklistIds = resolveCommaSeparated(config && config.idChecklists);
  const cardAddress = resolveOptionalString(config && config.address, { allowEmpty: true });
  const locationName = resolveOptionalString(config && config.locationName, { allowEmpty: true });
  const coordinates = resolveOptionalString(config && config.coordinates, { allowEmpty: true });
  try {
    const response = callTrello('/cards', {
      method: 'POST',
      query: {
        idList: listId,
        name: cardName,
        desc: cardDescription || undefined,
        pos: cardPosition || undefined,
        due: dueDate || undefined,
        dueComplete: dueComplete,
        idMembers: memberIds || undefined,
        idLabels: labelIds || undefined,
        idChecklists: checklistIds || undefined,
        address: cardAddress || undefined,
        locationName: locationName || undefined,
        coordinates: coordinates || undefined
      }
    });
    const card = response.body || {};
    const cardId = card.id || null;
    ctx.trelloEnhancedCard = card;
    ctx.trelloEnhancedCardId = cardId;
    if (!ctx.cardId && cardId) {
      ctx.cardId = cardId;
    }
    if (!ctx.cardUrl && card && card.shortUrl) {
      ctx.cardUrl = card.shortUrl;
    }
    logInfo('trello_enhanced_create_card_success', { cardId: cardId, listId: listId });
    return ctx;
  } catch (error) {
    handleTrelloEnhancedError(error, { operation: 'create_card', listId: listId });
  }
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds action.trello-enhanced:create_checklist 1`] = `
function step_action_trello_enhanced_create_checklist(ctx) {
  ctx = ctx || {};
  const config = {"idCard":"{{card_id}}","name":"Launch prerequisites","pos":"top"};
  const operationKey = 'create_checklist';
  const apiKey = getSecret('TRELLO_API_KEY', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__api_key', 'apps_script__trello_enhanced__api_key'] });
  const token = getSecret('TRELLO_TOKEN', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__token', 'apps_script__trello_enhanced__token'] });

  if (!apiKey || !token) {
    logWarn('trello_enhanced_missing_credentials', { operation: operationKey });
    throw new Error('Trello Enhanced ' + operationKey + ' requires TRELLO_API_KEY and TRELLO_TOKEN script properties.');
  }

  const rateConfig = { attempts: 5, initialDelayMs: 700, maxDelayMs: 7000, jitter: 0.25 };

  function resolveOptionalString(template, options) {
    options = options || {};
    if (template === undefined || template === null) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return '';
    }

    if (typeof template !== 'string') {
      template = String(template);
    }

    const trimmed = template.trim();
    if (!trimmed) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return options.allowEmpty ? '' : '';
    }

    const resolved = options.skipTrim ? interpolate(trimmed, ctx) : interpolate(trimmed, ctx).trim();
    if (!resolved) {
      if (options.fallbackSecret) {
        try {
          const secret = getSecret(options.fallbackSecret, { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello_enhanced__webhook_callback_url', 'apps_script__trello__webhook_callback_url'] });
          if (secret) {
            return String(secret).trim();
          }
        } catch (error) {
          // Ignore missing fallback secret
        }
      }

      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }

      return options.allowEmpty ? '' : '';
    }

    return options.skipTrim ? resolved : resolved.trim();
  }

  function resolveRequiredString(value, message, options) {
    const resolved = resolveOptionalString(value, options);
    if (!resolved) {
      throw new Error(message);
    }
    return resolved;
  }

  function resolveCommaSeparated(value) {
    if (value === undefined || value === null) {
      return '';
    }
    if (Array.isArray(value)) {
      const parts = [];
      for (let i = 0; i < value.length; i++) {
        const entry = resolveOptionalString(value[i], { allowEmpty: true });
        if (entry) {
          parts.push(entry);
        }
      }
      return parts.join(',');
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return '';
    }
    const items = resolved.split(',').map(part => part.trim()).filter(Boolean);
    return items.join(',');
  }

  function resolveBoolean(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return !!defaultValue;
    }
    if (typeof value === 'boolean') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return !!defaultValue;
    }
    const normalized = resolved.toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') {
      return true;
    }
    if (normalized === 'false' || normalized === '0' || normalized === 'no') {
      return false;
    }
    return !!defaultValue;
  }

  function resolveNumber(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    if (typeof value === 'number') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    const numeric = Number(resolved);
    if (isNaN(numeric)) {
      throw new Error('Expected a numeric value but received "' + resolved + '".');
    }
    return numeric;
  }

  function buildQuery(params) {
    const parts = [];
    for (const key in params) {
      if (!Object.prototype.hasOwnProperty.call(params, key)) {
        continue;
      }
      const value = params[key];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const entry = value[i];
          if (entry === undefined || entry === null || entry === '') {
            continue;
          }
          parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(entry)));
        }
        continue;
      }
      const stringValue = String(value);
      if (!stringValue && stringValue !== '0') {
        continue;
      }
      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(stringValue));
    }
    return parts.join('&');
  }

  function callTrello(path, options) {
    options = options || {};
    const query = options.query ? Object.assign({}, options.query) : {};
    query.key = apiKey;
    query.token = token;
    const queryString = buildQuery(query);
    const url = 'https://api.trello.com/1' + path + (queryString ? '?' + queryString : '');
    const request = {
      url: url,
      method: options.method || 'GET',
      headers: options.headers || {},
      payload: options.payload,
      contentType: options.contentType,
      muteHttpExceptions: true,
    };
    return rateLimitAware(() => fetchJson(request), rateConfig);
  }

  function handleTrelloEnhancedError(error, metadata) {
    metadata = metadata || {};
    const status = error && typeof error.status === 'number' ? error.status : null;
    const payload = error && Object.prototype.hasOwnProperty.call(error, 'body') ? error.body : null;
    const details = [];
    if (metadata.boardId) {
      details.push('board ' + metadata.boardId);
    }
    if (metadata.listId) {
      details.push('list ' + metadata.listId);
    }
    if (metadata.cardId) {
      details.push('card ' + metadata.cardId);
    }
    if (metadata.modelId) {
      details.push('model ' + metadata.modelId);
    }
    if (status) {
      details.push('status ' + status);
    }
    if (payload && typeof payload === 'object') {
      if (payload.message) {
        details.push(String(payload.message));
      }
      if (payload.error) {
        details.push(String(payload.error));
      }
    }
    const context = details.length ? ' (' + details.join('; ') + ')' : '';
    const message = 'Trello Enhanced ' + (metadata.operation || operationKey) + ' failed' + context + '.';
    const wrapped = new Error(message);
    if (status !== null) {
      wrapped.status = status;
    }
    if (payload !== undefined) {
      wrapped.body = payload;
    }
    wrapped.cause = error;
    throw wrapped;
  }

  const cardId = resolveRequiredString(config && (config.idCard || config.cardId), 'Trello Enhanced create_checklist requires a card ID.');
  const checklistName = resolveRequiredString(config && config.name, 'Trello Enhanced create_checklist requires a checklist name.');
  const checklistPosition = resolveOptionalString(config && config.pos, { allowEmpty: true });
  try {
    const response = callTrello('/cards/' + encodeURIComponent(cardId) + '/checklists', {
      method: 'POST',
      query: {
        name: checklistName,
        pos: checklistPosition || undefined
      }
    });
    const checklist = response.body || {};
    const checklistId = checklist.id || null;
    ctx.trelloEnhancedChecklist = checklist;
    ctx.trelloEnhancedChecklistId = checklistId;
    logInfo('trello_enhanced_create_checklist_success', { cardId: cardId, checklistId: checklistId });
    return ctx;
  } catch (error) {
    handleTrelloEnhancedError(error, { operation: 'create_checklist', cardId: cardId });
  }
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds action.trello-enhanced:add_checklist_item 1`] = `
function step_action_trello_enhanced_add_checklist_item(ctx) {
  ctx = ctx || {};
  const config = {"idChecklist":"{{checklist_id}}","name":"Confirm translations approved","pos":"bottom","checked":true};
  const operationKey = 'add_checklist_item';
  const apiKey = getSecret('TRELLO_API_KEY', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__api_key', 'apps_script__trello_enhanced__api_key'] });
  const token = getSecret('TRELLO_TOKEN', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__token', 'apps_script__trello_enhanced__token'] });

  if (!apiKey || !token) {
    logWarn('trello_enhanced_missing_credentials', { operation: operationKey });
    throw new Error('Trello Enhanced ' + operationKey + ' requires TRELLO_API_KEY and TRELLO_TOKEN script properties.');
  }

  const rateConfig = { attempts: 5, initialDelayMs: 700, maxDelayMs: 7000, jitter: 0.25 };

  function resolveOptionalString(template, options) {
    options = options || {};
    if (template === undefined || template === null) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return '';
    }

    if (typeof template !== 'string') {
      template = String(template);
    }

    const trimmed = template.trim();
    if (!trimmed) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return options.allowEmpty ? '' : '';
    }

    const resolved = options.skipTrim ? interpolate(trimmed, ctx) : interpolate(trimmed, ctx).trim();
    if (!resolved) {
      if (options.fallbackSecret) {
        try {
          const secret = getSecret(options.fallbackSecret, { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello_enhanced__webhook_callback_url', 'apps_script__trello__webhook_callback_url'] });
          if (secret) {
            return String(secret).trim();
          }
        } catch (error) {
          // Ignore missing fallback secret
        }
      }

      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }

      return options.allowEmpty ? '' : '';
    }

    return options.skipTrim ? resolved : resolved.trim();
  }

  function resolveRequiredString(value, message, options) {
    const resolved = resolveOptionalString(value, options);
    if (!resolved) {
      throw new Error(message);
    }
    return resolved;
  }

  function resolveCommaSeparated(value) {
    if (value === undefined || value === null) {
      return '';
    }
    if (Array.isArray(value)) {
      const parts = [];
      for (let i = 0; i < value.length; i++) {
        const entry = resolveOptionalString(value[i], { allowEmpty: true });
        if (entry) {
          parts.push(entry);
        }
      }
      return parts.join(',');
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return '';
    }
    const items = resolved.split(',').map(part => part.trim()).filter(Boolean);
    return items.join(',');
  }

  function resolveBoolean(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return !!defaultValue;
    }
    if (typeof value === 'boolean') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return !!defaultValue;
    }
    const normalized = resolved.toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') {
      return true;
    }
    if (normalized === 'false' || normalized === '0' || normalized === 'no') {
      return false;
    }
    return !!defaultValue;
  }

  function resolveNumber(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    if (typeof value === 'number') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    const numeric = Number(resolved);
    if (isNaN(numeric)) {
      throw new Error('Expected a numeric value but received "' + resolved + '".');
    }
    return numeric;
  }

  function buildQuery(params) {
    const parts = [];
    for (const key in params) {
      if (!Object.prototype.hasOwnProperty.call(params, key)) {
        continue;
      }
      const value = params[key];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const entry = value[i];
          if (entry === undefined || entry === null || entry === '') {
            continue;
          }
          parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(entry)));
        }
        continue;
      }
      const stringValue = String(value);
      if (!stringValue && stringValue !== '0') {
        continue;
      }
      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(stringValue));
    }
    return parts.join('&');
  }

  function callTrello(path, options) {
    options = options || {};
    const query = options.query ? Object.assign({}, options.query) : {};
    query.key = apiKey;
    query.token = token;
    const queryString = buildQuery(query);
    const url = 'https://api.trello.com/1' + path + (queryString ? '?' + queryString : '');
    const request = {
      url: url,
      method: options.method || 'GET',
      headers: options.headers || {},
      payload: options.payload,
      contentType: options.contentType,
      muteHttpExceptions: true,
    };
    return rateLimitAware(() => fetchJson(request), rateConfig);
  }

  function handleTrelloEnhancedError(error, metadata) {
    metadata = metadata || {};
    const status = error && typeof error.status === 'number' ? error.status : null;
    const payload = error && Object.prototype.hasOwnProperty.call(error, 'body') ? error.body : null;
    const details = [];
    if (metadata.boardId) {
      details.push('board ' + metadata.boardId);
    }
    if (metadata.listId) {
      details.push('list ' + metadata.listId);
    }
    if (metadata.cardId) {
      details.push('card ' + metadata.cardId);
    }
    if (metadata.modelId) {
      details.push('model ' + metadata.modelId);
    }
    if (status) {
      details.push('status ' + status);
    }
    if (payload && typeof payload === 'object') {
      if (payload.message) {
        details.push(String(payload.message));
      }
      if (payload.error) {
        details.push(String(payload.error));
      }
    }
    const context = details.length ? ' (' + details.join('; ') + ')' : '';
    const message = 'Trello Enhanced ' + (metadata.operation || operationKey) + ' failed' + context + '.';
    const wrapped = new Error(message);
    if (status !== null) {
      wrapped.status = status;
    }
    if (payload !== undefined) {
      wrapped.body = payload;
    }
    wrapped.cause = error;
    throw wrapped;
  }

  const checklistId = resolveRequiredString(config && (config.idChecklist || config.checklistId), 'Trello Enhanced add_checklist_item requires a checklist ID.');
  const itemName = resolveRequiredString(config && config.name, 'Trello Enhanced add_checklist_item requires an item name.');
  const itemPosition = resolveOptionalString(config && config.pos, { allowEmpty: true });
  const itemChecked = resolveBoolean(config && config.checked, false);
  try {
    const response = callTrello('/checklists/' + encodeURIComponent(checklistId) + '/checkItems', {
      method: 'POST',
      query: {
        name: itemName,
        pos: itemPosition || undefined,
        checked: itemChecked
      }
    });
    const checkItem = response.body || {};
    const checkItemId = checkItem.id || null;
    ctx.trelloEnhancedCheckItem = checkItem;
    ctx.trelloEnhancedCheckItemId = checkItemId;
    logInfo('trello_enhanced_add_checklist_item_success', { checklistId: checklistId, checkItemId: checkItemId });
    return ctx;
  } catch (error) {
    handleTrelloEnhancedError(error, { operation: 'add_checklist_item', checklistId: checklistId });
  }
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds action.trello-enhanced:add_attachment 1`] = `
function step_action_trello_enhanced_add_attachment(ctx) {
  ctx = ctx || {};
  const config = {"id":"{{card_id}}","name":"Final creative brief.pdf","file":"{{file_base64}}","mimeType":"application/pdf","setCover":true};
  const operationKey = 'add_attachment';
  const apiKey = getSecret('TRELLO_API_KEY', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__api_key', 'apps_script__trello_enhanced__api_key'] });
  const token = getSecret('TRELLO_TOKEN', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__token', 'apps_script__trello_enhanced__token'] });

  if (!apiKey || !token) {
    logWarn('trello_enhanced_missing_credentials', { operation: operationKey });
    throw new Error('Trello Enhanced ' + operationKey + ' requires TRELLO_API_KEY and TRELLO_TOKEN script properties.');
  }

  const rateConfig = { attempts: 5, initialDelayMs: 700, maxDelayMs: 7000, jitter: 0.25 };

  function resolveOptionalString(template, options) {
    options = options || {};
    if (template === undefined || template === null) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return '';
    }

    if (typeof template !== 'string') {
      template = String(template);
    }

    const trimmed = template.trim();
    if (!trimmed) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return options.allowEmpty ? '' : '';
    }

    const resolved = options.skipTrim ? interpolate(trimmed, ctx) : interpolate(trimmed, ctx).trim();
    if (!resolved) {
      if (options.fallbackSecret) {
        try {
          const secret = getSecret(options.fallbackSecret, { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello_enhanced__webhook_callback_url', 'apps_script__trello__webhook_callback_url'] });
          if (secret) {
            return String(secret).trim();
          }
        } catch (error) {
          // Ignore missing fallback secret
        }
      }

      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }

      return options.allowEmpty ? '' : '';
    }

    return options.skipTrim ? resolved : resolved.trim();
  }

  function resolveRequiredString(value, message, options) {
    const resolved = resolveOptionalString(value, options);
    if (!resolved) {
      throw new Error(message);
    }
    return resolved;
  }

  function resolveCommaSeparated(value) {
    if (value === undefined || value === null) {
      return '';
    }
    if (Array.isArray(value)) {
      const parts = [];
      for (let i = 0; i < value.length; i++) {
        const entry = resolveOptionalString(value[i], { allowEmpty: true });
        if (entry) {
          parts.push(entry);
        }
      }
      return parts.join(',');
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return '';
    }
    const items = resolved.split(',').map(part => part.trim()).filter(Boolean);
    return items.join(',');
  }

  function resolveBoolean(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return !!defaultValue;
    }
    if (typeof value === 'boolean') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return !!defaultValue;
    }
    const normalized = resolved.toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') {
      return true;
    }
    if (normalized === 'false' || normalized === '0' || normalized === 'no') {
      return false;
    }
    return !!defaultValue;
  }

  function resolveNumber(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    if (typeof value === 'number') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    const numeric = Number(resolved);
    if (isNaN(numeric)) {
      throw new Error('Expected a numeric value but received "' + resolved + '".');
    }
    return numeric;
  }

  function buildQuery(params) {
    const parts = [];
    for (const key in params) {
      if (!Object.prototype.hasOwnProperty.call(params, key)) {
        continue;
      }
      const value = params[key];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const entry = value[i];
          if (entry === undefined || entry === null || entry === '') {
            continue;
          }
          parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(entry)));
        }
        continue;
      }
      const stringValue = String(value);
      if (!stringValue && stringValue !== '0') {
        continue;
      }
      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(stringValue));
    }
    return parts.join('&');
  }

  function callTrello(path, options) {
    options = options || {};
    const query = options.query ? Object.assign({}, options.query) : {};
    query.key = apiKey;
    query.token = token;
    const queryString = buildQuery(query);
    const url = 'https://api.trello.com/1' + path + (queryString ? '?' + queryString : '');
    const request = {
      url: url,
      method: options.method || 'GET',
      headers: options.headers || {},
      payload: options.payload,
      contentType: options.contentType,
      muteHttpExceptions: true,
    };
    return rateLimitAware(() => fetchJson(request), rateConfig);
  }

  function handleTrelloEnhancedError(error, metadata) {
    metadata = metadata || {};
    const status = error && typeof error.status === 'number' ? error.status : null;
    const payload = error && Object.prototype.hasOwnProperty.call(error, 'body') ? error.body : null;
    const details = [];
    if (metadata.boardId) {
      details.push('board ' + metadata.boardId);
    }
    if (metadata.listId) {
      details.push('list ' + metadata.listId);
    }
    if (metadata.cardId) {
      details.push('card ' + metadata.cardId);
    }
    if (metadata.modelId) {
      details.push('model ' + metadata.modelId);
    }
    if (status) {
      details.push('status ' + status);
    }
    if (payload && typeof payload === 'object') {
      if (payload.message) {
        details.push(String(payload.message));
      }
      if (payload.error) {
        details.push(String(payload.error));
      }
    }
    const context = details.length ? ' (' + details.join('; ') + ')' : '';
    const message = 'Trello Enhanced ' + (metadata.operation || operationKey) + ' failed' + context + '.';
    const wrapped = new Error(message);
    if (status !== null) {
      wrapped.status = status;
    }
    if (payload !== undefined) {
      wrapped.body = payload;
    }
    wrapped.cause = error;
    throw wrapped;
  }

  const cardId = resolveRequiredString(config && (config.id || config.cardId), 'Trello Enhanced add_attachment requires a card ID.');
  const attachmentName = resolveOptionalString(config && config.name, { allowEmpty: true }) || 'Attachment';
  const attachmentUrl = resolveOptionalString(config && config.url, { allowEmpty: true });
  const attachmentFile = resolveOptionalString(config && config.file, { allowEmpty: true });
  const attachmentMime = resolveOptionalString(config && config.mimeType, { allowEmpty: true }) || 'application/octet-stream';
  const setCover = resolveBoolean(config && config.setCover, false);
  if (!attachmentUrl && !attachmentFile) {
    throw new Error('Trello Enhanced add_attachment requires either a URL or base64 encoded file content.');
  }
  try {
    const endpoint = '/cards/' + encodeURIComponent(cardId) + '/attachments';
    let response;
    if (attachmentUrl) {
      response = callTrello(endpoint, {
        method: 'POST',
        query: {
          url: attachmentUrl,
          name: attachmentName || undefined,
          setCover: setCover
        }
      });
    } else {
      const decoded = Utilities.base64Decode(attachmentFile);
      const blob = Utilities.newBlob(decoded, attachmentMime || 'application/octet-stream', attachmentName || 'attachment');
      const payload = {
        file: blob,
        name: attachmentName || 'attachment'
      };
      if (setCover) {
        payload.setCover = 'true';
      }
      response = callTrello(endpoint, {
        method: 'POST',
        payload: payload
      });
    }
    const attachment = response.body || {};
    const attachmentId = attachment.id || null;
    ctx.trelloEnhancedAttachment = attachment;
    ctx.trelloEnhancedAttachmentId = attachmentId;
    logInfo('trello_enhanced_add_attachment_success', { cardId: cardId, attachmentId: attachmentId });
    return ctx;
  } catch (error) {
    handleTrelloEnhancedError(error, { operation: 'add_attachment', cardId: cardId });
  }
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds action.trello-enhanced:create_label 1`] = `
function step_action_trello_enhanced_create_label(ctx) {
  ctx = ctx || {};
  const config = {"idBoard":"{{board_id}}","name":"High Priority","color":"red"};
  const operationKey = 'create_label';
  const apiKey = getSecret('TRELLO_API_KEY', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__api_key', 'apps_script__trello_enhanced__api_key'] });
  const token = getSecret('TRELLO_TOKEN', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__token', 'apps_script__trello_enhanced__token'] });

  if (!apiKey || !token) {
    logWarn('trello_enhanced_missing_credentials', { operation: operationKey });
    throw new Error('Trello Enhanced ' + operationKey + ' requires TRELLO_API_KEY and TRELLO_TOKEN script properties.');
  }

  const rateConfig = { attempts: 5, initialDelayMs: 700, maxDelayMs: 7000, jitter: 0.25 };

  function resolveOptionalString(template, options) {
    options = options || {};
    if (template === undefined || template === null) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return '';
    }

    if (typeof template !== 'string') {
      template = String(template);
    }

    const trimmed = template.trim();
    if (!trimmed) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return options.allowEmpty ? '' : '';
    }

    const resolved = options.skipTrim ? interpolate(trimmed, ctx) : interpolate(trimmed, ctx).trim();
    if (!resolved) {
      if (options.fallbackSecret) {
        try {
          const secret = getSecret(options.fallbackSecret, { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello_enhanced__webhook_callback_url', 'apps_script__trello__webhook_callback_url'] });
          if (secret) {
            return String(secret).trim();
          }
        } catch (error) {
          // Ignore missing fallback secret
        }
      }

      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }

      return options.allowEmpty ? '' : '';
    }

    return options.skipTrim ? resolved : resolved.trim();
  }

  function resolveRequiredString(value, message, options) {
    const resolved = resolveOptionalString(value, options);
    if (!resolved) {
      throw new Error(message);
    }
    return resolved;
  }

  function resolveCommaSeparated(value) {
    if (value === undefined || value === null) {
      return '';
    }
    if (Array.isArray(value)) {
      const parts = [];
      for (let i = 0; i < value.length; i++) {
        const entry = resolveOptionalString(value[i], { allowEmpty: true });
        if (entry) {
          parts.push(entry);
        }
      }
      return parts.join(',');
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return '';
    }
    const items = resolved.split(',').map(part => part.trim()).filter(Boolean);
    return items.join(',');
  }

  function resolveBoolean(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return !!defaultValue;
    }
    if (typeof value === 'boolean') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return !!defaultValue;
    }
    const normalized = resolved.toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') {
      return true;
    }
    if (normalized === 'false' || normalized === '0' || normalized === 'no') {
      return false;
    }
    return !!defaultValue;
  }

  function resolveNumber(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    if (typeof value === 'number') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    const numeric = Number(resolved);
    if (isNaN(numeric)) {
      throw new Error('Expected a numeric value but received "' + resolved + '".');
    }
    return numeric;
  }

  function buildQuery(params) {
    const parts = [];
    for (const key in params) {
      if (!Object.prototype.hasOwnProperty.call(params, key)) {
        continue;
      }
      const value = params[key];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const entry = value[i];
          if (entry === undefined || entry === null || entry === '') {
            continue;
          }
          parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(entry)));
        }
        continue;
      }
      const stringValue = String(value);
      if (!stringValue && stringValue !== '0') {
        continue;
      }
      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(stringValue));
    }
    return parts.join('&');
  }

  function callTrello(path, options) {
    options = options || {};
    const query = options.query ? Object.assign({}, options.query) : {};
    query.key = apiKey;
    query.token = token;
    const queryString = buildQuery(query);
    const url = 'https://api.trello.com/1' + path + (queryString ? '?' + queryString : '');
    const request = {
      url: url,
      method: options.method || 'GET',
      headers: options.headers || {},
      payload: options.payload,
      contentType: options.contentType,
      muteHttpExceptions: true,
    };
    return rateLimitAware(() => fetchJson(request), rateConfig);
  }

  function handleTrelloEnhancedError(error, metadata) {
    metadata = metadata || {};
    const status = error && typeof error.status === 'number' ? error.status : null;
    const payload = error && Object.prototype.hasOwnProperty.call(error, 'body') ? error.body : null;
    const details = [];
    if (metadata.boardId) {
      details.push('board ' + metadata.boardId);
    }
    if (metadata.listId) {
      details.push('list ' + metadata.listId);
    }
    if (metadata.cardId) {
      details.push('card ' + metadata.cardId);
    }
    if (metadata.modelId) {
      details.push('model ' + metadata.modelId);
    }
    if (status) {
      details.push('status ' + status);
    }
    if (payload && typeof payload === 'object') {
      if (payload.message) {
        details.push(String(payload.message));
      }
      if (payload.error) {
        details.push(String(payload.error));
      }
    }
    const context = details.length ? ' (' + details.join('; ') + ')' : '';
    const message = 'Trello Enhanced ' + (metadata.operation || operationKey) + ' failed' + context + '.';
    const wrapped = new Error(message);
    if (status !== null) {
      wrapped.status = status;
    }
    if (payload !== undefined) {
      wrapped.body = payload;
    }
    wrapped.cause = error;
    throw wrapped;
  }

  const boardId = resolveRequiredString(config && (config.idBoard || config.boardId), 'Trello Enhanced create_label requires a board ID.');
  const labelName = resolveRequiredString(config && config.name, 'Trello Enhanced create_label requires a label name.');
  const labelColor = resolveRequiredString(config && config.color, 'Trello Enhanced create_label requires a color.');
  try {
    const response = callTrello('/labels', {
      method: 'POST',
      query: {
        idBoard: boardId,
        name: labelName,
        color: labelColor
      }
    });
    const label = response.body || {};
    const labelId = label.id || null;
    ctx.trelloEnhancedLabel = label;
    ctx.trelloEnhancedLabelId = labelId;
    logInfo('trello_enhanced_create_label_success', { boardId: boardId, labelId: labelId });
    return ctx;
  } catch (error) {
    handleTrelloEnhancedError(error, { operation: 'create_label', boardId: boardId });
  }
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds action.trello-enhanced:search_cards 1`] = `
function step_action_trello_enhanced_search_cards(ctx) {
  ctx = ctx || {};
  const config = {"query":"label:\"High Priority\" due:{{due_window}}","idBoards":"{{board_id}}","modelTypes":"cards","card_fields":"name,due,dueComplete,idMembers","cards_limit":50,"card_board":true,"card_list":true,"card_members":true,"card_attachments":"cover","board_fields":"name,url","boards_limit":1,"partial":false};
  const operationKey = 'search_cards';
  const apiKey = getSecret('TRELLO_API_KEY', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__api_key', 'apps_script__trello_enhanced__api_key'] });
  const token = getSecret('TRELLO_TOKEN', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__token', 'apps_script__trello_enhanced__token'] });

  if (!apiKey || !token) {
    logWarn('trello_enhanced_missing_credentials', { operation: operationKey });
    throw new Error('Trello Enhanced ' + operationKey + ' requires TRELLO_API_KEY and TRELLO_TOKEN script properties.');
  }

  const rateConfig = { attempts: 5, initialDelayMs: 700, maxDelayMs: 7000, jitter: 0.25 };

  function resolveOptionalString(template, options) {
    options = options || {};
    if (template === undefined || template === null) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return '';
    }

    if (typeof template !== 'string') {
      template = String(template);
    }

    const trimmed = template.trim();
    if (!trimmed) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return options.allowEmpty ? '' : '';
    }

    const resolved = options.skipTrim ? interpolate(trimmed, ctx) : interpolate(trimmed, ctx).trim();
    if (!resolved) {
      if (options.fallbackSecret) {
        try {
          const secret = getSecret(options.fallbackSecret, { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello_enhanced__webhook_callback_url', 'apps_script__trello__webhook_callback_url'] });
          if (secret) {
            return String(secret).trim();
          }
        } catch (error) {
          // Ignore missing fallback secret
        }
      }

      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }

      return options.allowEmpty ? '' : '';
    }

    return options.skipTrim ? resolved : resolved.trim();
  }

  function resolveRequiredString(value, message, options) {
    const resolved = resolveOptionalString(value, options);
    if (!resolved) {
      throw new Error(message);
    }
    return resolved;
  }

  function resolveCommaSeparated(value) {
    if (value === undefined || value === null) {
      return '';
    }
    if (Array.isArray(value)) {
      const parts = [];
      for (let i = 0; i < value.length; i++) {
        const entry = resolveOptionalString(value[i], { allowEmpty: true });
        if (entry) {
          parts.push(entry);
        }
      }
      return parts.join(',');
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return '';
    }
    const items = resolved.split(',').map(part => part.trim()).filter(Boolean);
    return items.join(',');
  }

  function resolveBoolean(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return !!defaultValue;
    }
    if (typeof value === 'boolean') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return !!defaultValue;
    }
    const normalized = resolved.toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') {
      return true;
    }
    if (normalized === 'false' || normalized === '0' || normalized === 'no') {
      return false;
    }
    return !!defaultValue;
  }

  function resolveNumber(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    if (typeof value === 'number') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    const numeric = Number(resolved);
    if (isNaN(numeric)) {
      throw new Error('Expected a numeric value but received "' + resolved + '".');
    }
    return numeric;
  }

  function buildQuery(params) {
    const parts = [];
    for (const key in params) {
      if (!Object.prototype.hasOwnProperty.call(params, key)) {
        continue;
      }
      const value = params[key];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const entry = value[i];
          if (entry === undefined || entry === null || entry === '') {
            continue;
          }
          parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(entry)));
        }
        continue;
      }
      const stringValue = String(value);
      if (!stringValue && stringValue !== '0') {
        continue;
      }
      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(stringValue));
    }
    return parts.join('&');
  }

  function callTrello(path, options) {
    options = options || {};
    const query = options.query ? Object.assign({}, options.query) : {};
    query.key = apiKey;
    query.token = token;
    const queryString = buildQuery(query);
    const url = 'https://api.trello.com/1' + path + (queryString ? '?' + queryString : '');
    const request = {
      url: url,
      method: options.method || 'GET',
      headers: options.headers || {},
      payload: options.payload,
      contentType: options.contentType,
      muteHttpExceptions: true,
    };
    return rateLimitAware(() => fetchJson(request), rateConfig);
  }

  function handleTrelloEnhancedError(error, metadata) {
    metadata = metadata || {};
    const status = error && typeof error.status === 'number' ? error.status : null;
    const payload = error && Object.prototype.hasOwnProperty.call(error, 'body') ? error.body : null;
    const details = [];
    if (metadata.boardId) {
      details.push('board ' + metadata.boardId);
    }
    if (metadata.listId) {
      details.push('list ' + metadata.listId);
    }
    if (metadata.cardId) {
      details.push('card ' + metadata.cardId);
    }
    if (metadata.modelId) {
      details.push('model ' + metadata.modelId);
    }
    if (status) {
      details.push('status ' + status);
    }
    if (payload && typeof payload === 'object') {
      if (payload.message) {
        details.push(String(payload.message));
      }
      if (payload.error) {
        details.push(String(payload.error));
      }
    }
    const context = details.length ? ' (' + details.join('; ') + ')' : '';
    const message = 'Trello Enhanced ' + (metadata.operation || operationKey) + ' failed' + context + '.';
    const wrapped = new Error(message);
    if (status !== null) {
      wrapped.status = status;
    }
    if (payload !== undefined) {
      wrapped.body = payload;
    }
    wrapped.cause = error;
    throw wrapped;
  }

  const queryText = resolveRequiredString(config && config.query, 'Trello Enhanced search_cards requires a query string.');
  const boardFilter = resolveOptionalString(config && config.idBoards, { allowEmpty: true });
  const organizationFilter = resolveOptionalString(config && config.idOrganizations, { allowEmpty: true });
  const cardFilter = resolveOptionalString(config && config.idCards, { allowEmpty: true });
  const modelTypes = resolveOptionalString(config && config.modelTypes, { allowEmpty: true, defaultValue: 'cards' }) || 'cards';
  const boardFields = resolveOptionalString(config && config.board_fields, { allowEmpty: true });
  const boardsLimit = resolveNumber(config && config.boards_limit, 10);
  const cardFields = resolveOptionalString(config && config.card_fields, { allowEmpty: true });
  const cardsLimit = resolveNumber(config && config.cards_limit, 10);
  const cardsPage = resolveNumber(config && config.cards_page, null);
  const includeCardBoard = resolveBoolean(config && config.card_board, false);
  const includeCardList = resolveBoolean(config && config.card_list, false);
  const includeCardMembers = resolveBoolean(config && config.card_members, false);
  const includeCardStickers = resolveBoolean(config && config.card_stickers, false);
  const cardAttachments = resolveOptionalString(config && config.card_attachments, { allowEmpty: true });
  const organizationFields = resolveOptionalString(config && config.organization_fields, { allowEmpty: true });
  const organizationsLimit = resolveNumber(config && config.organizations_limit, 10);
  const memberFields = resolveOptionalString(config && config.member_fields, { allowEmpty: true });
  const membersLimit = resolveNumber(config && config.members_limit, 10);
  const allowPartial = resolveBoolean(config && config.partial, false);
  try {
    const response = callTrello('/search', {
      method: 'GET',
      query: {
        query: queryText,
        idBoards: boardFilter || undefined,
        idOrganizations: organizationFilter || undefined,
        idCards: cardFilter || undefined,
        modelTypes: modelTypes || undefined,
        board_fields: boardFields || undefined,
        boards_limit: boardsLimit || undefined,
        card_fields: cardFields || undefined,
        cards_limit: cardsLimit || undefined,
        cards_page: cardsPage !== null ? cardsPage : undefined,
        card_board: includeCardBoard ? 'true' : undefined,
        card_list: includeCardList ? 'true' : undefined,
        card_members: includeCardMembers ? 'true' : undefined,
        card_stickers: includeCardStickers ? 'true' : undefined,
        card_attachments: cardAttachments || undefined,
        organization_fields: organizationFields || undefined,
        organizations_limit: organizationsLimit || undefined,
        member_fields: memberFields || undefined,
        members_limit: membersLimit || undefined,
        partial: allowPartial ? 'true' : undefined
      }
    });
    const body = response.body || {};
    const cards = Array.isArray(body.cards) ? body.cards : [];
    ctx.trelloEnhancedSearchResponse = body;
    ctx.trelloEnhancedCards = cards;
    ctx.trelloEnhancedSearchStats = {
      cards: cards.length,
      boards: Array.isArray(body.boards) ? body.boards.length : 0,
      query: queryText
    };
    logInfo('trello_enhanced_search_cards_success', { cards: cards.length, query: queryText });
    return ctx;
  } catch (error) {
    handleTrelloEnhancedError(error, { operation: 'search_cards', query: queryText });
  }
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds action.trello-enhanced:create_webhook 1`] = `
function step_action_trello_enhanced_create_webhook(ctx) {
  ctx = ctx || {};
  const config = {"idModel":"{{board_id}}","callbackURL":"https://hooks.example.com/trello/{{environment}}","description":"Launch automation webhook","active":true};
  const operationKey = 'create_webhook';
  const apiKey = getSecret('TRELLO_API_KEY', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__api_key', 'apps_script__trello_enhanced__api_key'] });
  const token = getSecret('TRELLO_TOKEN', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__token', 'apps_script__trello_enhanced__token'] });

  if (!apiKey || !token) {
    logWarn('trello_enhanced_missing_credentials', { operation: operationKey });
    throw new Error('Trello Enhanced ' + operationKey + ' requires TRELLO_API_KEY and TRELLO_TOKEN script properties.');
  }

  const rateConfig = { attempts: 5, initialDelayMs: 700, maxDelayMs: 7000, jitter: 0.25 };

  function resolveOptionalString(template, options) {
    options = options || {};
    if (template === undefined || template === null) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return '';
    }

    if (typeof template !== 'string') {
      template = String(template);
    }

    const trimmed = template.trim();
    if (!trimmed) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return options.allowEmpty ? '' : '';
    }

    const resolved = options.skipTrim ? interpolate(trimmed, ctx) : interpolate(trimmed, ctx).trim();
    if (!resolved) {
      if (options.fallbackSecret) {
        try {
          const secret = getSecret(options.fallbackSecret, { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello_enhanced__webhook_callback_url', 'apps_script__trello__webhook_callback_url'] });
          if (secret) {
            return String(secret).trim();
          }
        } catch (error) {
          // Ignore missing fallback secret
        }
      }

      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }

      return options.allowEmpty ? '' : '';
    }

    return options.skipTrim ? resolved : resolved.trim();
  }

  function resolveRequiredString(value, message, options) {
    const resolved = resolveOptionalString(value, options);
    if (!resolved) {
      throw new Error(message);
    }
    return resolved;
  }

  function resolveCommaSeparated(value) {
    if (value === undefined || value === null) {
      return '';
    }
    if (Array.isArray(value)) {
      const parts = [];
      for (let i = 0; i < value.length; i++) {
        const entry = resolveOptionalString(value[i], { allowEmpty: true });
        if (entry) {
          parts.push(entry);
        }
      }
      return parts.join(',');
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return '';
    }
    const items = resolved.split(',').map(part => part.trim()).filter(Boolean);
    return items.join(',');
  }

  function resolveBoolean(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return !!defaultValue;
    }
    if (typeof value === 'boolean') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return !!defaultValue;
    }
    const normalized = resolved.toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') {
      return true;
    }
    if (normalized === 'false' || normalized === '0' || normalized === 'no') {
      return false;
    }
    return !!defaultValue;
  }

  function resolveNumber(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    if (typeof value === 'number') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    const numeric = Number(resolved);
    if (isNaN(numeric)) {
      throw new Error('Expected a numeric value but received "' + resolved + '".');
    }
    return numeric;
  }

  function buildQuery(params) {
    const parts = [];
    for (const key in params) {
      if (!Object.prototype.hasOwnProperty.call(params, key)) {
        continue;
      }
      const value = params[key];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const entry = value[i];
          if (entry === undefined || entry === null || entry === '') {
            continue;
          }
          parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(entry)));
        }
        continue;
      }
      const stringValue = String(value);
      if (!stringValue && stringValue !== '0') {
        continue;
      }
      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(stringValue));
    }
    return parts.join('&');
  }

  function callTrello(path, options) {
    options = options || {};
    const query = options.query ? Object.assign({}, options.query) : {};
    query.key = apiKey;
    query.token = token;
    const queryString = buildQuery(query);
    const url = 'https://api.trello.com/1' + path + (queryString ? '?' + queryString : '');
    const request = {
      url: url,
      method: options.method || 'GET',
      headers: options.headers || {},
      payload: options.payload,
      contentType: options.contentType,
      muteHttpExceptions: true,
    };
    return rateLimitAware(() => fetchJson(request), rateConfig);
  }

  function handleTrelloEnhancedError(error, metadata) {
    metadata = metadata || {};
    const status = error && typeof error.status === 'number' ? error.status : null;
    const payload = error && Object.prototype.hasOwnProperty.call(error, 'body') ? error.body : null;
    const details = [];
    if (metadata.boardId) {
      details.push('board ' + metadata.boardId);
    }
    if (metadata.listId) {
      details.push('list ' + metadata.listId);
    }
    if (metadata.cardId) {
      details.push('card ' + metadata.cardId);
    }
    if (metadata.modelId) {
      details.push('model ' + metadata.modelId);
    }
    if (status) {
      details.push('status ' + status);
    }
    if (payload && typeof payload === 'object') {
      if (payload.message) {
        details.push(String(payload.message));
      }
      if (payload.error) {
        details.push(String(payload.error));
      }
    }
    const context = details.length ? ' (' + details.join('; ') + ')' : '';
    const message = 'Trello Enhanced ' + (metadata.operation || operationKey) + ' failed' + context + '.';
    const wrapped = new Error(message);
    if (status !== null) {
      wrapped.status = status;
    }
    if (payload !== undefined) {
      wrapped.body = payload;
    }
    wrapped.cause = error;
    throw wrapped;
  }

  const callbackUrl = resolveRequiredString(config && config.callbackURL, 'Trello Enhanced create_webhook requires a callback URL.', { fallbackSecret: 'TRELLO_WEBHOOK_CALLBACK_URL' });
  const modelId = resolveRequiredString(config && config.idModel, 'Trello Enhanced create_webhook requires a model ID.');
  const webhookDescription = resolveOptionalString(config && config.description, { allowEmpty: true }) || 'Trello Enhanced Webhook';
  const webhookActive = resolveBoolean(config && config.active, true);
  try {
    const payload = {
      description: webhookDescription || 'Trello Enhanced Webhook',
      callbackURL: callbackUrl,
      idModel: modelId,
      active: webhookActive
    };
    const response = callTrello('/webhooks', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      payload: JSON.stringify(payload),
      contentType: 'application/json'
    });
    const webhook = response.body || {};
    const webhookId = webhook.id || null;
    ctx.trelloEnhancedWebhook = webhook;
    ctx.trelloEnhancedWebhookId = webhookId;
    logInfo('trello_enhanced_create_webhook_success', { webhookId: webhookId, modelId: modelId });
    return ctx;
  } catch (error) {
    handleTrelloEnhancedError(error, { operation: 'create_webhook', modelId: modelId });
  }
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds action.trello-enhanced:test_connection 1`] = `
function step_action_trello_enhanced_test_connection(ctx) {
  ctx = ctx || {};
  const config = {};
  const operationKey = 'test_connection';
  const apiKey = getSecret('TRELLO_API_KEY', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__api_key', 'apps_script__trello_enhanced__api_key'] });
  const token = getSecret('TRELLO_TOKEN', { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello__token', 'apps_script__trello_enhanced__token'] });

  if (!apiKey || !token) {
    logWarn('trello_enhanced_missing_credentials', { operation: operationKey });
    throw new Error('Trello Enhanced ' + operationKey + ' requires TRELLO_API_KEY and TRELLO_TOKEN script properties.');
  }

  const rateConfig = { attempts: 5, initialDelayMs: 700, maxDelayMs: 7000, jitter: 0.25 };

  function resolveOptionalString(template, options) {
    options = options || {};
    if (template === undefined || template === null) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return '';
    }

    if (typeof template !== 'string') {
      template = String(template);
    }

    const trimmed = template.trim();
    if (!trimmed) {
      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }
      return options.allowEmpty ? '' : '';
    }

    const resolved = options.skipTrim ? interpolate(trimmed, ctx) : interpolate(trimmed, ctx).trim();
    if (!resolved) {
      if (options.fallbackSecret) {
        try {
          const secret = getSecret(options.fallbackSecret, { connectorKey: 'trello-enhanced', aliases: ['apps_script__trello_enhanced__webhook_callback_url', 'apps_script__trello__webhook_callback_url'] });
          if (secret) {
            return String(secret).trim();
          }
        } catch (error) {
          // Ignore missing fallback secret
        }
      }

      if (Object.prototype.hasOwnProperty.call(options, 'defaultValue')) {
        return options.defaultValue === undefined || options.defaultValue === null
          ? ''
          : String(options.defaultValue);
      }

      return options.allowEmpty ? '' : '';
    }

    return options.skipTrim ? resolved : resolved.trim();
  }

  function resolveRequiredString(value, message, options) {
    const resolved = resolveOptionalString(value, options);
    if (!resolved) {
      throw new Error(message);
    }
    return resolved;
  }

  function resolveCommaSeparated(value) {
    if (value === undefined || value === null) {
      return '';
    }
    if (Array.isArray(value)) {
      const parts = [];
      for (let i = 0; i < value.length; i++) {
        const entry = resolveOptionalString(value[i], { allowEmpty: true });
        if (entry) {
          parts.push(entry);
        }
      }
      return parts.join(',');
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return '';
    }
    const items = resolved.split(',').map(part => part.trim()).filter(Boolean);
    return items.join(',');
  }

  function resolveBoolean(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return !!defaultValue;
    }
    if (typeof value === 'boolean') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return !!defaultValue;
    }
    const normalized = resolved.toLowerCase();
    if (normalized === 'true' || normalized === '1' || normalized === 'yes') {
      return true;
    }
    if (normalized === 'false' || normalized === '0' || normalized === 'no') {
      return false;
    }
    return !!defaultValue;
  }

  function resolveNumber(value, defaultValue) {
    if (value === undefined || value === null || value === '') {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    if (typeof value === 'number') {
      return value;
    }
    const resolved = resolveOptionalString(value, { allowEmpty: true });
    if (!resolved) {
      return defaultValue === undefined ? null : Number(defaultValue);
    }
    const numeric = Number(resolved);
    if (isNaN(numeric)) {
      throw new Error('Expected a numeric value but received "' + resolved + '".');
    }
    return numeric;
  }

  function buildQuery(params) {
    const parts = [];
    for (const key in params) {
      if (!Object.prototype.hasOwnProperty.call(params, key)) {
        continue;
      }
      const value = params[key];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) {
          const entry = value[i];
          if (entry === undefined || entry === null || entry === '') {
            continue;
          }
          parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(String(entry)));
        }
        continue;
      }
      const stringValue = String(value);
      if (!stringValue && stringValue !== '0') {
        continue;
      }
      parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(stringValue));
    }
    return parts.join('&');
  }

  function callTrello(path, options) {
    options = options || {};
    const query = options.query ? Object.assign({}, options.query) : {};
    query.key = apiKey;
    query.token = token;
    const queryString = buildQuery(query);
    const url = 'https://api.trello.com/1' + path + (queryString ? '?' + queryString : '');
    const request = {
      url: url,
      method: options.method || 'GET',
      headers: options.headers || {},
      payload: options.payload,
      contentType: options.contentType,
      muteHttpExceptions: true,
    };
    return rateLimitAware(() => fetchJson(request), rateConfig);
  }

  function handleTrelloEnhancedError(error, metadata) {
    metadata = metadata || {};
    const status = error && typeof error.status === 'number' ? error.status : null;
    const payload = error && Object.prototype.hasOwnProperty.call(error, 'body') ? error.body : null;
    const details = [];
    if (metadata.boardId) {
      details.push('board ' + metadata.boardId);
    }
    if (metadata.listId) {
      details.push('list ' + metadata.listId);
    }
    if (metadata.cardId) {
      details.push('card ' + metadata.cardId);
    }
    if (metadata.modelId) {
      details.push('model ' + metadata.modelId);
    }
    if (status) {
      details.push('status ' + status);
    }
    if (payload && typeof payload === 'object') {
      if (payload.message) {
        details.push(String(payload.message));
      }
      if (payload.error) {
        details.push(String(payload.error));
      }
    }
    const context = details.length ? ' (' + details.join('; ') + ')' : '';
    const message = 'Trello Enhanced ' + (metadata.operation || operationKey) + ' failed' + context + '.';
    const wrapped = new Error(message);
    if (status !== null) {
      wrapped.status = status;
    }
    if (payload !== undefined) {
      wrapped.body = payload;
    }
    wrapped.cause = error;
    throw wrapped;
  }

  try {
    const response = callTrello('/members/me', { method: 'GET' });
    const member = response.body || {};
    ctx.trelloEnhancedConnectionVerified = true;
    ctx.trelloEnhancedMember = member;
    logInfo('trello_enhanced_test_connection_success', { memberId: member && member.id ? member.id : null });
    return ctx;
  } catch (error) {
    handleTrelloEnhancedError(error, { operation: 'test_connection' });
  }
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds trigger.trello-enhanced:card_created 1`] = `
function trigger_trigger_trello_enhanced_card_created(ctx) {
  ctx = ctx || {};
  const config = {"idBoard":"{{board_id}}"};
  const payload = ctx.payload || ctx.webhookPayload || ctx.webhook || {};
  const action = payload.action || {};
  const actionType = action.type || '';

  if (actionType !== 'createCard') {
    logInfo('trello_enhanced_card_created_ignored', { actionType: actionType || null });
    return ctx;
  }

  const data = action.data || {};
  const card = data.card || {};
  const list = data.list || {};
  const board = data.board || payload.model || {};
  const model = payload.model || {};
  const boardId = board && board.id ? String(board.id) : (model && model.id ? String(model.id) : null);

  const boardTemplate = config && (config.idBoard || config.boardId) ? String(config.idBoard || config.boardId) : '';
  const boardFilter = boardTemplate && typeof interpolate === 'function' ? interpolate(boardTemplate, ctx).trim() : '';
  if (boardFilter && boardId && boardId !== boardFilter) {
    logInfo('trello_enhanced_card_created_skipped_board', { boardId: boardId, filter: boardFilter });
    return ctx;
  }

  const dedupeId = action.id || (card && card.id ? card.id + ':' + (action.date || '') : null);
  const event = {
    trigger: 'card_created',
    action: action,
    card: card,
    list: list,
    board: board,
    model: model,
    raw: payload
  };

  if (!ctx.events || !Array.isArray(ctx.events)) {
    ctx.events = [];
  }
  ctx.events.push({ dedupeId: dedupeId, data: event });

  ctx.trelloEnhancedLastEvent = event;
  ctx.trelloEnhancedTrigger = 'card_created';
  ctx.trelloEnhancedDedupeId = dedupeId;

  logInfo('trello_enhanced_card_created_received', {
    cardId: card && card.id ? card.id : null,
    boardId: boardId || null,
    listId: list && list.id ? list.id : null
  });

  return ctx;
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds trigger.trello-enhanced:card_moved 1`] = `
function trigger_trigger_trello_enhanced_card_moved(ctx) {
  ctx = ctx || {};
  const config = {"idBoard":"bQ9H42"};
  const payload = ctx.payload || ctx.webhookPayload || ctx.webhook || {};
  const action = payload.action || {};
  const actionType = action.type || '';

  if (actionType !== 'updateCard') {
    logInfo('trello_enhanced_card_moved_ignored', { actionType: actionType || null });
    return ctx;
  }

  const data = action.data || {};
  const card = data.card || {};
  const listBefore = data.listBefore || {};
  const listAfter = data.listAfter || data.list || {};
  const board = data.board || payload.model || {};
  const model = payload.model || {};
  const boardId = board && board.id ? String(board.id) : (model && model.id ? String(model.id) : null);

  if (!listBefore.id || !listAfter.id || listBefore.id === listAfter.id) {
    logInfo('trello_enhanced_card_moved_noop', {
      listBefore: listBefore && listBefore.id ? listBefore.id : null,
      listAfter: listAfter && listAfter.id ? listAfter.id : null
    });
    return ctx;
  }

  const boardTemplate = config && (config.idBoard || config.boardId) ? String(config.idBoard || config.boardId) : '';
  const boardFilter = boardTemplate && typeof interpolate === 'function' ? interpolate(boardTemplate, ctx).trim() : '';
  if (boardFilter && boardId && boardId !== boardFilter) {
    logInfo('trello_enhanced_card_moved_skipped_board', { boardId: boardId, filter: boardFilter });
    return ctx;
  }

  const dedupeId = action.id || (card && card.id ? card.id + ':' + (listAfter.id || '') + ':' + (action.date || '') : null);
  const event = {
    trigger: 'card_moved',
    action: action,
    card: card,
    listBefore: listBefore,
    listAfter: listAfter,
    board: board,
    model: model,
    raw: payload
  };

  if (!ctx.events || !Array.isArray(ctx.events)) {
    ctx.events = [];
  }
  ctx.events.push({ dedupeId: dedupeId, data: event });

  ctx.trelloEnhancedLastEvent = event;
  ctx.trelloEnhancedTrigger = 'card_moved';
  ctx.trelloEnhancedDedupeId = dedupeId;

  logInfo('trello_enhanced_card_moved_received', {
    cardId: card && card.id ? card.id : null,
    listBefore: listBefore && listBefore.id ? listBefore.id : null,
    listAfter: listAfter && listAfter.id ? listAfter.id : null,
    boardId: boardId || null
  });

  return ctx;
}
`
exports[`Apps Script Trello Enhanced REAL_OPS builds trigger.trello-enhanced:checklist_item_completed 1`] = `
function trigger_trigger_trello_enhanced_checklist_item_completed(ctx) {
  ctx = ctx || {};
  const config = {};
  const payload = ctx.payload || ctx.webhookPayload || ctx.webhook || {};
  const action = payload.action || {};
  const actionType = action.type || '';

  if (actionType !== 'updateCheckItemStateOnCard') {
    logInfo('trello_enhanced_checklist_item_completed_ignored', { actionType: actionType || null });
    return ctx;
  }

  const data = action.data || {};
  const card = data.card || {};
  const checklist = data.checklist || {};
  const checkItem = data.checkItem || {};
  const board = data.board || payload.model || {};
  const model = payload.model || {};
  const boardId = board && board.id ? String(board.id) : (model && model.id ? String(model.id) : null);

  if ((checkItem.state || '').toLowerCase() !== 'complete') {
    logInfo('trello_enhanced_checklist_item_completed_not_complete', { state: checkItem.state || null });
    return ctx;
  }

  const boardTemplate = config && (config.idBoard || config.boardId) ? String(config.idBoard || config.boardId) : '';
  const boardFilter = boardTemplate && typeof interpolate === 'function' ? interpolate(boardTemplate, ctx).trim() : '';
  if (boardFilter && boardId && boardId !== boardFilter) {
    logInfo('trello_enhanced_checklist_item_completed_skipped_board', { boardId: boardId, filter: boardFilter });
    return ctx;
  }

  const dedupeId = checkItem.id || action.id || (card && card.id ? card.id + ':' + (action.date || '') : null);
  const event = {
    trigger: 'checklist_item_completed',
    action: action,
    card: card,
    checklist: checklist,
    checkItem: checkItem,
    board: board,
    model: model,
    raw: payload
  };

  if (!ctx.events || !Array.isArray(ctx.events)) {
    ctx.events = [];
  }
  ctx.events.push({ dedupeId: dedupeId, data: event });

  ctx.trelloEnhancedLastEvent = event;
  ctx.trelloEnhancedTrigger = 'checklist_item_completed';
  ctx.trelloEnhancedDedupeId = dedupeId;

  logInfo('trello_enhanced_checklist_item_completed_received', {
    cardId: card && card.id ? card.id : null,
    checklistId: checklist && checklist.id ? checklist.id : null,
    checkItemId: checkItem && checkItem.id ? checkItem.id : null,
    boardId: boardId || null
  });

  return ctx;
}
`
