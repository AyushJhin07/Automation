
/**
 * Generated by Apps Script Studio - Intelligent Workflow
 * Prompt: Escalate urgent customer incidents from Gmail into our on-call workflows
 * Nodes: 6 | Edges: 5
 * Automation Type: incident_response
 */


var __WORKFLOW_LOG_METADATA = {"workflowId":"apps-script-tier-0-critical","automationType":"incident_response","connectors":[{"id":"gmail","displayName":"gmail"},{"id":"slack","displayName":"slack"},{"id":"salesforce","displayName":"salesforce"},{"id":"system","displayName":"system"},{"id":"branch","displayName":"branch"},{"id":"sheets","displayName":"sheets"}]};

var __HTTP_RETRY_DEFAULTS = {
  maxAttempts: 5,
  initialDelayMs: 500,
  backoffFactor: 2,
  maxDelayMs: 60000
};

var __LOG_TRANSPORT_RESOLVED = false;
var __LOG_TRANSPORT_TARGET = null;

function mask(value, seen) {
  if (value === null || value === undefined) {
    return null;
  }
  if (!seen) {
    seen = [];
  }
  var type = typeof value;
  if (type === 'string') {
    return value.length ? '[masked]' : '';
  }
  if (type === 'number' || type === 'boolean') {
    return '[masked]';
  }
  if (type === 'object') {
    for (var i = 0; i < seen.length; i++) {
      if (seen[i] === value) {
        return '[masked]';
      }
    }
    seen.push(value);
    if (Array.isArray && Array.isArray(value)) {
      var maskedArray = [];
      for (var j = 0; j < value.length; j++) {
        maskedArray[j] = mask(value[j], seen);
      }
      seen.pop();
      return maskedArray;
    }
    if (Object.prototype.toString.call(value) === '[object Date]') {
      seen.pop();
      return '[masked]';
    }
    var maskedObject = {};
    for (var key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        maskedObject[key] = mask(value[key], seen);
      }
    }
    seen.pop();
    return maskedObject;
  }
  return '[masked]';
}

function __extractConnectorTag(details) {
  if (!details || typeof details !== 'object') {
    return null;
  }
  var candidateKeys = ['connector', 'connectorId', 'app', 'sourceConnector', 'targetConnector'];
  for (var i = 0; i < candidateKeys.length; i++) {
    var key = candidateKeys[i];
    var value = details[key];
    if (typeof value === 'string' && value) {
      return value;
    }
  }
  if (Array.isArray && Array.isArray(details.connectors) && details.connectors.length > 0) {
    var first = details.connectors[0];
    if (typeof first === 'string' && first) {
      return first;
    }
    if (first && typeof first === 'object') {
      if (typeof first.id === 'string' && first.id) {
        return first.id;
      }
      if (typeof first.normalizedId === 'string' && first.normalizedId) {
        return first.normalizedId;
      }
    }
  }
  return null;
}

function __resolveLogTransport() {
  if (__LOG_TRANSPORT_RESOLVED) {
    return __LOG_TRANSPORT_TARGET;
  }
  __LOG_TRANSPORT_RESOLVED = true;
  var candidate = null;
  try {
    if (typeof CENTRAL_LOG_TRANSPORT !== 'undefined' && CENTRAL_LOG_TRANSPORT) {
      candidate = CENTRAL_LOG_TRANSPORT;
    } else if (typeof LOG_TRANSPORT_URL !== 'undefined' && LOG_TRANSPORT_URL) {
      candidate = { url: LOG_TRANSPORT_URL };
    } else if (typeof APPS_SCRIPT_LOG_TRANSPORT !== 'undefined' && APPS_SCRIPT_LOG_TRANSPORT) {
      candidate = APPS_SCRIPT_LOG_TRANSPORT;
    }
  } catch (error) {
    // Ignore global resolution errors.
  }
  if (!candidate && typeof PropertiesService !== 'undefined' && PropertiesService && typeof PropertiesService.getScriptProperties === 'function') {
    try {
      var props = PropertiesService.getScriptProperties();
      var urlCandidates = [
        'CENTRAL_LOG_TRANSPORT_URL',
        'APPS_SCRIPT_LOG_TRANSPORT_URL',
        'CENTRAL_LOGGING_ENDPOINT',
        'LOG_TRANSPORT_URL',
        'LOGGING_ENDPOINT'
      ];
      for (var i = 0; i < urlCandidates.length; i++) {
        var urlValue = props.getProperty(urlCandidates[i]);
        if (urlValue) {
          candidate = { url: urlValue };
          break;
        }
      }
      if (!candidate) {
        var objectCandidates = ['CENTRAL_LOG_TRANSPORT', 'APPS_SCRIPT_LOG_TRANSPORT'];
        for (var j = 0; j < objectCandidates.length; j++) {
          var raw = props.getProperty(objectCandidates[j]);
          if (!raw) {
            continue;
          }
          try {
            var parsed = JSON.parse(raw);
            if (parsed && parsed.url) {
              candidate = parsed;
              break;
            }
          } catch (parseError) {
            // Ignore parse failures, fall back to console transport.
          }
        }
      }
    } catch (propertyError) {
      // Ignore property access errors.
    }
  }
  if (candidate && typeof candidate === 'string') {
    candidate = { url: candidate };
  }
  if (candidate && candidate.url) {
    __LOG_TRANSPORT_TARGET = candidate;
  } else {
    __LOG_TRANSPORT_TARGET = null;
  }
  return __LOG_TRANSPORT_TARGET;
}

function __normalizeHeaders(headers) {
  var normalized = {};
  if (!headers) {
    return normalized;
  }
  for (var key in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, key)) {
      normalized[String(key).toLowerCase()] = headers[key];
    }
  }
  return normalized;
}

function __resolveRetryAfterMs(value) {
  if (value === null || value === undefined) {
    return null;
  }
  if (Array.isArray && Array.isArray(value) && value.length > 0) {
    value = value[0];
  }
  var raw = String(value).trim();
  if (!raw) {
    return null;
  }
  var asNumber = Number(raw);
  var now = new Date().getTime();
  if (!isNaN(asNumber)) {
    if (asNumber > 1000000000000) {
      return Math.max(0, Math.round(asNumber - now));
    }
    if (asNumber > 1000000000) {
      return Math.max(0, Math.round(asNumber * 1000 - now));
    }
    return Math.max(0, Math.round(asNumber * 1000));
  }
  var parsedDate = new Date(raw);
  if (!isNaN(parsedDate.getTime())) {
    return Math.max(0, parsedDate.getTime() - now);
  }
  return null;
}

function __resolveResetDelayMs(value) {
  if (value === null || value === undefined) {
    return null;
  }
  if (Array.isArray && Array.isArray(value) && value.length > 0) {
    value = value[0];
  }
  var raw = String(value).trim();
  if (!raw) {
    return null;
  }
  var asNumber = Number(raw);
  var now = new Date().getTime();
  if (!isNaN(asNumber)) {
    if (asNumber > 1000000000000) {
      return Math.max(0, Math.round(asNumber - now));
    }
    if (asNumber > 1000000000) {
      return Math.max(0, Math.round(asNumber * 1000 - now));
    }
    return Math.max(0, Math.round(asNumber * 1000));
  }
  var parsedDate = new Date(raw);
  if (!isNaN(parsedDate.getTime())) {
    return Math.max(0, parsedDate.getTime() - now);
  }
  return null;
}

function logStructured(level, event, details) {
  var payload = {
    level: level,
    event: event,
    details: details || {},
    timestamp: new Date().toISOString()
  };
  var message = '[' + payload.level + '] ' + payload.event + ' ' + JSON.stringify(payload.details);
  if (level === 'ERROR') {
    console.error(message);
  } else if (level === 'WARN') {
    console.warn(message);
  } else {
    console.log(message);
  }

  try {
    var transport = __resolveLogTransport();
    if (transport && transport.url && typeof UrlFetchApp !== 'undefined' && UrlFetchApp && typeof UrlFetchApp.fetch === 'function') {
      var metadata = null;
      if (typeof __WORKFLOW_LOG_METADATA !== 'undefined' && __WORKFLOW_LOG_METADATA) {
        metadata = __WORKFLOW_LOG_METADATA;
      }
      var connectorTag = __extractConnectorTag(payload.details);
      var tags = {
        event: event,
        connector: connectorTag,
        workflowId: metadata && metadata.workflowId ? metadata.workflowId : null
      };
      var transportPayload = {
        timestamp: payload.timestamp,
        level: payload.level,
        event: payload.event,
        details: payload.details,
        tags: tags,
        workflow: metadata
      };
      var method = transport.method ? String(transport.method).toUpperCase() : 'POST';
      var fetchOptions = {
        method: method,
        contentType: 'application/json',
        muteHttpExceptions: true,
        payload: JSON.stringify(transportPayload)
      };
      if (transport.headers) {
        fetchOptions.headers = transport.headers;
      }
      UrlFetchApp.fetch(transport.url, fetchOptions);
    }
  } catch (transportError) {
    try {
      console.warn('logStructured transport failed: ' + (transportError && transportError.message ? transportError.message : transportError));
    } catch (consoleError) {
      // Swallow console failures.
    }
  }
}

function logInfo(event, details) {
  logStructured('INFO', event, details);
}

function logWarn(event, details) {
  logStructured('WARN', event, details);
}

function logError(event, details) {
  logStructured('ERROR', event, details);
}

logStructured.mask = mask;
logInfo.mask = mask;
logWarn.mask = mask;
logError.mask = mask;

var __TRIGGER_REGISTRY_KEY = '__studio_trigger_registry__';

function __loadTriggerRegistry() {
  try {
    var raw = PropertiesService.getScriptProperties().getProperty(__TRIGGER_REGISTRY_KEY);
    if (!raw) {
      return {};
    }
    var parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object') {
      return parsed;
    }
  } catch (error) {
    logWarn('trigger_registry_parse_failed', {
      message: error && error.message ? error.message : String(error)
    });
  }
  return {};
}

function __saveTriggerRegistry(registry) {
  try {
    PropertiesService.getScriptProperties().setProperty(
      __TRIGGER_REGISTRY_KEY,
      JSON.stringify(registry || {})
    );
  } catch (error) {
    logError('trigger_registry_save_failed', {
      message: error && error.message ? error.message : String(error)
    });
  }
}

function __findTriggerById(triggerId) {
  if (!triggerId) {
    return null;
  }
  var triggers = ScriptApp.getProjectTriggers();
  for (var i = 0; i < triggers.length; i++) {
    var trigger = triggers[i];
    if (!trigger) {
      continue;
    }
    if (typeof trigger.getUniqueId === 'function' && trigger.getUniqueId() === triggerId) {
      return trigger;
    }
  }
  return null;
}

function __ensureTrigger(triggerKey, handler, type, builderFn, description) {
  var registry = __loadTriggerRegistry();
  var entry = registry[triggerKey];
  if (entry) {
    var existing = __findTriggerById(entry.id);
    if (existing) {
      logInfo('trigger_exists', { key: triggerKey, handler: handler, type: type });
      return { key: triggerKey, triggerId: entry.id, handler: handler, type: type };
    }
    logWarn('trigger_missing_recreating', { key: triggerKey, handler: handler, type: type });
  }

  try {
    var trigger = builderFn();
    var triggerId = trigger && typeof trigger.getUniqueId === 'function' ? trigger.getUniqueId() : null;
    registry[triggerKey] = {
      id: triggerId,
      handler: handler,
      type: type,
      description: description || null,
      updatedAt: new Date().toISOString()
    };
    __saveTriggerRegistry(registry);
    logInfo('trigger_created', { key: triggerKey, handler: handler, type: type, description: description || null });
    return { key: triggerKey, triggerId: triggerId, handler: handler, type: type };
  } catch (error) {
    logError('trigger_create_failed', {
      key: triggerKey,
      handler: handler,
      type: type,
      message: error && error.message ? error.message : String(error)
    });
    throw error;
  }
}

function __createEphemeralTrigger(triggerKey, handler, type, builderFn, description) {
  try {
    var trigger = builderFn();
    var triggerId = trigger && typeof trigger.getUniqueId === 'function' ? trigger.getUniqueId() : null;
    logInfo('trigger_created', {
      key: triggerKey,
      handler: handler,
      type: type,
      ephemeral: true,
      description: description || null
    });
    return { key: triggerKey, triggerId: triggerId, handler: handler, type: type };
  } catch (error) {
    logError('trigger_create_failed', {
      key: triggerKey,
      handler: handler,
      type: type,
      ephemeral: true,
      message: error && error.message ? error.message : String(error)
    });
    throw error;
  }
}

function syncTriggerRegistry(activeKeys) {
  var registry = __loadTriggerRegistry();
  var keep = {};
  if (Array.isArray(activeKeys)) {
    for (var i = 0; i < activeKeys.length; i++) {
      keep[activeKeys[i]] = true;
    }
  }
  var triggers = ScriptApp.getProjectTriggers();
  var changed = false;

  for (var key in registry) {
    if (!keep[key]) {
      var entry = registry[key];
      var triggerId = entry && entry.id;
      if (triggerId) {
        for (var j = 0; j < triggers.length; j++) {
          var trigger = triggers[j];
          if (trigger && typeof trigger.getUniqueId === 'function' && trigger.getUniqueId() === triggerId) {
            ScriptApp.deleteTrigger(trigger);
            break;
          }
        }
      }
      delete registry[key];
      changed = true;
      logInfo('trigger_removed', { key: key });
    }
  }

  if (changed) {
    __saveTriggerRegistry(registry);
  }
}

function clearTriggerByKey(triggerKey) {
  if (!triggerKey) {
    return;
  }
  var registry = __loadTriggerRegistry();
  var entry = registry[triggerKey];
  if (!entry) {
    return;
  }
  var triggerId = entry.id;
  var trigger = triggerId ? __findTriggerById(triggerId) : null;
  if (trigger) {
    ScriptApp.deleteTrigger(trigger);
  }
  delete registry[triggerKey];
  __saveTriggerRegistry(registry);
  logInfo('trigger_cleared', { key: triggerKey });
}

function buildTimeTrigger(config) {
  config = config || {};
  var handler = config.handler || 'main';
  var triggerKey = config.key || handler + ':' + (config.frequency || 'time');
  var description = config.description || null;

  function builder() {
    var timeBuilder = ScriptApp.newTrigger(handler).timeBased();
    if (config.runAt) {
      return timeBuilder.at(new Date(config.runAt)).create();
    }
    if (config.everyMinutes) {
      timeBuilder.everyMinutes(Number(config.everyMinutes) || 1);
    } else if (config.everyHours) {
      timeBuilder.everyHours(Number(config.everyHours) || 1);
    } else if (config.everyDays) {
      timeBuilder.everyDays(Number(config.everyDays) || 1);
    } else if (config.everyWeeks) {
      timeBuilder.everyWeeks(Number(config.everyWeeks) || 1);
    }
    if (typeof config.atHour === 'number' && typeof timeBuilder.atHour === 'function') {
      timeBuilder.atHour(config.atHour);
    }
    if (typeof config.nearMinute === 'number' && typeof timeBuilder.nearMinute === 'function') {
      timeBuilder.nearMinute(config.nearMinute);
    }
    if (typeof config.onMonthDay === 'number' && typeof timeBuilder.onMonthDay === 'function') {
      timeBuilder.onMonthDay(config.onMonthDay);
    }
    if (config.onWeekDay) {
      var weekDay = config.onWeekDay;
      if (typeof weekDay === 'string') {
        weekDay = ScriptApp.WeekDay[weekDay] || ScriptApp.WeekDay.MONDAY;
      }
      if (weekDay) {
        timeBuilder.onWeekDay(weekDay);
      }
    }
    return timeBuilder.create();
  }

  if (config.ephemeral) {
    return __createEphemeralTrigger(triggerKey, handler, 'time', builder, description);
  }

  return __ensureTrigger(triggerKey, handler, 'time', builder, description);
}

function buildPollingWrapper(triggerKey, executor) {
  var metadata = typeof __WORKFLOW_LOG_METADATA !== 'undefined' ? __WORKFLOW_LOG_METADATA : null;
  var initialConnectors = [];
  if (metadata && metadata.connectors && metadata.connectors.length) {
    for (var i = 0; i < metadata.connectors.length; i++) {
      if (metadata.connectors[i]) {
        initialConnectors.push(metadata.connectors[i]);
      }
    }
  }

  var connectorMap = {};
  var connectorList = [];

  function coerceConnectorMetadata(entry) {
    if (!entry) {
      return null;
    }
    if (typeof entry === 'string') {
      var trimmed = entry.trim();
      if (!trimmed) {
        return null;
      }
      return {
        id: trimmed,
        normalizedId: trimmed,
        name: trimmed,
        displayName: trimmed,
      };
    }
    if (typeof entry !== 'object') {
      return null;
    }

    var normalized = '';
    if (typeof entry.normalizedId === 'string' && entry.normalizedId.trim()) {
      normalized = entry.normalizedId.trim();
    } else if (typeof entry.id === 'string' && entry.id.trim()) {
      normalized = entry.id.trim();
    } else if (typeof entry.key === 'string' && entry.key.trim()) {
      normalized = entry.key.trim();
    } else if (typeof entry.connectorKey === 'string' && entry.connectorKey.trim()) {
      normalized = entry.connectorKey.trim();
    }

    if (!normalized) {
      return null;
    }

    var candidateNames = [entry.displayName, entry.name, entry.title, entry.label];
    var displayName = normalized;
    for (var n = 0; n < candidateNames.length; n++) {
      var candidate = candidateNames[n];
      if (typeof candidate === 'string' && candidate.trim()) {
        displayName = candidate.trim();
        break;
      }
    }

    var identifier = typeof entry.id === 'string' && entry.id.trim() ? entry.id.trim() : normalized;

    return {
      id: identifier,
      normalizedId: normalized,
      name: displayName,
      displayName: displayName,
    };
  }

  function mergeConnectors(value) {
    if (!value) {
      return;
    }

    var additions = Array.isArray(value) ? value : [value];
    var updated = false;

    for (var c = 0; c < additions.length; c++) {
      var metadataEntry = coerceConnectorMetadata(additions[c]);
      if (!metadataEntry) {
        continue;
      }

      var key = metadataEntry.normalizedId || metadataEntry.id;
      if (!key) {
        continue;
      }

      var existing = connectorMap[key];
      if (existing) {
        var existingName = existing.displayName || existing.name || existing.normalizedId;
        if (metadataEntry.displayName && metadataEntry.displayName !== existingName) {
          existing.displayName = metadataEntry.displayName;
          existing.name = metadataEntry.displayName;
          updated = true;
        }
        if (!existing.id && metadataEntry.id) {
          existing.id = metadataEntry.id;
          updated = true;
        }
      } else {
        connectorList.push(metadataEntry);
        connectorMap[key] = metadataEntry;
        updated = true;
      }
    }

    if (updated || !stats.connectors) {
      stats.connectors = connectorList.slice();
    }
  }

  var stats = { processed: 0, succeeded: 0, failed: 0 };

  if (initialConnectors.length > 0) {
    mergeConnectors(initialConnectors);
  }

  var startedAtMs = Date.now();
  var startedAtIso = new Date(startedAtMs).toISOString();
  stats.startedAt = startedAtIso;
  var properties = PropertiesService.getScriptProperties();
  var stateKey = '__studio_trigger_state__:' + triggerKey;
  var state = {};

  try {
    var rawState = properties.getProperty(stateKey);
    if (rawState) {
      var parsedState = JSON.parse(rawState);
      if (parsedState && typeof parsedState === 'object') {
        state = parsedState;
      }
    }
  } catch (error) {
    logWarn('trigger_state_load_failed', {
      key: triggerKey,
      message: error && error.message ? error.message : String(error)
    });
    state = {};
  }

  if (!state || typeof state !== 'object') {
    state = {};
  }

  state.lastRunStartedAt = startedAtIso;

  function finalizeStats(status) {
    var completedAtMs = Date.now();
    stats.completedAt = new Date(completedAtMs).toISOString();
    stats.durationMs = completedAtMs - startedAtMs;
    if (typeof stats.failed !== 'number') {
      stats.failed = 0;
    }
    if (typeof stats.processed !== 'number') {
      stats.processed = 0;
    }
    stats.attempted = (stats.processed || 0) + (stats.failed || 0);
    if (stats.durationMs > 0) {
      var perSecond = stats.processed / (stats.durationMs / 1000);
      var perMinute = stats.processed / (stats.durationMs / 60000);
      stats.throughputPerSecond = Math.round(perSecond * 1000) / 1000;
      stats.throughputPerMinute = Math.round(perMinute * 1000) / 1000;
    } else {
      stats.throughputPerSecond = stats.processed;
      stats.throughputPerMinute = stats.processed * 60;
    }
    stats.status = status;
    if (connectorList.length > 0 && (!stats.connectors || stats.connectors.length !== connectorList.length)) {
      stats.connectors = connectorList.slice();
    }
  }

  function persistState() {
    try {
      properties.setProperty(stateKey, JSON.stringify(state || {}));
    } catch (error) {
      logError('trigger_state_save_failed', {
        key: triggerKey,
        message: error && error.message ? error.message : String(error)
      });
    }
  }

  logInfo('trigger_poll_start', {
    key: triggerKey,
    connectors: connectorList.slice(),
    state: state
  });

  var runtime = {
    state: state,
    setState: function (nextState) {
      if (!nextState || typeof nextState !== 'object') {
        return runtime.state;
      }
      state = nextState;
      runtime.state = state;
      return runtime.state;
    },
    dispatch: function (payload) {
      try {
        main(payload || {});
        stats.processed += 1;
        stats.succeeded += 1;
        return true;
      } catch (error) {
        stats.failed += 1;
        logError('trigger_dispatch_failed', {
          key: triggerKey,
          message: error && error.message ? error.message : String(error)
        });
        throw error;
      }
    },
    summary: function (partial) {
      if (!partial || typeof partial !== 'object') {
        return;
      }
      for (var key in partial) {
        if (!Object.prototype.hasOwnProperty.call(partial, key)) {
          continue;
        }
        if (key === 'connectors') {
          mergeConnectors(partial[key]);
        } else {
          stats[key] = partial[key];
        }
      }
    }
  };

  function dispatchBatch(items, mapFn) {
    var result = { attempted: 0, succeeded: 0, failed: 0, errors: [] };
    if (!items || (typeof items.length !== 'number' && !Array.isArray(items))) {
      return result;
    }

    for (var index = 0; index < items.length; index++) {
      var item = items[index];
      result.attempted += 1;
      var payload = item;

      if (mapFn) {
        try {
          payload = mapFn(item, index);
        } catch (mapError) {
          var mapMessage = mapError && mapError.message ? mapError.message : String(mapError);
          result.failed += 1;
          stats.failed += 1;
          result.errors.push(mapMessage);
          logError('trigger_dispatch_map_failed', {
            key: triggerKey,
            index: index,
            message: mapMessage
          });
          continue;
        }
      }

      try {
        runtime.dispatch(payload);
        result.succeeded += 1;
      } catch (dispatchError) {
        var dispatchMessage = dispatchError && dispatchError.message ? dispatchError.message : String(dispatchError);
        result.failed += 1;
        result.errors.push(dispatchMessage);
      }
    }

    stats.batches = (stats.batches || 0) + 1;
    stats.lastBatch = {
      attempted: result.attempted,
      succeeded: result.succeeded,
      failed: result.failed
    };

    return result;
  }

  runtime.dispatchBatch = dispatchBatch;

  try {
    var result = executor(runtime);
    if (result && typeof result === 'object') {
      runtime.summary(result);
    }
    finalizeStats('success');
    if (!Object.prototype.hasOwnProperty.call(state, 'lastRunAt')) {
      state.lastRunAt = stats.completedAt;
    }
    state.lastSuccessStats = {
      processed: stats.processed,
      failed: stats.failed,
      durationMs: stats.durationMs
    };
    persistState();
    logInfo('trigger_poll_success', { key: triggerKey, stats: stats, state: state });
    return stats;
  } catch (error) {
    var errorMessage = error && error.message ? error.message : String(error);
    finalizeStats('error');
    state.lastErrorAt = stats.completedAt;
    state.lastErrorMessage = errorMessage;
    persistState();
    logError('trigger_poll_error', {
      key: triggerKey,
      message: errorMessage,
      stats: stats
    });
    throw error;
  }
}

var __SECRET_HELPER_DEFAULT_OVERRIDES = {
  defaults: {
    AIRTABLE_API_KEY: { aliases: ['apps_script__airtable__api_key'] },
    AIRTABLE_BASE_ID: { aliases: ['apps_script__airtable__base_id'] },
    ASANA_ACCESS_TOKEN: { aliases: ['apps_script__asana__access_token'] },
    BOX_ACCESS_TOKEN: { aliases: ['apps_script__box__access_token'] },
    DOCUSIGN_ACCESS_TOKEN: { aliases: ['apps_script__docusign__access_token'] },
    DOCUSIGN_ACCOUNT_ID: { aliases: ['apps_script__docusign__account_id'] },
    DOCUSIGN_BASE_URI: { aliases: ['apps_script__docusign__base_uri'] },
    DROPBOX_ACCESS_TOKEN: { aliases: ['apps_script__dropbox__access_token'] },
    GITHUB_ACCESS_TOKEN: { aliases: ['apps_script__github__access_token'] },
    GOOGLE_ADMIN_ACCESS_TOKEN: { aliases: ['apps_script__google_admin__access_token'] },
    GOOGLE_ADMIN_CUSTOMER_ID: { aliases: ['apps_script__google_admin__customer_id'] },
    HUBSPOT_API_KEY: { aliases: ['apps_script__hubspot__api_key'] },
    JIRA_API_TOKEN: { aliases: ['apps_script__jira__api_token'] },
    JIRA_BASE_URL: { aliases: ['apps_script__jira__base_url'] },
    JIRA_EMAIL: { aliases: ['apps_script__jira__email'] },
    NOTION_ACCESS_TOKEN: { aliases: ['apps_script__notion__access_token'] },
    SALESFORCE_ACCESS_TOKEN: { aliases: ['apps_script__salesforce__access_token'] },
    SALESFORCE_INSTANCE_URL: { aliases: ['apps_script__salesforce__instance_url'] },
    SHOPIFY_ACCESS_TOKEN: { aliases: ['apps_script__shopify__access_token'] },
    SHOPIFY_API_KEY: { aliases: ['apps_script__shopify__api_key'] },
    SHOPIFY_SHOP_DOMAIN: { aliases: ['apps_script__shopify__shop_domain'] },
    SLACK_ACCESS_TOKEN: { aliases: ['apps_script__slack__bot_token'], mapTo: 'SLACK_BOT_TOKEN' },
    SLACK_BOT_TOKEN: { aliases: ['SLACK_ACCESS_TOKEN', 'apps_script__slack__bot_token'] },
    SLACK_WEBHOOK_URL: { aliases: ['apps_script__slack__webhook_url'] },
    SQUARE_ACCESS_TOKEN: { aliases: ['apps_script__square__access_token'] },
    SQUARE_APPLICATION_ID: { aliases: ['apps_script__square__application_id'] },
    SQUARE_ENVIRONMENT: { aliases: ['apps_script__square__environment'] },
    STRIPE_SECRET_KEY: { aliases: ['apps_script__stripe__secret_key'] },
    TRELLO_API_KEY: { aliases: ['apps_script__trello__api_key'] },
    TRELLO_TOKEN: { aliases: ['apps_script__trello__token'] },
    TWILIO_ACCOUNT_SID: { aliases: ['apps_script__twilio__account_sid'] },
    TWILIO_AUTH_TOKEN: { aliases: ['apps_script__twilio__auth_token'] },
    TWILIO_FROM_NUMBER: { aliases: ['apps_script__twilio__from_number'] },
    TYPEFORM_ACCESS_TOKEN: { aliases: ['apps_script__typeform__access_token'] }
  },
  connectors: {
    airtable: {
      AIRTABLE_API_KEY: { aliases: ['apps_script__airtable__api_key'] },
      AIRTABLE_BASE_ID: { aliases: ['apps_script__airtable__base_id'] }
    },
    asana: {
      ASANA_ACCESS_TOKEN: { aliases: ['apps_script__asana__access_token'] }
    },
    box: {
      BOX_ACCESS_TOKEN: { aliases: ['apps_script__box__access_token'] }
    },
    docusign: {
      DOCUSIGN_ACCESS_TOKEN: { aliases: ['apps_script__docusign__access_token'] },
      DOCUSIGN_ACCOUNT_ID: { aliases: ['apps_script__docusign__account_id'] },
      DOCUSIGN_BASE_URI: { aliases: ['apps_script__docusign__base_uri'] }
    },
    dropbox: {
      DROPBOX_ACCESS_TOKEN: { aliases: ['apps_script__dropbox__access_token'] }
    },
    github: {
      GITHUB_ACCESS_TOKEN: { aliases: ['apps_script__github__access_token'] }
    },
    'google-admin': {
      GOOGLE_ADMIN_ACCESS_TOKEN: { aliases: ['apps_script__google_admin__access_token'] },
      GOOGLE_ADMIN_CUSTOMER_ID: { aliases: ['apps_script__google_admin__customer_id'] }
    },
    hubspot: {
      HUBSPOT_API_KEY: { aliases: ['apps_script__hubspot__api_key'] }
    },
    jira: {
      JIRA_API_TOKEN: { aliases: ['apps_script__jira__api_token'] },
      JIRA_BASE_URL: { aliases: ['apps_script__jira__base_url'] },
      JIRA_EMAIL: { aliases: ['apps_script__jira__email'] }
    },
    notion: {
      NOTION_ACCESS_TOKEN: { aliases: ['apps_script__notion__access_token'] }
    },
    salesforce: {
      SALESFORCE_ACCESS_TOKEN: { aliases: ['apps_script__salesforce__access_token'] },
      SALESFORCE_INSTANCE_URL: { aliases: ['apps_script__salesforce__instance_url'] }
    },
    shopify: {
      SHOPIFY_ACCESS_TOKEN: { aliases: ['apps_script__shopify__access_token'] },
      SHOPIFY_API_KEY: { aliases: ['apps_script__shopify__api_key'] },
      SHOPIFY_SHOP_DOMAIN: { aliases: ['apps_script__shopify__shop_domain'] }
    },
    slack: {
      SLACK_ACCESS_TOKEN: { aliases: ['apps_script__slack__bot_token'], mapTo: 'SLACK_BOT_TOKEN' },
      SLACK_BOT_TOKEN: { aliases: ['SLACK_ACCESS_TOKEN', 'apps_script__slack__bot_token'] },
      SLACK_WEBHOOK_URL: { aliases: ['apps_script__slack__webhook_url'] }
    },
    square: {
      SQUARE_ACCESS_TOKEN: { aliases: ['apps_script__square__access_token'] },
      SQUARE_APPLICATION_ID: { aliases: ['apps_script__square__application_id'] },
      SQUARE_ENVIRONMENT: { aliases: ['apps_script__square__environment'] }
    },
    stripe: {
      STRIPE_SECRET_KEY: { aliases: ['apps_script__stripe__secret_key'] }
    },
    trello: {
      TRELLO_API_KEY: { aliases: ['apps_script__trello__api_key'] },
      TRELLO_TOKEN: { aliases: ['apps_script__trello__token'] }
    },
    twilio: {
      TWILIO_ACCOUNT_SID: { aliases: ['apps_script__twilio__account_sid'] },
      TWILIO_AUTH_TOKEN: { aliases: ['apps_script__twilio__auth_token'] },
      TWILIO_FROM_NUMBER: { aliases: ['apps_script__twilio__from_number'] }
    },
    typeform: {
      TYPEFORM_ACCESS_TOKEN: { aliases: ['apps_script__typeform__access_token'] }
    }
  }
};
var __CONNECTOR_OAUTH_TOKEN_METADATA = {
  asana: {
    displayName: 'Asana',
    property: 'ASANA_ACCESS_TOKEN',
    description: 'personal access token',
    aliases: ['apps_script__asana__access_token']
  },
  box: {
    displayName: 'Box',
    property: 'BOX_ACCESS_TOKEN',
    description: 'OAuth access token',
    aliases: ['apps_script__box__access_token']
  },
  docusign: {
    displayName: 'DocuSign',
    property: 'DOCUSIGN_ACCESS_TOKEN',
    description: 'access token',
    aliases: ['apps_script__docusign__access_token']
  },
  dropbox: {
    displayName: 'Dropbox',
    property: 'DROPBOX_ACCESS_TOKEN',
    description: 'OAuth access token',
    aliases: ['apps_script__dropbox__access_token']
  },
  github: {
    displayName: 'GitHub',
    property: 'GITHUB_ACCESS_TOKEN',
    description: 'access token',
    aliases: ['apps_script__github__access_token']
  },
  'google-admin': {
    displayName: 'Google Admin',
    property: 'GOOGLE_ADMIN_ACCESS_TOKEN',
    description: 'access token',
    aliases: ['apps_script__google_admin__access_token']
  },
  jira: {
    displayName: 'Jira',
    property: 'JIRA_API_TOKEN',
    description: 'API token',
    aliases: ['apps_script__jira__api_token']
  },
  notion: {
    displayName: 'Notion',
    property: 'NOTION_ACCESS_TOKEN',
    description: 'integration token',
    aliases: ['apps_script__notion__access_token']
  },
  salesforce: {
    displayName: 'Salesforce',
    property: 'SALESFORCE_ACCESS_TOKEN',
    description: 'access token',
    aliases: ['apps_script__salesforce__access_token']
  },
  shopify: {
    displayName: 'Shopify',
    property: 'SHOPIFY_ACCESS_TOKEN',
    description: 'access token',
    aliases: ['apps_script__shopify__access_token']
  },
  slack: {
    displayName: 'Slack',
    property: 'SLACK_BOT_TOKEN',
    description: 'bot token',
    aliases: ['SLACK_ACCESS_TOKEN', 'apps_script__slack__bot_token']
  },
  square: {
    displayName: 'Square',
    property: 'SQUARE_ACCESS_TOKEN',
    description: 'access token',
    aliases: ['apps_script__square__access_token']
  },
  stripe: {
    displayName: 'Stripe',
    property: 'STRIPE_SECRET_KEY',
    description: 'secret key',
    aliases: ['apps_script__stripe__secret_key']
  },
  trello: {
    displayName: 'Trello',
    property: 'TRELLO_TOKEN',
    description: 'OAuth token',
    aliases: ['apps_script__trello__token']
  },
  twilio: {
    displayName: 'Twilio',
    property: 'TWILIO_AUTH_TOKEN',
    description: 'auth token',
    aliases: ['apps_script__twilio__auth_token']
  },
  typeform: {
    displayName: 'Typeform',
    property: 'TYPEFORM_ACCESS_TOKEN',
    description: 'access token',
    aliases: ['apps_script__typeform__access_token']
  }
};
var __SECRET_HELPER_OVERRIDES = __mergeSecretHelperOverrides(
  __SECRET_HELPER_DEFAULT_OVERRIDES,
  typeof SECRET_HELPER_OVERRIDES !== 'undefined' && SECRET_HELPER_OVERRIDES ? SECRET_HELPER_OVERRIDES : {}
);
var __SECRET_VAULT_EXPORT_CACHE = null;
var __SECRET_VAULT_EXPORT_PARSED = false;
var __APPS_SCRIPT_SECRET_PREFIX = 'AS1.';
var __APPS_SCRIPT_SECRET_STREAM_INFO_BYTES = null;
var __APPS_SCRIPT_SECRET_METADATA_INFO_BYTES = null;

function __coerceSecretArray(value) {
  if (!value) {
    return [];
  }
  if (Array.isArray(value)) {
    return value.filter(function (item) {
      return typeof item === 'string' && item.trim().length > 0;
    });
  }
  if (typeof value === 'string' && value.trim().length > 0) {
    return [value.trim()];
  }
  return [];
}

function __cloneSecretOverrideEntry(entry) {
  if (!entry || typeof entry !== 'object') {
    return {};
  }
  var clone = {};
  if (entry.aliases !== undefined) {
    var aliases = __coerceSecretArray(entry.aliases);
    if (aliases.length > 0) {
      clone.aliases = aliases.slice();
    }
  }
  for (var key in entry) {
    if (!Object.prototype.hasOwnProperty.call(entry, key) || key === 'aliases') {
      continue;
    }
    clone[key] = entry[key];
  }
  return clone;
}

function __mergeSecretOverrideEntry(baseEntry, overrideEntry) {
  var merged = __cloneSecretOverrideEntry(baseEntry);
  if (!overrideEntry || typeof overrideEntry !== 'object') {
    return merged;
  }
  if (overrideEntry.aliases !== undefined) {
    var existing = merged.aliases ? merged.aliases.slice() : [];
    var additions = __coerceSecretArray(overrideEntry.aliases);
    for (var i = 0; i < additions.length; i++) {
      var alias = additions[i];
      if (existing.indexOf(alias) === -1) {
        existing.push(alias);
      }
    }
    if (existing.length > 0) {
      merged.aliases = existing;
    } else {
      delete merged.aliases;
    }
  }
  for (var key in overrideEntry) {
    if (!Object.prototype.hasOwnProperty.call(overrideEntry, key) || key === 'aliases') {
      continue;
    }
    merged[key] = overrideEntry[key];
  }
  return merged;
}

function __mergeSecretHelperOverrides(baseOverrides, extraOverrides) {
  var result = { defaults: {}, connectors: {} };

  if (baseOverrides && baseOverrides.defaults) {
    for (var baseDefaultKey in baseOverrides.defaults) {
      if (!Object.prototype.hasOwnProperty.call(baseOverrides.defaults, baseDefaultKey)) {
        continue;
      }
      result.defaults[baseDefaultKey] = __cloneSecretOverrideEntry(baseOverrides.defaults[baseDefaultKey]);
    }
  }

  if (baseOverrides && baseOverrides.connectors) {
    for (var baseConnectorKey in baseOverrides.connectors) {
      if (!Object.prototype.hasOwnProperty.call(baseOverrides.connectors, baseConnectorKey)) {
        continue;
      }
      var baseConnectorOverrides = baseOverrides.connectors[baseConnectorKey];
      var connectorClone = {};
      for (var baseProperty in baseConnectorOverrides) {
        if (!Object.prototype.hasOwnProperty.call(baseConnectorOverrides, baseProperty)) {
          continue;
        }
        connectorClone[baseProperty] = __cloneSecretOverrideEntry(baseConnectorOverrides[baseProperty]);
      }
      result.connectors[baseConnectorKey] = connectorClone;
    }
  }

  if (extraOverrides && extraOverrides.defaults) {
    for (var extraDefaultKey in extraOverrides.defaults) {
      if (!Object.prototype.hasOwnProperty.call(extraOverrides.defaults, extraDefaultKey)) {
        continue;
      }
      result.defaults[extraDefaultKey] = __mergeSecretOverrideEntry(
        result.defaults[extraDefaultKey],
        extraOverrides.defaults[extraDefaultKey]
      );
    }
  }

  if (extraOverrides && extraOverrides.connectors) {
    for (var extraConnectorKey in extraOverrides.connectors) {
      if (!Object.prototype.hasOwnProperty.call(extraOverrides.connectors, extraConnectorKey)) {
        continue;
      }
      var extraConnectorOverrides = extraOverrides.connectors[extraConnectorKey];
      if (!result.connectors[extraConnectorKey]) {
        result.connectors[extraConnectorKey] = {};
      }
      for (var extraProperty in extraConnectorOverrides) {
        if (!Object.prototype.hasOwnProperty.call(extraConnectorOverrides, extraProperty)) {
          continue;
        }
        result.connectors[extraConnectorKey][extraProperty] = __mergeSecretOverrideEntry(
          result.connectors[extraConnectorKey][extraProperty],
          extraConnectorOverrides[extraProperty]
        );
      }
    }
  }

  if (baseOverrides) {
    for (var baseKey in baseOverrides) {
      if (!Object.prototype.hasOwnProperty.call(baseOverrides, baseKey)) {
        continue;
      }
      if (baseKey === 'defaults' || baseKey === 'connectors') {
        continue;
      }
      result[baseKey] = baseOverrides[baseKey];
    }
  }

  if (extraOverrides) {
    for (var extraKey in extraOverrides) {
      if (!Object.prototype.hasOwnProperty.call(extraOverrides, extraKey)) {
        continue;
      }
      if (extraKey === 'defaults' || extraKey === 'connectors') {
        continue;
      }
      result[extraKey] = extraOverrides[extraKey];
    }
  }

  return result;
}

function __loadVaultExports() {
  if (__SECRET_VAULT_EXPORT_PARSED) {
    return __SECRET_VAULT_EXPORT_CACHE;
  }
  __SECRET_VAULT_EXPORT_PARSED = true;

  var scriptProps = PropertiesService.getScriptProperties();
  var raw =
    scriptProps.getProperty('__VAULT_EXPORTS__') ||
    scriptProps.getProperty('VAULT_EXPORTS_JSON') ||
    scriptProps.getProperty('VAULT_EXPORTS');

  if (!raw) {
    __SECRET_VAULT_EXPORT_CACHE = {};
    return __SECRET_VAULT_EXPORT_CACHE;
  }

  try {
    var parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object') {
      if (parsed.secrets && typeof parsed.secrets === 'object') {
        __SECRET_VAULT_EXPORT_CACHE = parsed.secrets;
      } else {
        __SECRET_VAULT_EXPORT_CACHE = parsed;
      }
    } else {
      __SECRET_VAULT_EXPORT_CACHE = {};
    }
  } catch (error) {
    logWarn('vault_exports_parse_failed', { message: error && error.message ? error.message : String(error) });
    __SECRET_VAULT_EXPORT_CACHE = {};
  }

  return __SECRET_VAULT_EXPORT_CACHE;
}

function __stringToBytes(value) {
  return Utilities.newBlob(value || '', 'text/plain').getBytes();
}

function __ensureSecretConstants() {
  if (!__APPS_SCRIPT_SECRET_STREAM_INFO_BYTES) {
    __APPS_SCRIPT_SECRET_STREAM_INFO_BYTES = __stringToBytes('apps-script-secret-stream-v1');
  }
  if (!__APPS_SCRIPT_SECRET_METADATA_INFO_BYTES) {
    __APPS_SCRIPT_SECRET_METADATA_INFO_BYTES = __stringToBytes('apps-script-secret-metadata-v1');
  }
}

function __concatByteArrays(chunks) {
  var total = 0;
  for (var i = 0; i < chunks.length; i++) {
    var chunk = chunks[i];
    if (chunk && chunk.length) {
      total += chunk.length;
    }
  }
  var result = new Array(total);
  var offset = 0;
  for (var j = 0; j < chunks.length; j++) {
    var segment = chunks[j];
    if (!segment) {
      continue;
    }
    for (var k = 0; k < segment.length; k++) {
      result[offset++] = segment[k];
    }
  }
  return result;
}

function __numberToUint32Bytes(value) {
  return [
    (value >>> 24) & 0xff,
    (value >>> 16) & 0xff,
    (value >>> 8) & 0xff,
    value & 0xff,
  ];
}

function __bytesToHex(bytes) {
  var hex = '';
  for (var i = 0; i < bytes.length; i++) {
    var piece = (bytes[i] & 0xff).toString(16);
    if (piece.length < 2) {
      piece = '0' + piece;
    }
    hex += piece;
  }
  return hex;
}

function __bytesToString(bytes) {
  return Utilities.newBlob(bytes, 'application/octet-stream').getDataAsString('utf-8');
}

function __constantTimeEqualsHex(a, b) {
  if (typeof a !== 'string' || typeof b !== 'string' || a.length !== b.length) {
    return false;
  }
  var result = 0;
  for (var i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  return result === 0;
}

function __deriveSecretKeystream(sharedKeyBytes, ivBytes, length) {
  __ensureSecretConstants();
  var blockSize = 32;
  var blocks = Math.ceil(length / blockSize);
  var output = new Array(blocks * blockSize);

  for (var i = 0; i < blocks; i++) {
    var counterBytes = __numberToUint32Bytes(i);
    var digest = Utilities.computeHmacSha256(
      __concatByteArrays([ivBytes, counterBytes, __APPS_SCRIPT_SECRET_STREAM_INFO_BYTES]),
      sharedKeyBytes
    );
    for (var j = 0; j < digest.length; j++) {
      output[i * blockSize + j] = digest[j];
    }
  }

  output.length = length;
  return output;
}

function __decodeAppsScriptSecret(value) {
  if (typeof value !== 'string' || value.indexOf(__APPS_SCRIPT_SECRET_PREFIX) !== 0) {
    return null;
  }

  var encoded = value.substring(__APPS_SCRIPT_SECRET_PREFIX.length);
  var tokenBytes = Utilities.base64Decode(encoded);
  var tokenJson = __bytesToString(tokenBytes);
  var token;

  try {
    token = JSON.parse(tokenJson);
  } catch (error) {
    throw new Error('Failed to parse sealed credential token: ' + error);
  }

  if (!token || typeof token !== 'object' || token.version !== 1) {
    throw new Error('Unrecognized sealed credential token format.');
  }

  var now = Date.now();
  if (typeof token.expiresAt === 'number' && now > token.expiresAt) {
    throw new Error('Credential token for ' + (token.purpose || 'credential') + ' has expired.');
  }

  var sharedKeyBytes = Utilities.base64Decode(token.sharedKey);
  var ivBytes = Utilities.base64Decode(token.iv);
  var ciphertextBytes = Utilities.base64Decode(token.ciphertext);

  __ensureSecretConstants();
  var macInput = __concatByteArrays([
    __APPS_SCRIPT_SECRET_METADATA_INFO_BYTES,
    ivBytes,
    ciphertextBytes,
    __stringToBytes(String(token.issuedAt)),
    __stringToBytes(String(token.expiresAt)),
    __stringToBytes(token.purpose || ''),
  ]);

  var macBytes = Utilities.computeHmacSha256(macInput, sharedKeyBytes);
  var macHex = __bytesToHex(macBytes);
  if (!__constantTimeEqualsHex(macHex, token.hmac)) {
    throw new Error('Credential token integrity check failed for ' + (token.purpose || 'credential') + '.');
  }

  var keystream = __deriveSecretKeystream(sharedKeyBytes, ivBytes, ciphertextBytes.length);
  var plaintextBytes = new Array(ciphertextBytes.length);
  for (var i = 0; i < ciphertextBytes.length; i++) {
    plaintextBytes[i] = ciphertextBytes[i] ^ keystream[i];
  }

  var payloadString = __bytesToString(plaintextBytes);
  var sealedPayload;
  try {
    sealedPayload = JSON.parse(payloadString);
  } catch (error) {
    throw new Error('Failed to decode sealed credential payload: ' + error);
  }

  if (
    !sealedPayload ||
    typeof sealedPayload !== 'object' ||
    sealedPayload.issuedAt !== token.issuedAt ||
    sealedPayload.expiresAt !== token.expiresAt ||
    (sealedPayload.purpose || null) !== (token.purpose || null)
  ) {
    throw new Error('Credential token metadata mismatch for ' + (token.purpose || 'credential') + '.');
  }

  return {
    payload: sealedPayload.payload,
    issuedAt: token.issuedAt,
    expiresAt: token.expiresAt,
    purpose: token.purpose || null,
  };
}

function getSecret(propertyName, opts) {
  var options = opts || {};
  var key = typeof propertyName === 'string' ? propertyName.trim() : '';

  if (!key) {
    throw new Error('getSecret requires a propertyName');
  }

  var connectorKey = options.connectorKey || options.connector || null;
  if (!connectorKey) {
    var normalizedKey = key.replace(/^_+/, '');
    var underscoreIndex = normalizedKey.indexOf('_');
    if (underscoreIndex > 0) {
      connectorKey = normalizedKey.substring(0, underscoreIndex).toLowerCase();
    }
  }
  var candidates = [];
  var seen = {};

  function pushCandidate(name) {
    if (!name || typeof name !== 'string') {
      return;
    }
    var trimmed = name.trim();
    if (!trimmed || seen[trimmed]) {
      return;
    }
    seen[trimmed] = true;
    candidates.push(trimmed);
  }

  pushCandidate(key);

  var defaultOverrides = (__SECRET_HELPER_OVERRIDES.defaults && __SECRET_HELPER_OVERRIDES.defaults[key]) || null;
  var connectorOverrides =
    (connectorKey &&
      __SECRET_HELPER_OVERRIDES.connectors &&
      __SECRET_HELPER_OVERRIDES.connectors[connectorKey] &&
      __SECRET_HELPER_OVERRIDES.connectors[connectorKey][key]) ||
    null;

  __coerceSecretArray(defaultOverrides && defaultOverrides.aliases).forEach(pushCandidate);
  __coerceSecretArray(connectorOverrides && connectorOverrides.aliases).forEach(pushCandidate);
  __coerceSecretArray(options.aliases || options.alias).forEach(pushCandidate);

  if (defaultOverrides && defaultOverrides.mapTo) {
    pushCandidate(defaultOverrides.mapTo);
  }
  if (connectorOverrides && connectorOverrides.mapTo) {
    pushCandidate(connectorOverrides.mapTo);
  }
  if (options.mapTo) {
    pushCandidate(options.mapTo);
  }

  var scriptProps = PropertiesService.getScriptProperties();
  var resolvedKey = null;
  var value = null;
  var source = null;

  for (var i = 0; i < candidates.length; i++) {
    var candidate = candidates[i];
    var candidateValue = scriptProps.getProperty(candidate);
    if (candidateValue !== null && candidateValue !== undefined && String(candidateValue).trim() !== '') {
      resolvedKey = candidate;
      value = candidateValue;
      source = 'script_properties';
      break;
    }
  }

  if (value === null) {
    var vaultSecrets = __loadVaultExports();
    if (vaultSecrets && typeof vaultSecrets === 'object') {
      for (var j = 0; j < candidates.length; j++) {
        var vaultKey = candidates[j];
        if (vaultSecrets.hasOwnProperty(vaultKey) && vaultSecrets[vaultKey] !== undefined && vaultSecrets[vaultKey] !== null) {
          resolvedKey = vaultKey;
          value = String(vaultSecrets[vaultKey]);
          source = 'vault_exports';
          break;
        }
      }
    }
  }

  if (value === null && defaultOverrides && defaultOverrides.defaultValue !== undefined) {
    value = defaultOverrides.defaultValue;
    source = 'default_override';
    resolvedKey = key;
  }

  if (value === null && connectorOverrides && connectorOverrides.defaultValue !== undefined) {
    value = connectorOverrides.defaultValue;
    source = 'connector_override';
    resolvedKey = key;
  }

  if (value === null && options.defaultValue !== undefined) {
    value = options.defaultValue;
    source = 'default_option';
    resolvedKey = key;
  }

  if (value === null || value === undefined || String(value).trim() === '') {
    logError('secret_missing', {
      property: key,
      connectorKey: connectorKey || null,
      triedKeys: candidates
    });
    throw new Error('Missing required secret "' + key + '"');
  }

  if (options.logResolved) {
    logInfo('secret_resolved', {
      property: key,
      connectorKey: connectorKey || null,
      resolvedKey: resolvedKey,
      source: source
    });
  }

  if (typeof value === 'string') {
    var sealed = __decodeAppsScriptSecret(value);
    if (sealed) {
      if (options.logResolved) {
        logInfo('sealed_secret_validated', {
          property: key,
          connector: connectorKey || null,
          purpose: sealed.purpose,
          expiresAt: new Date(sealed.expiresAt).toISOString(),
        });
      }
      value = sealed.payload;
    }
  }

  return value;
}

function requireOAuthToken(connectorKey, opts) {
  var options = opts || {};
  var key = typeof connectorKey === 'string' ? connectorKey.trim().toLowerCase() : '';

  if (!key) {
    throw new Error('requireOAuthToken requires a connectorKey');
  }

  var metadata = __CONNECTOR_OAUTH_TOKEN_METADATA[key];
  if (!metadata) {
    throw new Error('requireOAuthToken is not configured for connector "' + key + '"');
  }

  var scopes = __coerceSecretArray(options.scopes);

  try {
    return getSecret(metadata.property, { connectorKey: key });
  } catch (error) {
    var message = error && error.message ? String(error.message) : '';
    if (message.indexOf('Missing required secret') === 0) {
      var requirement = metadata.description || 'OAuth token';
      var article = 'a';
      if (requirement && /^[aeiou]/i.test(requirement)) {
        article = 'an';
      }
      var aliasList = __coerceSecretArray(metadata.aliases);
      var aliasText = aliasList.length > 0 ? ' (aliases: ' + aliasList.join(', ') + ')' : '';
      var scopeText = scopes.length > 0 ? ' Required scopes: ' + scopes.join(', ') + '.' : '';
      throw new Error(
        metadata.displayName +
          ' requires ' +
          article +
          ' ' +
          requirement +
          '. Configure ' +
          metadata.property +
          aliasText +
          ' in Script Properties.' +
          scopeText
      );
    }
    throw error;
  }
}

function withRetries(fn, options) {
  var config = options || {};
  var attempts = config.attempts || config.maxAttempts || __HTTP_RETRY_DEFAULTS.maxAttempts;
  var backoffMs = config.backoffMs || config.initialDelayMs || __HTTP_RETRY_DEFAULTS.initialDelayMs;
  var backoffFactor = config.backoffFactor || __HTTP_RETRY_DEFAULTS.backoffFactor;
  var maxDelayMs = config.maxDelayMs || __HTTP_RETRY_DEFAULTS.maxDelayMs;
  var jitter = typeof config.jitter === 'number' ? config.jitter : 0;
  var retryOn = typeof config.retryOn === 'function' ? config.retryOn : null;
  var attempt = 0;
  var delay = backoffMs;

  while (attempt < attempts) {
    try {
      return fn(attempt + 1);
    } catch (error) {
      attempt++;
      var status = error && typeof error.status === 'number' ? error.status : null;
      var headers = error && error.headers ? error.headers : {};
      var normalizedHeaders = __normalizeHeaders(headers);
      var retryAfterMs = __resolveRetryAfterMs(normalizedHeaders['retry-after']);
      var message = error && error.message ? error.message : String(error);
      var shouldRetry = attempt < attempts && (status ? (status === 429 || (status >= 500 && status < 600)) : true);
      var userDelay = null;

      var context = {
        attempt: attempt,
        error: error,
        response: status !== null ? { status: status, headers: headers || {}, body: error.body, text: error.text } : null,
        delayMs: delay,
        retryAfterMs: retryAfterMs
      };

      if (retryOn) {
        try {
          var decision = retryOn(context);
          if (typeof decision === 'boolean') {
            shouldRetry = attempt < attempts && decision;
          } else if (decision && typeof decision === 'object') {
            if (decision.retry !== undefined) {
              shouldRetry = attempt < attempts && !!decision.retry;
            }
            if (decision.delayMs !== undefined) {
              userDelay = Number(decision.delayMs);
              if (isNaN(userDelay)) {
                userDelay = null;
              }
            }
          }
        } catch (retryError) {
          logWarn('http_retry_callback_failed', {
            attempt: attempt,
            message: retryError && retryError.message ? retryError.message : String(retryError)
          });
        }
      }

      if (!shouldRetry || attempt >= attempts) {
        logError('http_retry_exhausted', { attempts: attempt, message: message, status: status });
        throw error;
      }

      var waitMs = userDelay !== null ? userDelay : (retryAfterMs !== null ? retryAfterMs : delay);
      if (typeof waitMs !== 'number' || isNaN(waitMs) || waitMs < 0) {
        waitMs = delay;
      }
      waitMs = Math.min(waitMs, maxDelayMs);

      if (jitter) {
        var jitterRange = waitMs * jitter;
        if (jitterRange > 0) {
          waitMs = Math.min(maxDelayMs, waitMs + Math.floor(Math.random() * jitterRange));
        }
      }

      logWarn('http_retry', { attempt: attempt, delayMs: waitMs, status: status, message: message });
      Utilities.sleep(waitMs);
      delay = Math.min(Math.max(backoffMs, waitMs) * backoffFactor, maxDelayMs);
    }
  }

  throw new Error('withRetries exhausted without executing function');
}

function rateLimitAware(fn, options) {
  var config = options || {};
  var providedRetryOn = typeof config.retryOn === 'function' ? config.retryOn : null;
  var mergedOptions = {};
  for (var key in config) {
    if (Object.prototype.hasOwnProperty.call(config, key)) {
      mergedOptions[key] = config[key];
    }
  }

  mergedOptions.retryOn = function(context) {
    var headers = {};
    if (context) {
      if (context.response && context.response.headers) {
        headers = context.response.headers;
      } else if (context.error && context.error.headers) {
        headers = context.error.headers;
      }
    }
    var normalizedHeaders = __normalizeHeaders(headers);
    var status = null;
    if (context && context.response && typeof context.response.status === 'number') {
      status = context.response.status;
    } else if (context && context.error && typeof context.error.status === 'number') {
      status = context.error.status;
    }

    var computedDelay = null;

    if (normalizedHeaders['retry-after'] !== undefined) {
      var retryDelay = __resolveRetryAfterMs(normalizedHeaders['retry-after']);
      if (retryDelay !== null) {
        computedDelay = retryDelay;
      }
    }

    var remainingKeys = ['x-ratelimit-remaining', 'x-rate-limit-remaining'];
    for (var i = 0; i < remainingKeys.length; i++) {
      var remainingValue = normalizedHeaders[remainingKeys[i]];
      if (remainingValue === undefined) {
        continue;
      }
      var remaining = Number(String(remainingValue));
      if (!isNaN(remaining) && remaining <= 0) {
        var resetKey = remainingKeys[i] === 'x-ratelimit-remaining' ? 'x-ratelimit-reset' : 'x-rate-limit-reset';
        var resetDelay = __resolveResetDelayMs(normalizedHeaders[resetKey]);
        if (resetDelay !== null) {
          computedDelay = computedDelay === null ? resetDelay : Math.max(computedDelay, resetDelay);
        }
      }
    }

    var result = {};
    if (status === 429 || (status >= 500 && status < 600)) {
      result.retry = true;
    }

    if (computedDelay !== null) {
      result.delayMs = computedDelay;
    }

    if (providedRetryOn) {
      var userDecision = providedRetryOn(context);
      if (typeof userDecision === 'boolean') {
        result.retry = userDecision;
      } else if (userDecision && typeof userDecision === 'object') {
        if (userDecision.retry !== undefined) {
          result.retry = userDecision.retry;
        }
        if (userDecision.delayMs !== undefined) {
          result.delayMs = userDecision.delayMs;
        }
      }
    }

    if (result.delayMs !== undefined && context && typeof context.delayMs === 'number') {
      var numericDelay = Number(result.delayMs);
      if (!isNaN(numericDelay)) {
        result.delayMs = Math.max(numericDelay, context.delayMs);
      }
    }

    return result;
  };

  return withRetries(fn, mergedOptions);
}

function __getRuntimeFileByRef(ctx, ref) {
  if (!ref) {
    return null;
  }

  var containers = [];
  if (ctx && typeof ctx === 'object') {
    if (ctx.__automationRuntime && ctx.__automationRuntime.files) {
      containers.push(ctx.__automationRuntime.files);
    }
    if (ctx.__runtime && ctx.__runtime.files) {
      containers.push(ctx.__runtime.files);
    }
    if (ctx.files) {
      containers.push(ctx.files);
    }
    if (ctx.attachments) {
      containers.push(ctx.attachments);
    }
    if (ctx.__files) {
      containers.push(ctx.__files);
    }
  }

  for (var i = 0; i < containers.length; i++) {
    var store = containers[i];
    if (!store) {
      continue;
    }

    if (typeof store === 'object') {
      if (Array.isArray(store)) {
        for (var j = 0; j < store.length; j++) {
          var item = store[j];
          if (!item) {
            continue;
          }
          if (item.id === ref || item.ref === ref || item.name === ref || item.fileName === ref) {
            return item;
          }
        }
      } else {
        if (store[ref]) {
          return store[ref];
        }
        if (store[String(ref)]) {
          return store[String(ref)];
        }
      }
    }
  }

  return null;
}

function __coerceByteArray(value) {
  if (!value) {
    return [];
  }

  if (Array.isArray(value)) {
    var result = [];
    for (var i = 0; i < value.length; i++) {
      var current = value[i];
      if (typeof current === 'number') {
        result.push(current & 0xff);
      } else if (typeof current === 'string' && current) {
        var parsed = Number(current);
        if (!isNaN(parsed)) {
          result.push(parsed & 0xff);
        }
      }
    }
    return result;
  }

  if (typeof value === 'string') {
    try {
      return Utilities.base64Decode(value);
    } catch (error) {
      return Utilities.newBlob(value).getBytes();
    }
  }

  if (value.bytes && Array.isArray(value.bytes)) {
    return __coerceByteArray(value.bytes);
  }

  if (value.blob && typeof value.blob.getBytes === 'function') {
    try {
      return value.blob.getBytes();
    } catch (error) {
      return [];
    }
  }

  return [];
}

function __resolveUploadInput(ctx, options) {
  var config = options || {};
  var provider = config.provider || 'connector';
  var inlineContent = typeof config.inlineContent === 'string' ? interpolate(config.inlineContent, ctx) : null;
  var inlineFileContent = typeof config.inlineFileContent === 'string' ? interpolate(config.inlineFileContent, ctx) : null;
  var inlineRef = typeof config.inlineRef === 'string' ? interpolate(config.inlineRef, ctx) : null;
  var inlineFileName = typeof config.inlineFileName === 'string' ? interpolate(config.inlineFileName, ctx) : null;
  var inlineMimeType = typeof config.inlineMimeType === 'string' ? interpolate(config.inlineMimeType, ctx) : null;
  var fallbackName = typeof config.fallbackName === 'string' ? config.fallbackName : null;

  var source = 'inline';
  var candidateContent = inlineContent || inlineFileContent;
  var base64Content = typeof candidateContent === 'string' ? candidateContent.trim() : null;
  var bytes = null;
  var mimeType = inlineMimeType || 'application/octet-stream';

  if ((!base64Content || base64Content.length === 0) && inlineRef) {
    var file = __getRuntimeFileByRef(ctx, inlineRef.trim());
    if (!file) {
      throw new Error(provider + ' upload requires resolving file reference "' + inlineRef + '".');
    }
    source = 'reference';
    if (!inlineFileName && (file.name || file.fileName || file.filename)) {
      inlineFileName = file.name || file.fileName || file.filename;
    }
    if (!inlineMimeType && (file.mimeType || file.contentType)) {
      mimeType = file.mimeType || file.contentType;
    }
    if (file.base64 || file.base64Content) {
      base64Content = file.base64 || file.base64Content;
    } else if (typeof file.content === 'string' && file.content) {
      base64Content = file.content;
    } else if (typeof file.data === 'string' && file.data) {
      base64Content = file.data;
    } else if (file.body && typeof file.body === 'string') {
      base64Content = file.body;
    }
    if (!base64Content && file.bytes) {
      bytes = __coerceByteArray(file.bytes);
    }
    if (!base64Content && !bytes && file.blob && typeof file.blob.getBytes === 'function') {
      bytes = file.blob.getBytes();
      try {
        if (!inlineMimeType && file.blob.getContentType) {
          mimeType = file.blob.getContentType();
        }
        if (!inlineFileName && file.blob.getName) {
          inlineFileName = file.blob.getName();
        }
      } catch (error) {}
    }
    if (!base64Content && file.base64Content) {
      base64Content = file.base64Content;
    }
  }

  if ((!base64Content || base64Content.length === 0) && !bytes) {
    var fallbackKeys = Array.isArray(config.fallbackCtxKeys) ? config.fallbackCtxKeys : [];
    for (var i = 0; i < fallbackKeys.length; i++) {
      var key = fallbackKeys[i];
      if (!key) {
        continue;
      }
      if (ctx && typeof ctx === 'object' && typeof ctx[key] === 'string') {
        base64Content = ctx[key];
        source = 'context';
        break;
      }
    }
  }

  if (!base64Content && !bytes) {
    throw new Error(provider + ' upload requires file content. Provide base64 content or a valid reference.');
  }

  if (!bytes) {
    try {
      bytes = Utilities.base64Decode(base64Content);
    } catch (error) {
      var blob = Utilities.newBlob(String(base64Content));
      bytes = blob.getBytes();
      if (!inlineMimeType) {
        mimeType = blob.getContentType();
      }
      source = source || 'text';
    }
  }

  var size = bytes.length;
  var name = inlineFileName || (fallbackName || ('upload-' + Date.now()));

  return {
    bytes: bytes,
    size: size,
    mimeType: mimeType || 'application/octet-stream',
    name: name,
    base64: base64Content || Utilities.base64Encode(bytes),
    source: source || 'inline'
  };
}

function __sliceBytes(bytes, start, end) {
  var result = [];
  if (!bytes || !bytes.length) {
    return result;
  }
  var limit = typeof end === 'number' ? Math.min(end, bytes.length) : bytes.length;
  for (var i = start; i < limit; i++) {
    result.push(bytes[i]);
  }
  return result;
}

function __dropboxFetch(url, requestOptions, accessToken) {
  var headers = {};
  if (requestOptions && requestOptions.headers) {
    for (var key in requestOptions.headers) {
      if (Object.prototype.hasOwnProperty.call(requestOptions.headers, key)) {
        headers[key] = requestOptions.headers[key];
      }
    }
  }
  headers['Authorization'] = 'Bearer ' + accessToken;

  var options = {
    method: requestOptions && requestOptions.method ? requestOptions.method : 'post',
    headers: headers,
    muteHttpExceptions: true
  };

  if (requestOptions && typeof requestOptions.payload !== 'undefined') {
    options.payload = requestOptions.payload;
  }

  if (requestOptions && requestOptions.contentType) {
    options.contentType = requestOptions.contentType;
  }

  return rateLimitAware(function() {
    var response = UrlFetchApp.fetch(url, options);
    var status = response.getResponseCode();
    if (status >= 200 && status < 300) {
      return response;
    }

    var error = new Error('Dropbox API request failed with status ' + status);
    error.status = status;
    try {
      error.headers = response.getAllHeaders();
    } catch (headerError) {
      error.headers = {};
    }
    try {
      error.text = response.getContentText();
      error.body = JSON.parse(error.text);
    } catch (parseError) {}
    throw error;
  }, requestOptions && requestOptions.retryOptions ? requestOptions.retryOptions : {});
}

function __dropboxDirectUpload(accessToken, commitOptions, fileInput) {
  var response = __dropboxFetch('https://content.dropboxapi.com/2/files/upload', {
    method: 'post',
    headers: {
      'Content-Type': 'application/octet-stream',
      'Dropbox-API-Arg': JSON.stringify(commitOptions)
    },
    payload: fileInput.bytes
  }, accessToken);

  return JSON.parse(response.getContentText());
}

function __dropboxChunkedUpload(accessToken, commitOptions, fileInput) {
  var bytes = fileInput.bytes;
  var total = bytes.length;
  var chunkSize = 8 * 1024 * 1024;
  var firstChunkSize = Math.min(chunkSize, total);

  var startResponse = __dropboxFetch('https://content.dropboxapi.com/2/files/upload_session/start', {
    method: 'post',
    headers: {
      'Content-Type': 'application/octet-stream',
      'Dropbox-API-Arg': JSON.stringify({ close: false })
    },
    payload: __sliceBytes(bytes, 0, firstChunkSize)
  }, accessToken);

  var session = JSON.parse(startResponse.getContentText());
  var sessionId = session.session_id;
  var offset = firstChunkSize;

  while (offset + chunkSize < total) {
    var chunk = __sliceBytes(bytes, offset, offset + chunkSize);
    __dropboxFetch('https://content.dropboxapi.com/2/files/upload_session/append_v2', {
      method: 'post',
      headers: {
        'Content-Type': 'application/octet-stream',
        'Dropbox-API-Arg': JSON.stringify({
          cursor: {
            session_id: sessionId,
            offset: offset
          },
          close: false
        })
      },
      payload: chunk
    }, accessToken);
    offset += chunk.length;
  }

  var finishChunk = __sliceBytes(bytes, offset, total);
  var finishResponse = __dropboxFetch('https://content.dropboxapi.com/2/files/upload_session/finish', {
    method: 'post',
    headers: {
      'Content-Type': 'application/octet-stream',
      'Dropbox-API-Arg': JSON.stringify({
        cursor: {
          session_id: sessionId,
          offset: offset
        },
        commit: commitOptions
      })
    },
    payload: finishChunk
  }, accessToken);

  return JSON.parse(finishResponse.getContentText());
}

function __boxFetch(url, requestOptions, accessToken) {
  var headers = {};
  if (requestOptions && requestOptions.headers) {
    for (var key in requestOptions.headers) {
      if (Object.prototype.hasOwnProperty.call(requestOptions.headers, key)) {
        headers[key] = requestOptions.headers[key];
      }
    }
  }
  headers['Authorization'] = 'Bearer ' + accessToken;

  var options = {
    method: requestOptions && requestOptions.method ? requestOptions.method : 'post',
    headers: headers,
    muteHttpExceptions: true
  };

  if (requestOptions && typeof requestOptions.payload !== 'undefined') {
    options.payload = requestOptions.payload;
  }

  if (requestOptions && requestOptions.contentType) {
    options.contentType = requestOptions.contentType;
  }

  if (requestOptions && typeof requestOptions.followRedirects === 'boolean') {
    options.followRedirects = requestOptions.followRedirects;
  }

  return rateLimitAware(function() {
    var response = UrlFetchApp.fetch(url, options);
    var status = response.getResponseCode();
    if (status >= 200 && status < 300) {
      return response;
    }

    var error = new Error('Box API request failed with status ' + status);
    error.status = status;
    try {
      error.headers = response.getAllHeaders();
    } catch (headerError) {
      error.headers = {};
    }
    try {
      error.text = response.getContentText();
      error.body = JSON.parse(error.text);
    } catch (parseError) {}
    throw error;
  }, requestOptions && requestOptions.retryOptions ? requestOptions.retryOptions : {});
}

function __boxDirectUpload(accessToken, parentId, fileInput) {
  var metadataBlob = Utilities.newBlob(JSON.stringify({
    name: fileInput.name,
    parent: { id: parentId }
  }), 'application/json', 'attributes.json');
  var fileBlob = Utilities.newBlob(fileInput.bytes, fileInput.mimeType, fileInput.name);

  var response = __boxFetch('https://upload.box.com/api/2.0/files/content', {
    method: 'post',
    payload: {
      attributes: metadataBlob,
      file: fileBlob
    }
  }, accessToken);

  return JSON.parse(response.getContentText());
}

function __boxChunkedUpload(accessToken, parentId, fileInput) {
  var sessionResponse = __boxFetch('https://upload.box.com/api/2.0/files/upload_sessions', {
    method: 'post',
    headers: {
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      folder_id: parentId,
      file_name: fileInput.name,
      file_size: fileInput.bytes.length
    })
  }, accessToken);

  var session = JSON.parse(sessionResponse.getContentText());
  if (!session || !session.id || !session.session_endpoints) {
    throw new Error('Box upload session response missing required fields.');
  }

  var uploadUrl = session.session_endpoints.upload_part;
  var commitUrl = session.session_endpoints.commit;
  var partSize = session.part_size;
  var parts = [];
  var offset = 0;
  var total = fileInput.bytes.length;

  while (offset < total) {
    var end = Math.min(offset + partSize, total);
    var chunk = __sliceBytes(fileInput.bytes, offset, end);
    var digestBytes = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_1, chunk);
    var digest = Utilities.base64Encode(digestBytes);

    var uploadResponse = __boxFetch(uploadUrl, {
      method: 'put',
      headers: {
        'Content-Type': 'application/octet-stream',
        'Content-Range': 'bytes ' + offset + '-' + (end - 1) + '/' + total,
        'Digest': 'SHA=' + digest
      },
      payload: chunk
    }, accessToken);

    var uploadBody = JSON.parse(uploadResponse.getContentText());
    if (!uploadBody || !uploadBody.part) {
      throw new Error('Box chunk upload did not return part metadata.');
    }
    parts.push(uploadBody.part);
    offset = end;
  }

  var commitResponse = __boxFetch(commitUrl, {
    method: 'post',
    headers: {
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({ parts: parts })
  }, accessToken);

  return JSON.parse(commitResponse.getContentText());
}

function fetchJson(request) {
  var config = request || {};
  if (typeof request === 'string') {
    var legacyOptions = arguments.length > 1 ? (arguments[1] || {}) : {};
    legacyOptions.url = request;
    config = legacyOptions;
  }

  var url = config.url;
  if (!url) {
    throw new Error('fetchJson requires a url');
  }

  var method = config.method || 'GET';
  var headers = config.headers || {};
  var payload = config.payload;
  var contentType = config.contentType || config['contentType'];
  var muteHttpExceptions = config.muteHttpExceptions !== undefined ? config.muteHttpExceptions : true;
  var followRedirects = config.followRedirects;
  var escape = config.escape;
  var start = new Date().getTime();

  var fetchOptions = {
    method: method,
    headers: headers,
    muteHttpExceptions: muteHttpExceptions
  };

  if (typeof payload !== 'undefined') {
    fetchOptions.payload = payload;
  }

  if (typeof contentType !== 'undefined') {
    fetchOptions.contentType = contentType;
  }

  if (typeof followRedirects !== 'undefined') {
    fetchOptions.followRedirects = followRedirects;
  }

  if (typeof escape !== 'undefined') {
    fetchOptions.escape = escape;
  }

  var response = UrlFetchApp.fetch(url, fetchOptions);
  var durationMs = new Date().getTime() - start;
  var status = response.getResponseCode();
  var text = response.getContentText();
  var allHeaders = response.getAllHeaders();
  var normalizedHeaders = __normalizeHeaders(allHeaders);
  var success = status >= 200 && status < 300;

  var logDetails = {
    url: url,
    method: method,
    status: status,
    durationMs: durationMs
  };

  if (!success) {
    logDetails.response = text;
  }

  logStructured(success ? 'INFO' : 'ERROR', success ? 'http_success' : 'http_failure', logDetails);

  var body = text;
  var isJson = false;
  if (normalizedHeaders['content-type'] && normalizedHeaders['content-type'].indexOf('application/json') !== -1) {
    isJson = true;
  }
  if (!isJson && text) {
    var trimmed = text.trim();
    if ((trimmed.charAt(0) === '{' && trimmed.charAt(trimmed.length - 1) === '}') || (trimmed.charAt(0) === '[' && trimmed.charAt(trimmed.length - 1) === ']')) {
      isJson = true;
    }
  }
  if (isJson) {
    try {
      body = text ? JSON.parse(text) : null;
    } catch (error) {
      logWarn('http_parse_failure', { url: url, message: error && error.message ? error.message : String(error) });
    }
  }

  if (!success) {
    var err = new Error('Request failed with status ' + status);
    err.status = status;
    err.headers = allHeaders;
    err.body = body;
    err.text = text;
    throw err;
  }

  return {
    status: status,
    headers: allHeaders,
    body: body,
    text: text
  };
}


var __nodeOutputs = {};
var __executionFlags = {};

function __resetNodeOutputs() {
  __nodeOutputs = {};
}

function __cloneNodeOutput(value) {
  try {
    return JSON.parse(JSON.stringify(value));
  } catch (error) {
    return value;
  }
}

function __storeNodeOutput(nodeId, output) {
  if (!nodeId) {
    return;
  }
  __nodeOutputs[nodeId] = __cloneNodeOutput(output);
}

function __initExecutionFlags() {
  __executionFlags = {};
}

function __activateNode(nodeId) {
  if (!nodeId) {
    return;
  }
  __executionFlags[nodeId] = true;
}

function __completeNode(nodeId) {
  if (!nodeId) {
    return;
  }
  __executionFlags[nodeId] = false;
}

function __shouldExecute(nodeId) {
  return Boolean(__executionFlags[nodeId]);
}

function __bootstrapExecution() {
  __initExecutionFlags();
  var roots = ["incident-trigger"];
  for (var i = 0; i < roots.length; i++) {
    __activateNode(roots[i]);
  }
}

function __normalizeRefPath(path) {
  if (!path || path === '$') {
    return '';
  }
  if (path.indexOf('$.') === 0) {
    return path.slice(2);
  }
  if (path.charAt(0) === '$') {
    return path.slice(1);
  }
  return path;
}

function __getNodeOutputValue(nodeId, path) {
  var output = __nodeOutputs[nodeId];
  if (typeof output === 'undefined') {
    return undefined;
  }
  var normalized = __normalizeRefPath(path);
  if (!normalized) {
    return output;
  }
  var segments = normalized.split('.');
  var value = output;
  for (var i = 0; i < segments.length; i++) {
    var key = segments[i];
    if (value == null) {
      return undefined;
    }
    if (Array.isArray(value)) {
      var index = Number(key);
      if (!isNaN(index)) {
        value = value[index];
        continue;
      }
    }
    value = value[key];
  }
  return value;
}

function interpolate(t, ctx) {
  return String(t).replace(/{{(.*?)}}/g, function(_, k) { return ctx[k.trim()] ?? ''; });
}

function main(ctx) {
  ctx = ctx || {};
  __resetNodeOutputs();
  __bootstrapExecution();
  console.log('🚀 Starting workflow with ${allNodes.length} steps (${supportedNodes.length} native, ${unsupportedNodes.length} fallback)...');

  if (__shouldExecute('incident-trigger')) {
    ctx = step_email_received(ctx);
    __storeNodeOutput('incident-trigger', ctx);
    __completeNode('incident-trigger');
    __activateNode('slack-escalation');
  }


  if (__shouldExecute('slack-escalation')) {
    ctx = step_send_message(ctx);
    __storeNodeOutput('slack-escalation', ctx);
    __completeNode('slack-escalation');
    __activateNode('salesforce-lead');
  }


  if (__shouldExecute('salesforce-lead')) {
    ctx = step_create_lead(ctx);
    __storeNodeOutput('salesforce-lead', ctx);
    __completeNode('salesforce-lead');
    __activateNode('lead-check');
  }


  if (__shouldExecute('lead-check')) {
    var __conditionState = step_lead_created(ctx);
    var __conditionOutput = (__conditionState && __conditionState.output) || {};
    ctx = (__conditionState && __conditionState.context) || ctx;
    __conditionOutput.availableBranches = [{"edgeId":"edge-condition-success","targetId":"success-log","label":"success","value":"true","isDefault":false},{"edgeId":"edge-condition-failure","targetId":"oncall-email","label":"fallback","value":"false","isDefault":false}];
    __storeNodeOutput('lead-check', __conditionOutput);
    __completeNode('lead-check');
    ctx.__lastCondition = __conditionOutput;
    var __branchMap = [{"edgeId":"edge-condition-success","targetId":"success-log","label":"success","value":"true","isDefault":false},{"edgeId":"edge-condition-failure","targetId":"oncall-email","label":"fallback","value":"false","isDefault":false}];
    var __matched = false;
    var __branchValue = __conditionOutput.matchedBranch;
    for (var i = 0; i < __branchMap.length; i++) {
      var __branch = __branchMap[i];
      if (__branch.value && __branch.value === __branchValue) {
        __activateNode(__branch.targetId);
        __conditionOutput.selectedEdgeId = __branch.edgeId;
        __conditionOutput.selectedTargetId = __branch.targetId;
        __matched = true;
      }
    }
    if (!__matched) {
      for (var j = 0; j < __branchMap.length; j++) {
        var __fallback = __branchMap[j];
        if (__fallback.isDefault) {
          __activateNode(__fallback.targetId);
          __conditionOutput.selectedEdgeId = __fallback.edgeId;
          __conditionOutput.selectedTargetId = __fallback.targetId;
          __conditionOutput.matchedBranch = __fallback.value;
          __matched = true;
          break;
        }
      }
    }
    if (!__matched && __branchMap.length === 1) {
      var __single = __branchMap[0];
      __activateNode(__single.targetId);
      __conditionOutput.selectedEdgeId = __single.edgeId;
      __conditionOutput.selectedTargetId = __single.targetId;
      __conditionOutput.matchedBranch = __single.value;
    }
  }


  if (__shouldExecute('success-log')) {
    ctx = step_append_row(ctx);
    __storeNodeOutput('success-log', ctx);
    __completeNode('success-log');
  }


  if (__shouldExecute('oncall-email')) {
    ctx = step_sendEmail(ctx);
    __storeNodeOutput('oncall-email', ctx);
    __completeNode('oncall-email');
  }

  return ctx;
}


function step_sendSlackMessage(ctx) {
  const webhookUrl = getSecret('SLACK_WEBHOOK_URL');
  if (!webhookUrl) {
    logWarn('slack_missing_webhook', { message: 'Slack webhook URL not configured' });
    return ctx;
  }

  const message = interpolate('Escalation: {{subject}} from {{email}}', ctx);
  const channel = '#sev-zero';

  const payload = {
    channel: channel,
    text: message,
    username: 'Apps Script Bot'
  };

  withRetries(() => fetchJson(webhookUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    payload: JSON.stringify(payload),
    contentType: 'application/json'
  }));

  logInfo('slack_message_sent', { channel: channel });

  return ctx;
}

function step_createSalesforceLead(ctx) {
  const accessToken = getSecret('SALESFORCE_ACCESS_TOKEN');
  const instanceUrl = getSecret('SALESFORCE_INSTANCE_URL');

  if (!accessToken || !instanceUrl) {
    logWarn('salesforce_missing_credentials', { message: 'Salesforce credentials not configured' });
    return ctx;
  }

  const leadData = {
    FirstName: interpolate('{{first_name}}', ctx),
    LastName: interpolate('{{last_name}}', ctx),
    Email: interpolate('{{email}}', ctx),
    Company: interpolate('Escalation Holding', ctx)
  };
  
  const response = withRetries(() => fetchJson(`${instanceUrl}/services/data/v52.0/sobjects/Lead`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(leadData),
    contentType: 'application/json'
  }));

  ctx.salesforceLeadId = response.body && response.body.id;
  logInfo('salesforce_create_lead', { leadId: ctx.salesforceLeadId || null });
  return ctx;
}

function step_lead_created(ctx) {
  var context = ctx || {};
  var rule = "!!ctx.salesforceLeadId";
  var evaluations = [];
  var evaluationError = null;
  var rawValue;

  try {
    if (typeof rule === 'boolean') {
      rawValue = rule;
    } else if (typeof rule === 'number') {
      rawValue = rule !== 0;
    } else if (rule && typeof rule === 'object' && typeof rule.value !== 'undefined') {
      rawValue = rule.value;
    } else if (typeof rule === 'string' && rule.trim().length > 0) {
      var sandbox = Object.assign({}, context, {
        params: context,
        parameters: context,
        data: context,
        nodes: __nodeOutputs,
        nodeOutputs: __nodeOutputs
      });
      try {
        rawValue = Function('scope', 'nodeOutputs', 'with(scope) { return (function() { return eval(arguments[0]); }).call(scope, arguments[2]); }')(sandbox, __nodeOutputs, rule);
      } catch (innerError) {
        evaluationError = innerError && innerError.message ? innerError.message : String(innerError);
      }
    } else {
      rawValue = false;
    }
  } catch (error) {
    evaluationError = error && error.message ? error.message : String(error);
  }

  if (typeof rawValue === 'undefined') {
    rawValue = false;
  }

  var resultValue = Boolean(rawValue);
  var matchedBranch = resultValue ? 'true' : 'false';
  evaluations.push({ expression: rule, raw: rawValue, result: resultValue, error: evaluationError });

  var output = {
    expression: rule,
    evaluations: evaluations,
    matchedBranch: matchedBranch,
    availableBranches: [{"edgeId":"edge-condition-success","targetId":"success-log","label":"success","value":"true","isDefault":false},{"edgeId":"edge-condition-failure","targetId":"oncall-email","label":"fallback","value":"false","isDefault":false}],
    error: evaluationError
  };

  return { context: context, output: output };
}


function step_appendRow(ctx) {
  // CRITICAL FIX: Safe spreadsheet access with validation and proper column handling
  const spreadsheetId = 'sev-tracker';
  const sheetName = 'Resolved';
  
  if (!spreadsheetId) {
    console.error('❌ CRITICAL: Spreadsheet ID is required but not provided');
    throw new Error('Spreadsheet ID is required for append_row operation');
  }
  
  try {
    const spreadsheet = SpreadsheetApp.openById(spreadsheetId);
    const sheet = spreadsheet.getSheetByName(sheetName) || spreadsheet.getSheets()[0];
    
    if (!sheet) {
      throw new Error(`Sheet '${sheetName}' not found in spreadsheet`);
    }
    
    // CRITICAL FIX: Handle columns array properly
    const columns = 'Data, Timestamp'.split(', ');
    const timestamp = new Date().toISOString();
    
    // Intelligent row data mapping based on available context
    let rowData = [];
    if (ctx.emails && ctx.emails.length > 0) {
      const email = ctx.emails[0];
      rowData = [
        email.from || 'Unknown',
        email.subject || 'No Subject', 
        email.body || 'No Body',
        'Processed',
        timestamp
      ];
    } else {
      // Generic data extraction
      rowData = [
        ctx.from || ctx.sender || 'Unknown',
        ctx.subject || ctx.title || 'No Subject',
        ctx.body || ctx.content || 'No Body',
        'Processed',
        timestamp
      ];
    }
    
    // Ensure row data matches column count
    while (rowData.length < columns.length) {
      rowData.push('');
    }
    rowData = rowData.slice(0, columns.length);
    
    sheet.appendRow(rowData);
    
    console.log(`✅ Successfully appended row to sheet: ${sheetName}`);
    console.log(`📊 Columns: ${JSON.stringify(columns)}`);
    console.log(`📊 Row data: ${JSON.stringify(rowData)}`);
    return ctx;
  } catch (error) {
    console.error('❌ CRITICAL: Failed to append to spreadsheet:', error.message);
    throw new Error(`Failed to append to spreadsheet: ${error.message}`);
  }
}

function step_sendEmail(ctx) {
  const to = interpolate('oncall@example.com', ctx);
  const subject = interpolate('Manual escalation required for {{subject}}', ctx);
  const body = interpolate('Salesforce failed to create a lead for {{email}}', ctx);
  GmailApp.sendEmail(to, subject, body);
  return ctx;
}

function step_unknown(ctx) {
  Logger.log('Fallback for trigger.gmail:undefined executed');
  return ctx;
}

// BUILD DIAGNOSTICS: Fallback operations
// The following nodes use a generic fallback implementation:
// - incident-trigger: trigger.gmail:email_received (No REAL_OPS implementation)
// To improve, add native handlers to REAL_OPS.



function registerSlackWebhook(callbackUrl, options) {
  logInfo('webhook_register_stub', { connector: 'slack', name: 'Slack', callbackUrl: callbackUrl || null });
  return {
    status: 'stub',
    connector: 'slack',
    name: 'Slack',
    callbackUrl: callbackUrl || null,
    options: options || null
  };
}

function unregisterSlackWebhook(webhookId) {
  logInfo('webhook_unregister_stub', { connector: 'slack', name: 'Slack', webhookId: webhookId || null });
  return {
    status: 'stub',
    connector: 'slack',
    name: 'Slack',
    webhookId: webhookId || null
  };
}


function registerSalesforceWebhook(callbackUrl, options) {
  logInfo('webhook_register_stub', { connector: 'salesforce', name: 'Salesforce', callbackUrl: callbackUrl || null });
  return {
    status: 'stub',
    connector: 'salesforce',
    name: 'Salesforce',
    callbackUrl: callbackUrl || null,
    options: options || null
  };
}

function unregisterSalesforceWebhook(webhookId) {
  logInfo('webhook_unregister_stub', { connector: 'salesforce', name: 'Salesforce', webhookId: webhookId || null });
  return {
    status: 'stub',
    connector: 'salesforce',
    name: 'Salesforce',
    webhookId: webhookId || null
  };
}



function executeGmail:email_received(inputData, params) {
  console.log('📧 Executing Gmail: ' + (params.operation || 'gmail:email_received'));
  
  try {
    const operation = params.operation || 'gmail:email_received';
    
    if (operation === 'email_received' || operation === 'trigger') {
      const query = params.query || 'is:unread';
      const maxResults = params.maxResults || 10;
      
      const threads = GmailApp.search(query, 0, maxResults);
      const emails = [];
      
      threads.forEach(thread => {
        const messages = thread.getMessages();
        messages.forEach(message => {
          emails.push({
            id: message.getId(),
            subject: message.getSubject(),
            from: message.getFrom(),
            date: message.getDate(),
            body: message.getPlainBody(),
            threadId: thread.getId(),
            thread: thread
          });
        });
      });
      
      console.log('📧 Found ' + emails.length + ' emails matching query: ' + query);
      return { ...inputData, emails: emails, emailsFound: emails.length };
    }
    
    if (operation === 'send_reply' || operation === 'reply') {
      const responseTemplate = params.responseTemplate || 'Thank you for your email. We will get back to you soon.';
      const emails = inputData.emails || [];
      let repliesSent = 0;
      
      emails.forEach(email => {
        if (email.thread) {
          // Personalize response with sender name
          const senderName = email.from.split('<')[0].trim() || 'Valued Customer';
          let personalizedResponse = responseTemplate;
          personalizedResponse = personalizedResponse.replace(/{{name}}/g, senderName);
          personalizedResponse = personalizedResponse.replace(/{{subject}}/g, email.subject);
          
          // Send reply
          email.thread.reply(personalizedResponse);
          repliesSent++;
          
          // Mark as processed
          if (params.markAsReplied) {
            const label = GmailApp.getUserLabelByName('Auto-Replied');
            if (label) {
              email.thread.addLabel(label);
            } else {
              email.thread.addLabel(GmailApp.createLabel('Auto-Replied'));
            }
          }
        }
      });
      
      console.log('📧 Sent ' + repliesSent + ' auto-replies');
      return { ...inputData, repliesSent: repliesSent, responseTemplate: responseTemplate };
    }
    
    if (operation === 'send_email') {
      const to = params.to || inputData.to;
      const subject = params.subject || inputData.subject || 'Automated Email';
      const body = params.body || inputData.body || 'Automated message';
      
      if (!to) {
        console.warn('⚠️ Missing recipient email');
        return { ...inputData, gmailError: 'Missing recipient' };
      }
      
      GmailApp.sendEmail(to, subject, body);
      console.log('📧 Email sent to: ' + to);
      return { ...inputData, emailSent: true, recipient: to };
    }
    
    console.log('✅ Gmail operation completed:', operation);
    return { ...inputData, gmailResult: 'success', operation };
  } catch (error) {
    console.error('❌ Gmail error:', error);
    return { ...inputData, gmailError: error.toString() };
  }
}


function executeSlack:send_message(inputData, params) {
  console.log('💬 Executing Slack: Page incident channel');
  
  const operation = params.operation || 'slack:send_message';
  const botToken = getSecret('SLACK_BOT_TOKEN');
  const webhookUrl = getSecret('SLACK_WEBHOOK_URL');
  
  try {
    switch (operation) {
      case 'send_message':
        return handleSendMessage(botToken, webhookUrl, params, inputData);
      case 'send_direct_message':
        return handleSendDirectMessage(botToken, params, inputData);
      case 'create_channel':
        return handleCreateChannel(botToken, params, inputData);
      case 'invite_user_to_channel':
        return handleInviteUser(botToken, params, inputData);
      case 'get_channel_history':
        return handleGetChannelHistory(botToken, params, inputData);
      case 'upload_file':
        return handleUploadFile(botToken, params, inputData);
      case 'add_reaction':
        return handleAddReaction(botToken, params, inputData);
      case 'get_user_info':
        return handleGetUserInfo(botToken, params, inputData);
      case 'list_channels':
        return handleListChannels(botToken, params, inputData);
      case 'set_channel_topic':
        return handleSetChannelTopic(botToken, params, inputData);
      case 'archive_channel':
        return handleArchiveChannel(botToken, params, inputData);
      case 'pin_message':
        return handlePinMessage(botToken, params, inputData);
      case 'schedule_message':
        return handleScheduleMessage(botToken, params, inputData);
      case 'test_connection':
        return handleSlackTestConnection(botToken, webhookUrl, params, inputData);
      case 'message_received':
      case 'mention_received':
        return handleSlackTrigger(botToken, params, inputData);
      default:
        console.warn(`⚠️ Unknown Slack operation: ${operation}`);
        return { ...inputData, slackWarning: `Unsupported operation: ${operation}` };
    }
    
  } catch (error) {
    console.error(`❌ Slack ${operation} failed:`, error);
    return { ...inputData, slackError: error.toString(), slackSuccess: false };
  }
}

function handleSendMessage(botToken, webhookUrl, params, inputData) {
  const channel = params.channel || '#general';
  const text = params.text || params.message || inputData.message || 'Workflow notification';
  const username = params.username || 'Apps Script Bot';
  const iconEmoji = params.icon_emoji || ':robot_face:';
  
  // Try bot token first, then webhook
  if (botToken) {
    const response = UrlFetchApp.fetch('https://slack.com/api/chat.postMessage', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${botToken}`,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify({
        channel: channel,
        text: text,
        username: username,
        icon_emoji: iconEmoji,
        attachments: params.attachments || [],
        blocks: params.blocks || []
      })
    });
    
    const data = JSON.parse(response.getContentText());
    if (data.ok) {
      console.log(`✅ Slack message sent to ${channel}`);
      return { ...inputData, slackSent: true, channel: channel, messageTs: data.ts };
    } else {
      throw new Error(`Slack API error: ${data.error}`);
    }
  } else if (webhookUrl) {
    const response = UrlFetchApp.fetch(webhookUrl, {
      method: 'POST',
      contentType: 'application/json',
      payload: JSON.stringify({
        channel: channel,
        text: text,
        username: username,
        icon_emoji: iconEmoji
      })
    });
    
    if (response.getResponseCode() === 200) {
      console.log(`✅ Slack webhook message sent to ${channel}`);
      return { ...inputData, slackSent: true, channel: channel };
    } else {
      throw new Error(`Webhook failed with status: ${response.getResponseCode()}`);
    }
  } else {
    throw new Error('Neither Slack bot token nor webhook URL is configured');
  }
}

function handleSendDirectMessage(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for direct messages');
  }
  
  const userId = params.userId || params.user;
  const text = params.text || params.message || 'Direct message from automation';
  
  if (!userId) {
    throw new Error('User ID is required for direct message');
  }
  
  const response = UrlFetchApp.fetch('https://slack.com/api/chat.postMessage', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${botToken}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      channel: userId,
      text: text
    })
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    console.log(`✅ Direct message sent to user ${userId}`);
    return { ...inputData, slackDmSent: true, userId: userId, messageTs: data.ts };
  } else {
    throw new Error(`Slack API error: ${data.error}`);
  }
}

function handleCreateChannel(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for channel creation');
  }
  
  const name = params.name || params.channelName;
  const isPrivate = params.is_private || false;
  
  if (!name) {
    throw new Error('Channel name is required');
  }
  
  const response = UrlFetchApp.fetch('https://slack.com/api/conversations.create', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${botToken}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      name: name,
      is_private: isPrivate
    })
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    console.log(`✅ Created Slack channel: #${name}`);
    return { ...inputData, slackChannelCreated: true, channelId: data.channel.id, channelName: name };
  } else {
    throw new Error(`Slack API error: ${data.error}`);
  }
}

function handleInviteUser(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for inviting users');
  }
  
  const channelId = params.channelId || params.channel;
  const userId = params.userId || params.user;
  
  if (!channelId || !userId) {
    throw new Error('Channel ID and User ID are required');
  }
  
  const response = UrlFetchApp.fetch('https://slack.com/api/conversations.invite', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${botToken}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify({
      channel: channelId,
      users: userId
    })
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    console.log(`✅ Invited user ${userId} to channel ${channelId}`);
    return { ...inputData, slackUserInvited: true, channelId: channelId, userId: userId };
  } else {
    throw new Error(`Slack API error: ${data.error}`);
  }
}

function handleGetChannelHistory(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for channel history');
  }
  
  const channelId = params.channelId || params.channel;
  const limit = params.limit || 100;
  
  if (!channelId) {
    throw new Error('Channel ID is required');
  }
  
  const response = UrlFetchApp.fetch(`https://slack.com/api/conversations.history?channel=${channelId}&limit=${limit}`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${botToken}`
    }
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    console.log(`✅ Retrieved ${data.messages.length} messages from channel ${channelId}`);
    return { ...inputData, slackMessages: data.messages, messageCount: data.messages.length };
  } else {
    throw new Error(`Slack API error: ${data.error}`);
  }
}

function handleUploadFile(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for file upload');
  }
  
  const channels = params.channels || params.channel || '#general';
  const title = params.title || 'File from automation';
  const content = params.content || params.fileContent || inputData.fileContent || 'Sample content';
  const filename = params.filename || 'automation-file.txt';
  
  const response = UrlFetchApp.fetch('https://slack.com/api/files.upload', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${botToken}`
    },
    payload: {
      channels: channels,
      title: title,
      filename: filename,
      content: content
    }
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    console.log(`✅ Uploaded file to Slack: ${filename}`);
    return { ...inputData, slackFileUploaded: true, fileId: data.file.id, filename: filename };
  } else {
    throw new Error(`Slack API error: ${data.error}`);
  }
}

function handleListChannels(botToken, params, inputData) {
  if (!botToken) {
    throw new Error('Slack bot token is required for listing channels');
  }
  
  const types = params.types || 'public_channel,private_channel';
  const excludeArchived = params.exclude_archived !== false;
  
  const response = UrlFetchApp.fetch(`https://slack.com/api/conversations.list?types=${types}&exclude_archived=${excludeArchived}`, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${botToken}`
    }
  });
  
  const data = JSON.parse(response.getContentText());
  if (data.ok) {
    const channels = data.channels.map(channel => ({
      id: channel.id,
      name: channel.name,
      isChannel: channel.is_channel,
      isPrivate: channel.is_private,
      isArchived: channel.is_archived,
      memberCount: channel.num_members || 0
    }));
    
    console.log(`✅ Retrieved ${channels.length} Slack channels`);
    return { ...inputData, slackChannels: channels, channelCount: channels.length };
  } else {
    throw new Error(`Slack API error: ${data.error}`);
  }
}

function handleSlackTestConnection(botToken, webhookUrl, params, inputData) {
  try {
    if (botToken) {
      const response = UrlFetchApp.fetch('https://slack.com/api/auth.test', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${botToken}`
        }
      });
      
      const data = JSON.parse(response.getContentText());
      if (data.ok) {
        console.log(`✅ Slack bot token test successful. Team: ${data.team}, User: ${data.user}`);
        return { ...inputData, connectionTest: 'success', team: data.team, user: data.user };
      } else {
        throw new Error(`Bot token test failed: ${data.error}`);
      }
    } else if (webhookUrl) {
      const testResponse = UrlFetchApp.fetch(webhookUrl, {
        method: 'POST',
        contentType: 'application/json',
        payload: JSON.stringify({
          text: 'Connection test from Apps Script',
          username: 'Test Bot'
        })
      });
      
      if (testResponse.getResponseCode() === 200) {
        console.log('✅ Slack webhook test successful');
        return { ...inputData, connectionTest: 'success', method: 'webhook' };
      } else {
        throw new Error(`Webhook test failed: ${testResponse.getResponseCode()}`);
      }
    } else {
      throw new Error('Neither bot token nor webhook URL is configured');
    }
  } catch (error) {
    console.error('❌ Slack connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleSlackTrigger(botToken, params, inputData) {
  // This simulates checking for new messages/mentions
  if (!botToken) {
    console.warn('⚠️ Bot token required for message triggers, using webhook fallback');
    return { ...inputData, slackTrigger: 'simulated', message: 'Trigger detected' };
  }
  
  const channelId = params.channelId || params.channel;
  const keywords = params.keywords || '';
  
  try {
    if (channelId) {
      const response = UrlFetchApp.fetch(`https://slack.com/api/conversations.history?channel=${channelId}&limit=10`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${botToken}`
        }
      });
      
      const data = JSON.parse(response.getContentText());
      if (data.ok && data.messages.length > 0) {
        const recentMessages = data.messages.filter(msg => {
          if (!keywords) return true;
          return msg.text && msg.text.toLowerCase().includes(keywords.toLowerCase());
        });
        
        console.log(`📨 Slack trigger found ${recentMessages.length} matching messages`);
        return { ...inputData, slackTrigger: recentMessages, triggerCount: recentMessages.length };
      }
    }
    
    return { ...inputData, slackTrigger: [], triggerCount: 0 };
  } catch (error) {
    console.error('❌ Slack trigger check failed:', error);
    return { ...inputData, slackTriggerError: error.toString() };
  }
}


function executeSalesforce:create_lead(inputData, params) {
  console.log('☁️ Executing Salesforce: Create critical lead');
  
  const operation = params.operation || 'salesforce:create_lead';
  const accessToken = getSecret('SALESFORCE_ACCESS_TOKEN');
  const instanceUrl = getSecret('SALESFORCE_INSTANCE_URL');
  
  if (!accessToken || !instanceUrl) {
    console.warn('⚠️ Salesforce credentials not configured');
    return { ...inputData, salesforceSkipped: true, error: 'Missing OAuth credentials' };
  }
  
  try {
    switch (operation) {
      case 'query_records':
        return handleQueryRecords(accessToken, instanceUrl, params, inputData);
      case 'create_record':
        return handleCreateRecord(accessToken, instanceUrl, params, inputData);
      case 'update_record':
        return handleUpdateRecord(accessToken, instanceUrl, params, inputData);
      case 'delete_record':
        return handleDeleteRecord(accessToken, instanceUrl, params, inputData);
      case 'get_record':
        return handleGetRecord(accessToken, instanceUrl, params, inputData);
      case 'upsert_record':
        return handleUpsertRecord(accessToken, instanceUrl, params, inputData);
      case 'execute_apex':
        return handleExecuteApex(accessToken, instanceUrl, params, inputData);
      case 'test_connection':
        return handleSalesforceTestConnection(accessToken, instanceUrl, params, inputData);
      case 'record_created':
      case 'record_updated':
        return handleSalesforceTrigger(accessToken, instanceUrl, params, inputData);
      case 'create_lead':
        return handleCreateLead(accessToken, instanceUrl, params, inputData);
      case 'create_contact':
        return handleCreateContact(accessToken, instanceUrl, params, inputData);
      case 'create_opportunity':
        return handleCreateOpportunity(accessToken, instanceUrl, params, inputData);
      default:
        console.warn(`⚠️ Unknown Salesforce operation: ${operation}`);
        return { ...inputData, salesforceWarning: `Unsupported operation: ${operation}` };
    }
    
  } catch (error) {
    console.error(`❌ Salesforce ${operation} failed:`, error);
    return { ...inputData, salesforceError: error.toString(), salesforceSuccess: false };
  }
}

function handleQueryRecords(accessToken, instanceUrl, params, inputData) {
  const soql = params.soql || params.query || 'SELECT Id, Name FROM Account LIMIT 10';
  const endpoint = `/services/data/v58.0/query/?q=${encodeURIComponent(soql)}`;
  
  const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(`✅ Salesforce query returned ${data.totalSize} records`);
    return { ...inputData, salesforceRecords: data.records, totalSize: data.totalSize, done: data.done };
  } else {
    throw new Error(`Query failed: ${response.getResponseCode()}`);
  }
}

function handleCreateRecord(accessToken, instanceUrl, params, inputData) {
  const sobjectType = params.sobjectType || params.objectType || 'Lead';
  const fields = params.fields || {};
  
  const endpoint = `/services/data/v58.0/sobjects/${sobjectType}/`;
  
  const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(fields)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(`✅ Created Salesforce ${sobjectType} record: ${data.id}`);
    return { ...inputData, salesforceCreated: true, recordId: data.id, sobjectType: sobjectType };
  } else {
    throw new Error(`Create failed: ${response.getResponseCode()}`);
  }
}

function handleUpdateRecord(accessToken, instanceUrl, params, inputData) {
  const sobjectType = params.sobjectType || params.objectType || 'Lead';
  const recordId = params.recordId || params.id;
  const fields = params.fields || {};
  
  if (!recordId) {
    throw new Error('Record ID is required for update');
  }
  
  const endpoint = `/services/data/v58.0/sobjects/${sobjectType}/${recordId}`;
  
  const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
    method: 'PATCH',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(fields)
  });
  
  if (response.getResponseCode() === 204) {
    console.log(`✅ Updated Salesforce ${sobjectType} record: ${recordId}`);
    return { ...inputData, salesforceUpdated: true, recordId: recordId, sobjectType: sobjectType };
  } else {
    throw new Error(`Update failed: ${response.getResponseCode()}`);
  }
}

function handleDeleteRecord(accessToken, instanceUrl, params, inputData) {
  const sobjectType = params.sobjectType || params.objectType || 'Lead';
  const recordId = params.recordId || params.id;
  
  if (!recordId) {
    throw new Error('Record ID is required for deletion');
  }
  
  const endpoint = `/services/data/v58.0/sobjects/${sobjectType}/${recordId}`;
  
  const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
    method: 'DELETE',
    headers: {
      'Authorization': `Bearer ${accessToken}`
    }
  });
  
  if (response.getResponseCode() === 204) {
    console.log(`✅ Deleted Salesforce ${sobjectType} record: ${recordId}`);
    return { ...inputData, salesforceDeleted: true, recordId: recordId, sobjectType: sobjectType };
  } else {
    throw new Error(`Delete failed: ${response.getResponseCode()}`);
  }
}

function handleGetRecord(accessToken, instanceUrl, params, inputData) {
  const sobjectType = params.sobjectType || params.objectType || 'Lead';
  const recordId = params.recordId || params.id;
  const fields = params.fields ? params.fields.join(',') : null;
  
  if (!recordId) {
    throw new Error('Record ID is required');
  }
  
  let endpoint = `/services/data/v58.0/sobjects/${sobjectType}/${recordId}`;
  if (fields) {
    endpoint += `?fields=${fields}`;
  }
  
  const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
    method: 'GET',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(`✅ Retrieved Salesforce ${sobjectType} record: ${recordId}`);
    return { ...inputData, salesforceRecord: data, recordId: recordId, sobjectType: sobjectType };
  } else {
    throw new Error(`Get record failed: ${response.getResponseCode()}`);
  }
}

function handleCreateLead(accessToken, instanceUrl, params, inputData) {
  const leadData = {
    FirstName: params.firstName || params.first_name || inputData.firstName || inputData.first_name || '',
    LastName: params.lastName || params.last_name || inputData.lastName || inputData.last_name || 'Unknown',
    Email: params.email || inputData.email || '',
    Company: params.company || inputData.company || 'Unknown Company',
    Phone: params.phone || inputData.phone || '',
    LeadSource: params.leadSource || params.lead_source || 'Website',
    Status: params.status || 'Open - Not Contacted',
    Description: params.description || params.notes || ''
  };
  
  const response = UrlFetchApp.fetch(instanceUrl + '/services/data/v58.0/sobjects/Lead/', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(leadData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(`✅ Created Salesforce Lead: ${data.id}`);
    return { ...inputData, salesforceLeadCreated: true, leadId: data.id, leadData: leadData };
  } else {
    throw new Error(`Create lead failed: ${response.getResponseCode()}`);
  }
}

function handleCreateContact(accessToken, instanceUrl, params, inputData) {
  const contactData = {
    FirstName: params.firstName || params.first_name || inputData.firstName || inputData.first_name || '',
    LastName: params.lastName || params.last_name || inputData.lastName || inputData.last_name || 'Unknown',
    Email: params.email || inputData.email || '',
    Phone: params.phone || inputData.phone || '',
    AccountId: params.accountId || params.account_id || null,
    Description: params.description || params.notes || ''
  };
  
  const response = UrlFetchApp.fetch(instanceUrl + '/services/data/v58.0/sobjects/Contact/', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(contactData)
  });
  
  if (response.getResponseCode() === 201) {
    const data = JSON.parse(response.getContentText());
    console.log(`✅ Created Salesforce Contact: ${data.id}`);
    return { ...inputData, salesforceContactCreated: true, contactId: data.id, contactData: contactData };
  } else {
    throw new Error(`Create contact failed: ${response.getResponseCode()}`);
  }
}

function handleSalesforceTestConnection(accessToken, instanceUrl, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(instanceUrl + '/services/data/', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(`✅ Salesforce connection test successful. Available versions: ${data.length}`);
      return { ...inputData, connectionTest: 'success', availableVersions: data.length, instanceUrl: instanceUrl };
    } else {
      throw new Error(`Test failed: ${response.getResponseCode()}`);
    }
  } catch (error) {
    console.error('❌ Salesforce connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

function handleSalesforceTrigger(accessToken, instanceUrl, params, inputData) {
  // Simulate record monitoring by querying recent records
  const sobjectType = params.sobjectType || 'Lead';
  const timeFilter = params.timeFilter || 'LAST_N_DAYS:1';
  
  const soql = `SELECT Id, Name, CreatedDate FROM ${sobjectType} WHERE CreatedDate >= ${timeFilter} ORDER BY CreatedDate DESC LIMIT 10`;
  const endpoint = `/services/data/v58.0/query/?q=${encodeURIComponent(soql)}`;
  
  try {
    const response = UrlFetchApp.fetch(instanceUrl + endpoint, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(`📊 Salesforce trigger found ${data.totalSize} recent ${sobjectType} records`);
      return { ...inputData, salesforceTrigger: data.records, triggerCount: data.totalSize };
    } else {
      throw new Error(`Trigger query failed: ${response.getResponseCode()}`);
    }
  } catch (error) {
    console.error('❌ Salesforce trigger failed:', error);
    return { ...inputData, salesforceTriggerError: error.toString() };
  }
}


async function executeBranch:lead_created(inputData, params) {
  console.log('🔧 Executing System action: Did Salesforce accept the lead?');
  
  const message = params.message || 'Workflow executed';
  const level = params.level || 'info';
  
  try {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      inputData: Object.keys(inputData),
      nodeType: 'condition.branch'
    };
    
    // Log to Apps Script console
    if (level === 'error') {
      console.error(`[SYSTEM] ${message}`);
    } else if (level === 'warn') {
      console.warn(`[SYSTEM] ${message}`);
    } else {
      console.log(`[SYSTEM] ${message}`);
    }
    
    // Store in PropertiesService for audit trail
    const logs = getSecret('WORKFLOW_LOGS', { defaultValue: '[]' });
    const logArray = JSON.parse(logs);
    logArray.push(logEntry);
    
    // Keep only last 100 logs
    if (logArray.length > 100) {
      logArray.splice(0, logArray.length - 100);
    }
    
    PropertiesService.getScriptProperties().setProperty('WORKFLOW_LOGS', JSON.stringify(logArray));
    
    console.log(`✅ System action completed: ${message}`);
    return { ...inputData, systemLogged: true, logEntry };
    
  } catch (error) {
    console.error('❌ System action failed:', error);
    return { ...inputData, systemError: error.message };
  }
}


  function executeSheets:append_row(inputData, params) {
  console.log('📊 Executing Google Sheets: Log resolved incident');
  
  const spreadsheetId = params.spreadsheetId;
  const operation = params.operation || 'sheets:append_row';
  
  if (!spreadsheetId) {
    console.warn('⚠️ Spreadsheet ID is required for most operations');
  }
  
  try {
    const spreadsheet = spreadsheetId ? SpreadsheetApp.openById(spreadsheetId) : null;
    
    switch (operation) {
      case 'append_row':
        return handleAppendRow(spreadsheet, params, inputData);
      case 'update_cell':
        return handleUpdateCell(spreadsheet, params, inputData);
      case 'update_range':
        return handleUpdateRange(spreadsheet, params, inputData);
      case 'get_values':
        return handleGetValues(spreadsheet, params, inputData);
      case 'clear_range':
        return handleClearRange(spreadsheet, params, inputData);
      case 'create_sheet':
        return handleCreateSheet(spreadsheet, params, inputData);
      case 'delete_sheet':
        return handleDeleteSheet(spreadsheet, params, inputData);
      case 'duplicate_sheet':
        return handleDuplicateSheet(spreadsheet, params, inputData);
      case 'format_cells':
        return handleFormatCells(spreadsheet, params, inputData);
      case 'find_replace':
        return handleFindReplace(spreadsheet, params, inputData);
      case 'sort_range':
        return handleSortRange(spreadsheet, params, inputData);
      case 'test_connection':
        return handleTestConnection(params, inputData);
      default:
        console.warn(`⚠️ Unknown Sheets operation: ${operation}`);
        return { ...inputData, sheetsWarning: `Unsupported operation: ${operation}` };
    }
    
  } catch (error) {
    console.error(`❌ Google Sheets ${operation} failed:`, error);
    return { ...inputData, sheetsError: error.toString(), sheetsSuccess: false };
  }
}

function handleAppendRow(spreadsheet, params, inputData) {
  const sheet = getSheet(spreadsheet, params.sheet || params.sheetName || 'Sheet1');
  const values = params.values || extractRowData(inputData);
  
  if (!Array.isArray(values) || values.length === 0) {
    throw new Error('Values array is required for append operation');
  }
  
  const range = sheet.getRange(sheet.getLastRow() + 1, 1, 1, values.length);
  range.setValues([values]);
  
  console.log(`✅ Appended row to ${sheet.getName()}: ${values.length} columns`);
  return { ...inputData, sheetsAppended: true, rowsAdded: 1, sheetName: sheet.getName() };
}

function handleUpdateCell(spreadsheet, params, inputData) {
  const range = params.range;
  const value = params.value;
  
  if (!range || value === undefined) {
    throw new Error('Range and value are required for cell update');
  }
  
  const cell = spreadsheet.getRange(range);
  cell.setValue(value);
  
  console.log(`✅ Updated cell ${range} with value: ${value}`);
  return { ...inputData, sheetsUpdated: true, updatedRange: range, updatedValue: value };
}

function handleUpdateRange(spreadsheet, params, inputData) {
  const range = params.range;
  const values = params.values;
  
  if (!range || !Array.isArray(values)) {
    throw new Error('Range and values 2D array are required for range update');
  }
  
  const targetRange = spreadsheet.getRange(range);
  targetRange.setValues(values);
  
  console.log(`✅ Updated range ${range} with ${values.length} rows`);
  return { ...inputData, sheetsUpdated: true, updatedRange: range, rowsUpdated: values.length };
}

function handleGetValues(spreadsheet, params, inputData) {
  const range = params.range;
  
  if (!range) {
    throw new Error('Range is required for get values operation');
  }
  
  const targetRange = spreadsheet.getRange(range);
  const values = targetRange.getValues();
  
  console.log(`✅ Retrieved ${values.length} rows from range ${range}`);
  return { ...inputData, sheetsData: values, retrievedRange: range, rowCount: values.length };
}

function handleClearRange(spreadsheet, params, inputData) {
  const range = params.range;
  
  if (!range) {
    throw new Error('Range is required for clear operation');
  }
  
  const targetRange = spreadsheet.getRange(range);
  targetRange.clear();
  
  console.log(`✅ Cleared range ${range}`);
  return { ...inputData, sheetsCleared: true, clearedRange: range };
}

function handleCreateSheet(spreadsheet, params, inputData) {
  const title = params.title || 'New Sheet';
  const index = params.index || undefined;
  
  const newSheet = index !== undefined 
    ? spreadsheet.insertSheet(title, index)
    : spreadsheet.insertSheet(title);
  
  console.log(`✅ Created new sheet: ${title}`);
  return { ...inputData, sheetCreated: true, sheetName: title, sheetId: newSheet.getSheetId() };
}

function handleDeleteSheet(spreadsheet, params, inputData) {
  const sheetName = params.sheetName || params.title;
  
  if (!sheetName) {
    throw new Error('Sheet name is required for delete operation');
  }
  
  const sheet = spreadsheet.getSheetByName(sheetName);
  if (!sheet) {
    throw new Error(`Sheet '${sheetName}' not found`);
  }
  
  spreadsheet.deleteSheet(sheet);
  
  console.log(`✅ Deleted sheet: ${sheetName}`);
  return { ...inputData, sheetDeleted: true, deletedSheetName: sheetName };
}

function handleDuplicateSheet(spreadsheet, params, inputData) {
  const sourceSheetName = params.sourceSheet || 'Sheet1';
  const newSheetName = params.newSheetName || `Copy of ${sourceSheetName}`;
  
  const sourceSheet = spreadsheet.getSheetByName(sourceSheetName);
  if (!sourceSheet) {
    throw new Error(`Source sheet '${sourceSheetName}' not found`);
  }
  
  const duplicatedSheet = sourceSheet.copyTo(spreadsheet);
  duplicatedSheet.setName(newSheetName);
  
  console.log(`✅ Duplicated sheet '${sourceSheetName}' as '${newSheetName}'`);
  return { ...inputData, sheetDuplicated: true, newSheetName: newSheetName, sourceSheetName: sourceSheetName };
}

function handleFormatCells(spreadsheet, params, inputData) {
  const range = params.range;
  const format = params.format || {};
  
  if (!range) {
    throw new Error('Range is required for formatting');
  }
  
  const targetRange = spreadsheet.getRange(range);
  
  // Apply formatting options
  if (format.backgroundColor) targetRange.setBackground(format.backgroundColor);
  if (format.fontColor) targetRange.setFontColor(format.fontColor);
  if (format.fontSize) targetRange.setFontSize(format.fontSize);
  if (format.fontWeight) targetRange.setFontWeight(format.fontWeight);
  if (format.numberFormat) targetRange.setNumberFormat(format.numberFormat);
  if (format.horizontalAlignment) targetRange.setHorizontalAlignment(format.horizontalAlignment);
  if (format.verticalAlignment) targetRange.setVerticalAlignment(format.verticalAlignment);
  
  console.log(`✅ Formatted range ${range}`);
  return { ...inputData, sheetsFormatted: true, formattedRange: range };
}

function handleFindReplace(spreadsheet, params, inputData) {
  const findText = params.findText;
  const replaceText = params.replaceText || '';
  const sheetName = params.sheetName;
  
  if (!findText) {
    throw new Error('Find text is required for find/replace operation');
  }
  
  let targetSheet;
  if (sheetName) {
    targetSheet = spreadsheet.getSheetByName(sheetName);
    if (!targetSheet) {
      throw new Error(`Sheet '${sheetName}' not found`);
    }
  } else {
    targetSheet = spreadsheet.getActiveSheet();
  }
  
  const textFinder = targetSheet.createTextFinder(findText);
  const replacements = textFinder.replaceAllWith(replaceText);
  
  console.log(`✅ Replaced ${replacements} instances of '${findText}' with '${replaceText}'`);
  return { ...inputData, sheetsReplaced: true, replacements: replacements, findText: findText, replaceText: replaceText };
}

function handleSortRange(spreadsheet, params, inputData) {
  const range = params.range;
  const sortColumn = params.sortColumn || 1;
  const ascending = params.ascending !== false;
  
  if (!range) {
    throw new Error('Range is required for sort operation');
  }
  
  const targetRange = spreadsheet.getRange(range);
  targetRange.sort({ column: sortColumn, ascending: ascending });
  
  console.log(`✅ Sorted range ${range} by column ${sortColumn} (${ascending ? 'ascending' : 'descending'})`);
  return { ...inputData, sheetsSorted: true, sortedRange: range, sortColumn: sortColumn };
}

function handleTestConnection(params, inputData) {
  try {
    // Test by accessing SpreadsheetApp
    const user = Session.getActiveUser().getEmail();
    console.log(`✅ Google Sheets connection test successful. User: ${user}`);
    return { ...inputData, connectionTest: 'success', userEmail: user };
  } catch (error) {
    console.error('❌ Sheets connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}

// Helper functions
function getSheet(spreadsheet, sheetNameOrRange) {
  if (!spreadsheet) throw new Error('Spreadsheet is required');
  
  let sheetName = sheetNameOrRange;
  if (sheetNameOrRange.includes('!')) {
    sheetName = sheetNameOrRange.split('!')[0];
  }
  
  const sheet = spreadsheet.getSheetByName(sheetName);
  if (!sheet) {
    throw new Error(`Sheet '${sheetName}' not found`);
  }
  
  return sheet;
}

function extractRowData(inputData) {
  // Extract meaningful data from various input formats
  if (inputData.emails && Array.isArray(inputData.emails) && inputData.emails.length > 0) {
    const email = inputData.emails[0];
    return [email.subject || '', email.from || '', email.date || new Date(), email.body || ''];
  } else if (inputData.formResponses && Array.isArray(inputData.formResponses) && inputData.formResponses.length > 0) {
    const response = inputData.formResponses[0];
    return Object.values(response.answers || {});
  } else if (inputData.shopifyResult && inputData.shopifyResult.customer) {
    const customer = inputData.shopifyResult.customer;
    return [customer.first_name || '', customer.last_name || '', customer.email || '', customer.phone || ''];
  } else {
    // Generic extraction
    const values = [];
    ['name', 'email', 'phone', 'company', 'subject', 'message', 'date'].forEach(key => {
      if (inputData[key] !== undefined) {
        values.push(inputData[key]);
      }
    });
    return values.length > 0 ? values : ['Data from workflow', new Date().toString()];
  }
}


function executeGmail:sendEmail(inputData, params) {
  console.log('📧 Executing Gmail: ' + (params.operation || 'gmail:sendEmail'));
  
  try {
    const operation = params.operation || 'gmail:sendEmail';
    
    if (operation === 'email_received' || operation === 'trigger') {
      const query = params.query || 'is:unread';
      const maxResults = params.maxResults || 10;
      
      const threads = GmailApp.search(query, 0, maxResults);
      const emails = [];
      
      threads.forEach(thread => {
        const messages = thread.getMessages();
        messages.forEach(message => {
          emails.push({
            id: message.getId(),
            subject: message.getSubject(),
            from: message.getFrom(),
            date: message.getDate(),
            body: message.getPlainBody(),
            threadId: thread.getId(),
            thread: thread
          });
        });
      });
      
      console.log('📧 Found ' + emails.length + ' emails matching query: ' + query);
      return { ...inputData, emails: emails, emailsFound: emails.length };
    }
    
    if (operation === 'send_reply' || operation === 'reply') {
      const responseTemplate = params.responseTemplate || 'Thank you for your email. We will get back to you soon.';
      const emails = inputData.emails || [];
      let repliesSent = 0;
      
      emails.forEach(email => {
        if (email.thread) {
          // Personalize response with sender name
          const senderName = email.from.split('<')[0].trim() || 'Valued Customer';
          let personalizedResponse = responseTemplate;
          personalizedResponse = personalizedResponse.replace(/{{name}}/g, senderName);
          personalizedResponse = personalizedResponse.replace(/{{subject}}/g, email.subject);
          
          // Send reply
          email.thread.reply(personalizedResponse);
          repliesSent++;
          
          // Mark as processed
          if (params.markAsReplied) {
            const label = GmailApp.getUserLabelByName('Auto-Replied');
            if (label) {
              email.thread.addLabel(label);
            } else {
              email.thread.addLabel(GmailApp.createLabel('Auto-Replied'));
            }
          }
        }
      });
      
      console.log('📧 Sent ' + repliesSent + ' auto-replies');
      return { ...inputData, repliesSent: repliesSent, responseTemplate: responseTemplate };
    }
    
    if (operation === 'send_email') {
      const to = params.to || inputData.to;
      const subject = params.subject || inputData.subject || 'Automated Email';
      const body = params.body || inputData.body || 'Automated message';
      
      if (!to) {
        console.warn('⚠️ Missing recipient email');
        return { ...inputData, gmailError: 'Missing recipient' };
      }
      
      GmailApp.sendEmail(to, subject, body);
      console.log('📧 Email sent to: ' + to);
      return { ...inputData, emailSent: true, recipient: to };
    }
    
    console.log('✅ Gmail operation completed:', operation);
    return { ...inputData, gmailResult: 'success', operation };
  } catch (error) {
    console.error('❌ Gmail error:', error);
    return { ...inputData, gmailError: error.toString() };
  }
}