
/**
 * Generated by Apps Script Studio - Intelligent Workflow
 * Prompt: Every night create an Asana task for outstanding documents and backfill a Trello card if Asana fails
 * Nodes: 5 | Edges: 4
 * Automation Type: project_management
 */



var __HTTP_RETRY_DEFAULTS = {
  maxAttempts: 5,
  initialDelayMs: 500,
  backoffFactor: 2,
  maxDelayMs: 60000
};

function logStructured(level, event, details) {
  var payload = {
    level: level,
    event: event,
    details: details || {},
    timestamp: new Date().toISOString()
  };
  var message = '[' + payload.level + '] ' + payload.event + ' ' + JSON.stringify(payload.details);
  if (level === 'ERROR') {
    console.error(message);
  } else if (level === 'WARN') {
    console.warn(message);
  } else {
    console.log(message);
  }
}

function logInfo(event, details) {
  logStructured('INFO', event, details);
}

function logWarn(event, details) {
  logStructured('WARN', event, details);
}

function logError(event, details) {
  logStructured('ERROR', event, details);
}

var __TRIGGER_REGISTRY_KEY = '__studio_trigger_registry__';

function __loadTriggerRegistry() {
  try {
    var raw = PropertiesService.getScriptProperties().getProperty(__TRIGGER_REGISTRY_KEY);
    if (!raw) {
      return {};
    }
    var parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object') {
      return parsed;
    }
  } catch (error) {
    logWarn('trigger_registry_parse_failed', {
      message: error && error.message ? error.message : String(error)
    });
  }
  return {};
}

function __saveTriggerRegistry(registry) {
  try {
    PropertiesService.getScriptProperties().setProperty(
      __TRIGGER_REGISTRY_KEY,
      JSON.stringify(registry || {})
    );
  } catch (error) {
    logError('trigger_registry_save_failed', {
      message: error && error.message ? error.message : String(error)
    });
  }
}

function __findTriggerById(triggerId) {
  if (!triggerId) {
    return null;
  }
  var triggers = ScriptApp.getProjectTriggers();
  for (var i = 0; i < triggers.length; i++) {
    var trigger = triggers[i];
    if (!trigger) {
      continue;
    }
    if (typeof trigger.getUniqueId === 'function' && trigger.getUniqueId() === triggerId) {
      return trigger;
    }
  }
  return null;
}

function __ensureTrigger(triggerKey, handler, type, builderFn, description) {
  var registry = __loadTriggerRegistry();
  var entry = registry[triggerKey];
  if (entry) {
    var existing = __findTriggerById(entry.id);
    if (existing) {
      logInfo('trigger_exists', { key: triggerKey, handler: handler, type: type });
      return { key: triggerKey, triggerId: entry.id, handler: handler, type: type };
    }
    logWarn('trigger_missing_recreating', { key: triggerKey, handler: handler, type: type });
  }

  try {
    var trigger = builderFn();
    var triggerId = trigger && typeof trigger.getUniqueId === 'function' ? trigger.getUniqueId() : null;
    registry[triggerKey] = {
      id: triggerId,
      handler: handler,
      type: type,
      description: description || null,
      updatedAt: new Date().toISOString()
    };
    __saveTriggerRegistry(registry);
    logInfo('trigger_created', { key: triggerKey, handler: handler, type: type, description: description || null });
    return { key: triggerKey, triggerId: triggerId, handler: handler, type: type };
  } catch (error) {
    logError('trigger_create_failed', {
      key: triggerKey,
      handler: handler,
      type: type,
      message: error && error.message ? error.message : String(error)
    });
    throw error;
  }
}

function __createEphemeralTrigger(triggerKey, handler, type, builderFn, description) {
  try {
    var trigger = builderFn();
    var triggerId = trigger && typeof trigger.getUniqueId === 'function' ? trigger.getUniqueId() : null;
    logInfo('trigger_created', {
      key: triggerKey,
      handler: handler,
      type: type,
      ephemeral: true,
      description: description || null
    });
    return { key: triggerKey, triggerId: triggerId, handler: handler, type: type };
  } catch (error) {
    logError('trigger_create_failed', {
      key: triggerKey,
      handler: handler,
      type: type,
      ephemeral: true,
      message: error && error.message ? error.message : String(error)
    });
    throw error;
  }
}

function syncTriggerRegistry(activeKeys) {
  var registry = __loadTriggerRegistry();
  var keep = {};
  if (Array.isArray(activeKeys)) {
    for (var i = 0; i < activeKeys.length; i++) {
      keep[activeKeys[i]] = true;
    }
  }
  var triggers = ScriptApp.getProjectTriggers();
  var changed = false;

  for (var key in registry) {
    if (!keep[key]) {
      var entry = registry[key];
      var triggerId = entry && entry.id;
      if (triggerId) {
        for (var j = 0; j < triggers.length; j++) {
          var trigger = triggers[j];
          if (trigger && typeof trigger.getUniqueId === 'function' && trigger.getUniqueId() === triggerId) {
            ScriptApp.deleteTrigger(trigger);
            break;
          }
        }
      }
      delete registry[key];
      changed = true;
      logInfo('trigger_removed', { key: key });
    }
  }

  if (changed) {
    __saveTriggerRegistry(registry);
  }
}

function clearTriggerByKey(triggerKey) {
  if (!triggerKey) {
    return;
  }
  var registry = __loadTriggerRegistry();
  var entry = registry[triggerKey];
  if (!entry) {
    return;
  }
  var triggerId = entry.id;
  var trigger = triggerId ? __findTriggerById(triggerId) : null;
  if (trigger) {
    ScriptApp.deleteTrigger(trigger);
  }
  delete registry[triggerKey];
  __saveTriggerRegistry(registry);
  logInfo('trigger_cleared', { key: triggerKey });
}

function buildTimeTrigger(config) {
  config = config || {};
  var handler = config.handler || 'main';
  var triggerKey = config.key || handler + ':' + (config.frequency || 'time');
  var description = config.description || null;

  function builder() {
    var timeBuilder = ScriptApp.newTrigger(handler).timeBased();
    if (config.runAt) {
      return timeBuilder.at(new Date(config.runAt)).create();
    }
    if (config.everyMinutes) {
      timeBuilder.everyMinutes(Number(config.everyMinutes) || 1);
    } else if (config.everyHours) {
      timeBuilder.everyHours(Number(config.everyHours) || 1);
    } else if (config.everyDays) {
      timeBuilder.everyDays(Number(config.everyDays) || 1);
    } else if (config.everyWeeks) {
      timeBuilder.everyWeeks(Number(config.everyWeeks) || 1);
    }
    if (typeof config.atHour === 'number' && typeof timeBuilder.atHour === 'function') {
      timeBuilder.atHour(config.atHour);
    }
    if (typeof config.nearMinute === 'number' && typeof timeBuilder.nearMinute === 'function') {
      timeBuilder.nearMinute(config.nearMinute);
    }
    if (typeof config.onMonthDay === 'number' && typeof timeBuilder.onMonthDay === 'function') {
      timeBuilder.onMonthDay(config.onMonthDay);
    }
    if (config.onWeekDay) {
      var weekDay = config.onWeekDay;
      if (typeof weekDay === 'string') {
        weekDay = ScriptApp.WeekDay[weekDay] || ScriptApp.WeekDay.MONDAY;
      }
      if (weekDay) {
        timeBuilder.onWeekDay(weekDay);
      }
    }
    return timeBuilder.create();
  }

  if (config.ephemeral) {
    return __createEphemeralTrigger(triggerKey, handler, 'time', builder, description);
  }

  return __ensureTrigger(triggerKey, handler, 'time', builder, description);
}

function buildPollingWrapper(triggerKey, executor) {
  var stats = { processed: 0 };
  logInfo('trigger_poll_start', { key: triggerKey });
  var runtime = {
    dispatch: function (payload) {
      try {
        main(payload || {});
        stats.processed += 1;
      } catch (error) {
        logError('trigger_dispatch_failed', {
          key: triggerKey,
          message: error && error.message ? error.message : String(error)
        });
        throw error;
      }
    },
    summary: function (partial) {
      if (!partial || typeof partial !== 'object') {
        return;
      }
      for (var key in partial) {
        stats[key] = partial[key];
      }
    }
  };

  try {
    var result = executor(runtime);
    if (result && typeof result === 'object') {
      runtime.summary(result);
    }
    logInfo('trigger_poll_success', { key: triggerKey, stats: stats });
    return stats;
  } catch (error) {
    logError('trigger_poll_error', {
      key: triggerKey,
      message: error && error.message ? error.message : String(error)
    });
    throw error;
  }
}

var __SECRET_HELPER_OVERRIDES =
  typeof SECRET_HELPER_OVERRIDES !== 'undefined' && SECRET_HELPER_OVERRIDES
    ? SECRET_HELPER_OVERRIDES
    : {};
var __SECRET_VAULT_EXPORT_CACHE = null;
var __SECRET_VAULT_EXPORT_PARSED = false;
var __APPS_SCRIPT_SECRET_PREFIX = 'AS1.';
var __APPS_SCRIPT_SECRET_STREAM_INFO_BYTES = null;
var __APPS_SCRIPT_SECRET_METADATA_INFO_BYTES = null;

function __coerceSecretArray(value) {
  if (!value) {
    return [];
  }
  if (Array.isArray(value)) {
    return value.filter(function (item) {
      return typeof item === 'string' && item.trim().length > 0;
    });
  }
  if (typeof value === 'string' && value.trim().length > 0) {
    return [value.trim()];
  }
  return [];
}

function __loadVaultExports() {
  if (__SECRET_VAULT_EXPORT_PARSED) {
    return __SECRET_VAULT_EXPORT_CACHE;
  }
  __SECRET_VAULT_EXPORT_PARSED = true;

  var scriptProps = PropertiesService.getScriptProperties();
  var raw =
    scriptProps.getProperty('__VAULT_EXPORTS__') ||
    scriptProps.getProperty('VAULT_EXPORTS_JSON') ||
    scriptProps.getProperty('VAULT_EXPORTS');

  if (!raw) {
    __SECRET_VAULT_EXPORT_CACHE = {};
    return __SECRET_VAULT_EXPORT_CACHE;
  }

  try {
    var parsed = JSON.parse(raw);
    if (parsed && typeof parsed === 'object') {
      if (parsed.secrets && typeof parsed.secrets === 'object') {
        __SECRET_VAULT_EXPORT_CACHE = parsed.secrets;
      } else {
        __SECRET_VAULT_EXPORT_CACHE = parsed;
      }
    } else {
      __SECRET_VAULT_EXPORT_CACHE = {};
    }
  } catch (error) {
    logWarn('vault_exports_parse_failed', { message: error && error.message ? error.message : String(error) });
    __SECRET_VAULT_EXPORT_CACHE = {};
  }

  return __SECRET_VAULT_EXPORT_CACHE;
}

function __stringToBytes(value) {
  return Utilities.newBlob(value || '', 'text/plain').getBytes();
}

function __ensureSecretConstants() {
  if (!__APPS_SCRIPT_SECRET_STREAM_INFO_BYTES) {
    __APPS_SCRIPT_SECRET_STREAM_INFO_BYTES = __stringToBytes('apps-script-secret-stream-v1');
  }
  if (!__APPS_SCRIPT_SECRET_METADATA_INFO_BYTES) {
    __APPS_SCRIPT_SECRET_METADATA_INFO_BYTES = __stringToBytes('apps-script-secret-metadata-v1');
  }
}

function __concatByteArrays(chunks) {
  var total = 0;
  for (var i = 0; i < chunks.length; i++) {
    var chunk = chunks[i];
    if (chunk && chunk.length) {
      total += chunk.length;
    }
  }
  var result = new Array(total);
  var offset = 0;
  for (var j = 0; j < chunks.length; j++) {
    var segment = chunks[j];
    if (!segment) {
      continue;
    }
    for (var k = 0; k < segment.length; k++) {
      result[offset++] = segment[k];
    }
  }
  return result;
}

function __numberToUint32Bytes(value) {
  return [
    (value >>> 24) & 0xff,
    (value >>> 16) & 0xff,
    (value >>> 8) & 0xff,
    value & 0xff,
  ];
}

function __bytesToHex(bytes) {
  var hex = '';
  for (var i = 0; i < bytes.length; i++) {
    var piece = (bytes[i] & 0xff).toString(16);
    if (piece.length < 2) {
      piece = '0' + piece;
    }
    hex += piece;
  }
  return hex;
}

function __bytesToString(bytes) {
  return Utilities.newBlob(bytes, 'application/octet-stream').getDataAsString('utf-8');
}

function __constantTimeEqualsHex(a, b) {
  if (typeof a !== 'string' || typeof b !== 'string' || a.length !== b.length) {
    return false;
  }
  var result = 0;
  for (var i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  return result === 0;
}

function __deriveSecretKeystream(sharedKeyBytes, ivBytes, length) {
  __ensureSecretConstants();
  var blockSize = 32;
  var blocks = Math.ceil(length / blockSize);
  var output = new Array(blocks * blockSize);

  for (var i = 0; i < blocks; i++) {
    var counterBytes = __numberToUint32Bytes(i);
    var digest = Utilities.computeHmacSha256(
      __concatByteArrays([ivBytes, counterBytes, __APPS_SCRIPT_SECRET_STREAM_INFO_BYTES]),
      sharedKeyBytes
    );
    for (var j = 0; j < digest.length; j++) {
      output[i * blockSize + j] = digest[j];
    }
  }

  output.length = length;
  return output;
}

function __decodeAppsScriptSecret(value) {
  if (typeof value !== 'string' || value.indexOf(__APPS_SCRIPT_SECRET_PREFIX) !== 0) {
    return null;
  }

  var encoded = value.substring(__APPS_SCRIPT_SECRET_PREFIX.length);
  var tokenBytes = Utilities.base64Decode(encoded);
  var tokenJson = __bytesToString(tokenBytes);
  var token;

  try {
    token = JSON.parse(tokenJson);
  } catch (error) {
    throw new Error('Failed to parse sealed credential token: ' + error);
  }

  if (!token || typeof token !== 'object' || token.version !== 1) {
    throw new Error('Unrecognized sealed credential token format.');
  }

  var now = Date.now();
  if (typeof token.expiresAt === 'number' && now > token.expiresAt) {
    throw new Error('Credential token for ' + (token.purpose || 'credential') + ' has expired.');
  }

  var sharedKeyBytes = Utilities.base64Decode(token.sharedKey);
  var ivBytes = Utilities.base64Decode(token.iv);
  var ciphertextBytes = Utilities.base64Decode(token.ciphertext);

  __ensureSecretConstants();
  var macInput = __concatByteArrays([
    __APPS_SCRIPT_SECRET_METADATA_INFO_BYTES,
    ivBytes,
    ciphertextBytes,
    __stringToBytes(String(token.issuedAt)),
    __stringToBytes(String(token.expiresAt)),
    __stringToBytes(token.purpose || ''),
  ]);

  var macBytes = Utilities.computeHmacSha256(macInput, sharedKeyBytes);
  var macHex = __bytesToHex(macBytes);
  if (!__constantTimeEqualsHex(macHex, token.hmac)) {
    throw new Error('Credential token integrity check failed for ' + (token.purpose || 'credential') + '.');
  }

  var keystream = __deriveSecretKeystream(sharedKeyBytes, ivBytes, ciphertextBytes.length);
  var plaintextBytes = new Array(ciphertextBytes.length);
  for (var i = 0; i < ciphertextBytes.length; i++) {
    plaintextBytes[i] = ciphertextBytes[i] ^ keystream[i];
  }

  var payloadString = __bytesToString(plaintextBytes);
  var sealedPayload;
  try {
    sealedPayload = JSON.parse(payloadString);
  } catch (error) {
    throw new Error('Failed to decode sealed credential payload: ' + error);
  }

  if (
    !sealedPayload ||
    typeof sealedPayload !== 'object' ||
    sealedPayload.issuedAt !== token.issuedAt ||
    sealedPayload.expiresAt !== token.expiresAt ||
    (sealedPayload.purpose || null) !== (token.purpose || null)
  ) {
    throw new Error('Credential token metadata mismatch for ' + (token.purpose || 'credential') + '.');
  }

  return {
    payload: sealedPayload.payload,
    issuedAt: token.issuedAt,
    expiresAt: token.expiresAt,
    purpose: token.purpose || null,
  };
}

function getSecret(propertyName, opts) {
  var options = opts || {};
  var key = typeof propertyName === 'string' ? propertyName.trim() : '';

  if (!key) {
    throw new Error('getSecret requires a propertyName');
  }

  var connectorKey = options.connectorKey || options.connector || null;
  if (!connectorKey) {
    var normalizedKey = key.replace(/^_+/, '');
    var underscoreIndex = normalizedKey.indexOf('_');
    if (underscoreIndex > 0) {
      connectorKey = normalizedKey.substring(0, underscoreIndex).toLowerCase();
    }
  }
  var candidates = [];
  var seen = {};

  function pushCandidate(name) {
    if (!name || typeof name !== 'string') {
      return;
    }
    var trimmed = name.trim();
    if (!trimmed || seen[trimmed]) {
      return;
    }
    seen[trimmed] = true;
    candidates.push(trimmed);
  }

  pushCandidate(key);

  var defaultOverrides = (__SECRET_HELPER_OVERRIDES.defaults && __SECRET_HELPER_OVERRIDES.defaults[key]) || null;
  var connectorOverrides =
    (connectorKey &&
      __SECRET_HELPER_OVERRIDES.connectors &&
      __SECRET_HELPER_OVERRIDES.connectors[connectorKey] &&
      __SECRET_HELPER_OVERRIDES.connectors[connectorKey][key]) ||
    null;

  __coerceSecretArray(defaultOverrides && defaultOverrides.aliases).forEach(pushCandidate);
  __coerceSecretArray(connectorOverrides && connectorOverrides.aliases).forEach(pushCandidate);
  __coerceSecretArray(options.aliases || options.alias).forEach(pushCandidate);

  if (defaultOverrides && defaultOverrides.mapTo) {
    pushCandidate(defaultOverrides.mapTo);
  }
  if (connectorOverrides && connectorOverrides.mapTo) {
    pushCandidate(connectorOverrides.mapTo);
  }
  if (options.mapTo) {
    pushCandidate(options.mapTo);
  }

  var scriptProps = PropertiesService.getScriptProperties();
  var resolvedKey = null;
  var value = null;
  var source = null;

  for (var i = 0; i < candidates.length; i++) {
    var candidate = candidates[i];
    var candidateValue = scriptProps.getProperty(candidate);
    if (candidateValue !== null && candidateValue !== undefined && String(candidateValue).trim() !== '') {
      resolvedKey = candidate;
      value = candidateValue;
      source = 'script_properties';
      break;
    }
  }

  if (value === null) {
    var vaultSecrets = __loadVaultExports();
    if (vaultSecrets && typeof vaultSecrets === 'object') {
      for (var j = 0; j < candidates.length; j++) {
        var vaultKey = candidates[j];
        if (vaultSecrets.hasOwnProperty(vaultKey) && vaultSecrets[vaultKey] !== undefined && vaultSecrets[vaultKey] !== null) {
          resolvedKey = vaultKey;
          value = String(vaultSecrets[vaultKey]);
          source = 'vault_exports';
          break;
        }
      }
    }
  }

  if (value === null && defaultOverrides && defaultOverrides.defaultValue !== undefined) {
    value = defaultOverrides.defaultValue;
    source = 'default_override';
    resolvedKey = key;
  }

  if (value === null && connectorOverrides && connectorOverrides.defaultValue !== undefined) {
    value = connectorOverrides.defaultValue;
    source = 'connector_override';
    resolvedKey = key;
  }

  if (value === null && options.defaultValue !== undefined) {
    value = options.defaultValue;
    source = 'default_option';
    resolvedKey = key;
  }

  if (value === null || value === undefined || String(value).trim() === '') {
    logError('secret_missing', {
      property: key,
      connectorKey: connectorKey || null,
      triedKeys: candidates
    });
    throw new Error('Missing required secret "' + key + '"');
  }

  if (options.logResolved) {
    logInfo('secret_resolved', {
      property: key,
      connectorKey: connectorKey || null,
      resolvedKey: resolvedKey,
      source: source
    });
  }

  if (typeof value === 'string') {
    var sealed = __decodeAppsScriptSecret(value);
    if (sealed) {
      if (options.logResolved) {
        logInfo('sealed_secret_validated', {
          property: key,
          connector: connectorKey || null,
          purpose: sealed.purpose,
          expiresAt: new Date(sealed.expiresAt).toISOString(),
        });
      }
      value = sealed.payload;
    }
  }

  return value;
}

function withRetries(fn, options) {
  var config = options || {};
  var maxAttempts = config.maxAttempts || __HTTP_RETRY_DEFAULTS.maxAttempts;
  var initialDelayMs = config.initialDelayMs || __HTTP_RETRY_DEFAULTS.initialDelayMs;
  var backoffFactor = config.backoffFactor || __HTTP_RETRY_DEFAULTS.backoffFactor;
  var maxDelayMs = config.maxDelayMs || __HTTP_RETRY_DEFAULTS.maxDelayMs;
  var attempt = 0;
  var delay = initialDelayMs;

  while (true) {
    try {
      return fn(attempt + 1);
    } catch (error) {
      attempt++;
      var message = error && error.message ? error.message : String(error);
      if (attempt >= maxAttempts) {
        logError('http_retry_exhausted', { attempts: attempt, message: message });
        throw error;
      }
      logWarn('http_retry', { attempt: attempt, delayMs: delay, message: message });
      Utilities.sleep(delay);
      delay = Math.min(delay * backoffFactor, maxDelayMs);
    }
  }
}

function fetchJson(url, requestOptions) {
  var options = requestOptions || {};
  var method = options.method || 'GET';
  var headers = options.headers || {};
  var payload = options.payload;
  var contentType = options.contentType || options['contentType'];
  var muteHttpExceptions = options.muteHttpExceptions !== undefined ? options.muteHttpExceptions : true;
  var followRedirects = options.followRedirects;
  var start = new Date().getTime();

  var fetchOptions = {
    method: method,
    headers: headers,
    muteHttpExceptions: muteHttpExceptions
  };

  if (typeof payload !== 'undefined') {
    fetchOptions.payload = payload;
  }

  if (typeof contentType !== 'undefined') {
    fetchOptions.contentType = contentType;
  }

  if (typeof followRedirects !== 'undefined') {
    fetchOptions.followRedirects = followRedirects;
  }

  if (options.escape !== undefined) {
    fetchOptions.escape = options.escape;
  }

  var response = UrlFetchApp.fetch(url, fetchOptions);
  var durationMs = new Date().getTime() - start;
  var status = response.getResponseCode();
  var text = response.getContentText();
  var allHeaders = response.getAllHeaders();
  var success = status >= 200 && status < 300;

  var logDetails = {
    url: url,
    method: method,
    status: status,
    durationMs: durationMs
  };

  if (!success) {
    logDetails.response = text;
  }

  logStructured(success ? 'INFO' : 'ERROR', success ? 'http_success' : 'http_failure', logDetails);

  var responseContentType = '';
  if (allHeaders['Content-Type']) {
    responseContentType = String(allHeaders['Content-Type']).toLowerCase();
  } else if (allHeaders['content-type']) {
    responseContentType = String(allHeaders['content-type']).toLowerCase();
  }

  var body = text;
  if (responseContentType.indexOf('application/json') !== -1) {
    try {
      body = text ? JSON.parse(text) : null;
    } catch (error) {
      logWarn('http_parse_failure', { url: url, message: error && error.message ? error.message : String(error) });
    }
  }

  if (!success) {
    var err = new Error('Request failed with status ' + status);
    var errorWithDetails = err;
    errorWithDetails.status = status;
    errorWithDetails.body = body;
    errorWithDetails.text = text;
    errorWithDetails.headers = allHeaders;
    throw errorWithDetails;
  }

  return {
    ok: success,
    status: status,
    headers: allHeaders,
    body: body,
    text: text
  };
}


var __nodeOutputs = {};
var __executionFlags = {};

function __resetNodeOutputs() {
  __nodeOutputs = {};
}

function __cloneNodeOutput(value) {
  try {
    return JSON.parse(JSON.stringify(value));
  } catch (error) {
    return value;
  }
}

function __storeNodeOutput(nodeId, output) {
  if (!nodeId) {
    return;
  }
  __nodeOutputs[nodeId] = __cloneNodeOutput(output);
}

function __initExecutionFlags() {
  __executionFlags = {};
}

function __activateNode(nodeId) {
  if (!nodeId) {
    return;
  }
  __executionFlags[nodeId] = true;
}

function __completeNode(nodeId) {
  if (!nodeId) {
    return;
  }
  __executionFlags[nodeId] = false;
}

function __shouldExecute(nodeId) {
  return Boolean(__executionFlags[nodeId]);
}

function __bootstrapExecution() {
  __initExecutionFlags();
  var roots = ["schedule-trigger"];
  for (var i = 0; i < roots.length; i++) {
    __activateNode(roots[i]);
  }
}

function __normalizeRefPath(path) {
  if (!path || path === '$') {
    return '';
  }
  if (path.indexOf('$.') === 0) {
    return path.slice(2);
  }
  if (path.charAt(0) === '$') {
    return path.slice(1);
  }
  return path;
}

function __getNodeOutputValue(nodeId, path) {
  var output = __nodeOutputs[nodeId];
  if (typeof output === 'undefined') {
    return undefined;
  }
  var normalized = __normalizeRefPath(path);
  if (!normalized) {
    return output;
  }
  var segments = normalized.split('.');
  var value = output;
  for (var i = 0; i < segments.length; i++) {
    var key = segments[i];
    if (value == null) {
      return undefined;
    }
    if (Array.isArray(value)) {
      var index = Number(key);
      if (!isNaN(index)) {
        value = value[index];
        continue;
      }
    }
    value = value[key];
  }
  return value;
}

function interpolate(t, ctx) {
  return String(t).replace(/{{(.*?)}}/g, function(_, k) { return ctx[k.trim()] ?? ''; });
}

function main(ctx) {
  ctx = ctx || {};
  __resetNodeOutputs();
  __bootstrapExecution();
  console.log('🚀 Starting workflow with ${allNodes.length} steps (${supportedNodes.length} native, ${unsupportedNodes.length} fallback)...');

  if (__shouldExecute('schedule-trigger')) {
    ctx = step_schedule(ctx);
    __storeNodeOutput('schedule-trigger', ctx);
    __completeNode('schedule-trigger');
    __activateNode('asana-task');
  }


  if (__shouldExecute('asana-task')) {
    ctx = step_create_task(ctx);
    __storeNodeOutput('asana-task', ctx);
    __completeNode('asana-task');
    __activateNode('task-check');
  }


  if (__shouldExecute('task-check')) {
    var __conditionState = step_asana_success(ctx);
    var __conditionOutput = (__conditionState && __conditionState.output) || {};
    ctx = (__conditionState && __conditionState.context) || ctx;
    __conditionOutput.availableBranches = [{"edgeId":"edge-condition-success","targetId":"cooldown-delay","label":"cooldown","value":"true","isDefault":false},{"edgeId":"edge-condition-failure","targetId":"mailchimp-fallback","label":"fallback","value":"false","isDefault":false}];
    __storeNodeOutput('task-check', __conditionOutput);
    __completeNode('task-check');
    ctx.__lastCondition = __conditionOutput;
    var __branchMap = [{"edgeId":"edge-condition-success","targetId":"cooldown-delay","label":"cooldown","value":"true","isDefault":false},{"edgeId":"edge-condition-failure","targetId":"mailchimp-fallback","label":"fallback","value":"false","isDefault":false}];
    var __matched = false;
    var __branchValue = __conditionOutput.matchedBranch;
    for (var i = 0; i < __branchMap.length; i++) {
      var __branch = __branchMap[i];
      if (__branch.value && __branch.value === __branchValue) {
        __activateNode(__branch.targetId);
        __conditionOutput.selectedEdgeId = __branch.edgeId;
        __conditionOutput.selectedTargetId = __branch.targetId;
        __matched = true;
      }
    }
    if (!__matched) {
      for (var j = 0; j < __branchMap.length; j++) {
        var __fallback = __branchMap[j];
        if (__fallback.isDefault) {
          __activateNode(__fallback.targetId);
          __conditionOutput.selectedEdgeId = __fallback.edgeId;
          __conditionOutput.selectedTargetId = __fallback.targetId;
          __conditionOutput.matchedBranch = __fallback.value;
          __matched = true;
          break;
        }
      }
    }
    if (!__matched && __branchMap.length === 1) {
      var __single = __branchMap[0];
      __activateNode(__single.targetId);
      __conditionOutput.selectedEdgeId = __single.edgeId;
      __conditionOutput.selectedTargetId = __single.targetId;
      __conditionOutput.matchedBranch = __single.value;
    }
  }


  if (__shouldExecute('cooldown-delay')) {
    ctx = step_delay(ctx);
    __storeNodeOutput('cooldown-delay', ctx);
    __completeNode('cooldown-delay');
  }


  if (__shouldExecute('mailchimp-fallback')) {
    ctx = step_add_subscriber(ctx);
    __storeNodeOutput('mailchimp-fallback', ctx);
    __completeNode('mailchimp-fallback');
  }

  return ctx;
}


function scheduledTrigger() {
  return buildPollingWrapper('trigger.time:schedule', function (runtime) {
    var frequency = '24';
    var unit = 'hours';
    var triggerTime = new Date().toISOString();

    logInfo('time_trigger_fired', { frequency: frequency, unit: unit, triggerTime: triggerTime });
    runtime.summary({ frequency: frequency, unit: unit, triggerTime: triggerTime });
    runtime.dispatch({ triggerTime: triggerTime, frequency: frequency, unit: unit });
    return { dispatched: 1, triggerTime: triggerTime, frequency: frequency, unit: unit };
  });
}

function step_createAsanaTask(ctx) {
  const accessToken = getSecret('ASANA_ACCESS_TOKEN');

  if (!accessToken) {
    logWarn('asana_missing_access_token', { message: 'Asana access token not configured' });
    return ctx;
  }
  
  const taskData = {
    data: {
      name: interpolate('Compile nightly document digest', ctx),
      notes: interpolate('Generated by Apps Script nightly job', ctx),
      projects: ['123456789'].filter(Boolean)
    }
  };
  
  const response = withRetries(() => fetchJson('https://app.asana.com/api/1.0/tasks', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${accessToken}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(taskData),
    contentType: 'application/json'
  }));

  ctx.asanaTaskId = response.body && response.body.data ? response.body.data.gid : null;
  logInfo('asana_create_task', { taskId: ctx.asanaTaskId || null });
  return ctx;
}

function step_asana_success(ctx) {
  var context = ctx || {};
  var rule = "!!ctx.asanaTaskId";
  var evaluations = [];
  var evaluationError = null;
  var rawValue;

  try {
    if (typeof rule === 'boolean') {
      rawValue = rule;
    } else if (typeof rule === 'number') {
      rawValue = rule !== 0;
    } else if (rule && typeof rule === 'object' && typeof rule.value !== 'undefined') {
      rawValue = rule.value;
    } else if (typeof rule === 'string' && rule.trim().length > 0) {
      var sandbox = Object.assign({}, context, {
        params: context,
        parameters: context,
        data: context,
        nodes: __nodeOutputs,
        nodeOutputs: __nodeOutputs
      });
      try {
        rawValue = Function('scope', 'nodeOutputs', 'with(scope) { return (function() { return eval(arguments[0]); }).call(scope, arguments[2]); }')(sandbox, __nodeOutputs, rule);
      } catch (innerError) {
        evaluationError = innerError && innerError.message ? innerError.message : String(innerError);
      }
    } else {
      rawValue = false;
    }
  } catch (error) {
    evaluationError = error && error.message ? error.message : String(error);
  }

  if (typeof rawValue === 'undefined') {
    rawValue = false;
  }

  var resultValue = Boolean(rawValue);
  var matchedBranch = resultValue ? 'true' : 'false';
  evaluations.push({ expression: rule, raw: rawValue, result: resultValue, error: evaluationError });

  var output = {
    expression: rule,
    evaluations: evaluations,
    matchedBranch: matchedBranch,
    availableBranches: [{"edgeId":"edge-condition-success","targetId":"cooldown-delay","label":"cooldown","value":"true","isDefault":false},{"edgeId":"edge-condition-failure","targetId":"mailchimp-fallback","label":"fallback","value":"false","isDefault":false}],
    error: evaluationError
  };

  return { context: context, output: output };
}


function step_delay(ctx) {
  // P0 CRITICAL FIX: Don't use Utilities.sleep for long delays (Apps Script 6min limit)
  const hours = 1;

  if (hours > 0.1) { // More than 6 minutes
    const contextKey = 'delayed_context_' + Utilities.getUuid();
    const scriptProps = PropertiesService.getScriptProperties();
    scriptProps.setProperty(contextKey, JSON.stringify(ctx));

    const triggerTime = new Date(Date.now() + (hours * 60 * 60 * 1000));
    buildTimeTrigger({
      handler: 'executeDelayedContext',
      key: 'delay:' + contextKey,
      runAt: triggerTime.toISOString(),
      description: 'delayed_execution_' + hours + '_hours',
      ephemeral: true
    });

    scriptProps.setProperty('trigger_context', contextKey);
    logInfo('delay_trigger_scheduled', { contextKey: contextKey, triggerTime: triggerTime.toISOString(), hours: hours });
    return ctx;
  } else {
    // CRITICAL FIX: NEVER use Utilities.sleep - always use triggers for safety
    logInfo('delay_trigger_short', { hours: hours });

    const contextKey = 'delayed_context_' + Utilities.getUuid();
    const scriptProps = PropertiesService.getScriptProperties();
    scriptProps.setProperty(contextKey, JSON.stringify(ctx));

    const delayMs = Math.max(hours * 60 * 60 * 1000, 60000);
    const triggerTime = new Date(Date.now() + delayMs);

    buildTimeTrigger({
      handler: 'executeDelayedContext',
      key: 'delay:' + contextKey,
      runAt: triggerTime.toISOString(),
      description: 'delayed_execution_short_' + delayMs,
      ephemeral: true
    });

    scriptProps.setProperties({
      'trigger_context': contextKey,
      'short_delay_trigger': 'true'
    });

    logInfo('delay_trigger_scheduled', { contextKey: contextKey, triggerTime: triggerTime.toISOString(), delayMs: delayMs });
    return ctx;
  }
}

// Handler for delayed execution
function executeDelayedContext() {
  return buildPollingWrapper('action.time:delay.execute', function (runtime) {
    const scriptProps = PropertiesService.getScriptProperties();
    const contextKey = scriptProps.getProperty('trigger_context');

    if (!contextKey) {
      runtime.summary({ skipped: true, reason: 'missing_trigger_context' });
      return { skipped: true, reason: 'missing_trigger_context' };
    }

    const savedContext = scriptProps.getProperty(contextKey);
    if (!savedContext) {
      scriptProps.deleteProperty('trigger_context');
      runtime.summary({ skipped: true, reason: 'missing_saved_context', contextKey: contextKey });
      return { skipped: true, reason: 'missing_saved_context', contextKey: contextKey };
    }

    const ctx = JSON.parse(savedContext);
    scriptProps.deleteProperty(contextKey);
    scriptProps.deleteProperty('trigger_context');
    scriptProps.deleteProperty('short_delay_trigger');

    logInfo('delay_trigger_execute', { contextKey: contextKey });
    runtime.dispatch(ctx);
    return { resumed: true, contextKey: contextKey };
  });
}

function step_addMailchimpSubscriber(ctx) {
  const apiKey = getSecret('MAILCHIMP_API_KEY');
  const listId = getSecret('MAILCHIMP_LIST_ID');
  const datacenter = apiKey ? apiKey.split('-')[1] : '';

  if (!apiKey || !listId) {
    logWarn('mailchimp_missing_credentials', { message: 'Mailchimp credentials not configured' });
    return ctx;
  }
  
  const memberData = {
    email_address: interpolate('{{input.email}}', ctx),
    status: 'pending',
    merge_fields: {
      FNAME: interpolate('{{input.first_name}}', ctx),
      LNAME: interpolate('{{input.last_name}}', ctx)
    }
  };
  
  const response = withRetries(() => fetchJson(`https://${datacenter}.api.mailchimp.com/3.0/lists/${listId}/members`, {
    method: 'POST',
    headers: {
      'Authorization': `Basic ${Utilities.base64Encode('anystring:' + apiKey)}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(memberData),
    contentType: 'application/json'
  }));

  ctx.mailchimpMemberId = response.body && response.body.id;
  logInfo('mailchimp_add_subscriber', { memberId: ctx.mailchimpMemberId || null });
  return ctx;
}


function setupTriggers() {
  var activeKeys = [];
  function track(entry) {
    if (entry && entry.key) {
      activeKeys.push(entry.key);
    }
  }
  track(buildTimeTrigger({
    handler: 'main',
    key: 'time:schedule-trigger:24:0900',
    frequency: '24',
    description: '24 schedule @ 09:00',
    everyDays: 1,
    atHour: 9,
    nearMinute: 0
  }));
  syncTriggerRegistry(activeKeys);
}


function registerMailchimpWebhook(callbackUrl, options) {
  logInfo('webhook_register_stub', { connector: 'mailchimp', name: 'Mailchimp', callbackUrl: callbackUrl || null });
  return {
    status: 'stub',
    connector: 'mailchimp',
    name: 'Mailchimp',
    callbackUrl: callbackUrl || null,
    options: options || null
  };
}

function unregisterMailchimpWebhook(webhookId) {
  logInfo('webhook_unregister_stub', { connector: 'mailchimp', name: 'Mailchimp', webhookId: webhookId || null });
  return {
    status: 'stub',
    connector: 'mailchimp',
    name: 'Mailchimp',
    webhookId: webhookId || null
  };
}



async function executeTime:schedule(params) {
  console.log('⏰ Executing Time trigger: Nightly schedule');
  
  const frequency = params.frequency || 'daily';
  const time = params.time || '09:00';
  
  try {
    const now = new Date();
    const [hours, minutes] = time.split(':').map(Number);
    
    console.log(`⏰ Time trigger executed at ${now.toISOString()}`);
    console.log(`📅 Schedule: ${frequency} at ${time}`);
    
    return { 
      triggerTime: now.toISOString(),
      frequency,
      scheduledTime: time,
      message: `Workflow triggered by ${frequency} schedule at ${time}`
    };
    
  } catch (error) {
    console.error('❌ Time trigger failed:', error);
    throw error;
  }
}


async function executeAsana:create_task(inputData, params) {
  console.log('🔧 Executing Create documentation task');
  console.log('📥 Input:', inputData);
  console.log('⚙️ Params:', params);
  
  // TODO: Implement action.asana:create_task execution logic
  return { ...inputData, action_asana:create_task: 'executed' };
}


async function executeBranch:asana_success(inputData, params) {
  console.log('🔧 Executing System action: Did Asana issue an ID?');
  
  const message = params.message || 'Workflow executed';
  const level = params.level || 'info';
  
  try {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      inputData: Object.keys(inputData),
      nodeType: 'condition.branch'
    };
    
    // Log to Apps Script console
    if (level === 'error') {
      console.error(`[SYSTEM] ${message}`);
    } else if (level === 'warn') {
      console.warn(`[SYSTEM] ${message}`);
    } else {
      console.log(`[SYSTEM] ${message}`);
    }
    
    // Store in PropertiesService for audit trail
    const logs = getSecret('WORKFLOW_LOGS', { defaultValue: '[]' });
    const logArray = JSON.parse(logs);
    logArray.push(logEntry);
    
    // Keep only last 100 logs
    if (logArray.length > 100) {
      logArray.splice(0, logArray.length - 100);
    }
    
    PropertiesService.getScriptProperties().setProperty('WORKFLOW_LOGS', JSON.stringify(logArray));
    
    console.log(`✅ System action completed: ${message}`);
    return { ...inputData, systemLogged: true, logEntry };
    
  } catch (error) {
    console.error('❌ System action failed:', error);
    return { ...inputData, systemError: error.message };
  }
}


async function executeTime:delay(params) {
  console.log('⏰ Executing Time trigger: Throttle API activity');
  
  const frequency = params.frequency || 'daily';
  const time = params.time || '09:00';
  
  try {
    const now = new Date();
    const [hours, minutes] = time.split(':').map(Number);
    
    console.log(`⏰ Time trigger executed at ${now.toISOString()}`);
    console.log(`📅 Schedule: ${frequency} at ${time}`);
    
    return { 
      triggerTime: now.toISOString(),
      frequency,
      scheduledTime: time,
      message: `Workflow triggered by ${frequency} schedule at ${time}`
    };
    
  } catch (error) {
    console.error('❌ Time trigger failed:', error);
    throw error;
  }
}


function executeMailchimp:add_subscriber(inputData, params) {
  console.log('📧 Executing Mailchimp: Tag contact for manual follow-up');
  
  const operation = params.operation || 'mailchimp:add_subscriber';
  const apiKey = getSecret('MAILCHIMP_API_KEY');
  
  if (!apiKey) {
    console.warn('⚠️ Mailchimp API key not configured');
    return { ...inputData, mailchimpSkipped: true, error: 'Missing API key' };
  }
  
  try {
    const datacenter = apiKey.split('-')[1];
    const baseUrl = `https://${datacenter}.api.mailchimp.com/3.0`;
    
    switch (operation) {
      case 'add_subscriber':
      case 'create_member':
        return handleAddSubscriber(baseUrl, apiKey, params, inputData);
      case 'update_subscriber':
        return handleUpdateSubscriber(baseUrl, apiKey, params, inputData);
      case 'get_subscriber':
        return handleGetSubscriber(baseUrl, apiKey, params, inputData);
      case 'remove_subscriber':
        return handleRemoveSubscriber(baseUrl, apiKey, params, inputData);
      case 'get_lists':
      case 'list_audiences':
        return handleGetLists(baseUrl, apiKey, params, inputData);
      case 'create_campaign':
        return handleCreateCampaign(baseUrl, apiKey, params, inputData);
      case 'send_campaign':
        return handleSendCampaign(baseUrl, apiKey, params, inputData);
      case 'test_connection':
        return handleMailchimpTestConnection(baseUrl, apiKey, params, inputData);
      case 'subscriber_added':
      case 'campaign_sent':
        return handleMailchimpTrigger(baseUrl, apiKey, params, inputData);
      default:
        console.warn(`⚠️ Unknown Mailchimp operation: ${operation}`);
        return { ...inputData, mailchimpWarning: `Unsupported operation: ${operation}` };
    }
    
  } catch (error) {
    console.error(`❌ Mailchimp ${operation} failed:`, error);
    return { ...inputData, mailchimpError: error.toString(), mailchimpSuccess: false };
  }
}

function handleAddSubscriber(baseUrl, apiKey, params, inputData) {
  const listId = params.listId || params.list_id || params.audienceId;
  const email = params.email || inputData.email;
  
  if (!listId || !email) {
    throw new Error('List ID and email are required');
  }
  
  const subscriberData = {
    email_address: email,
    status: params.status || 'subscribed',
    merge_fields: {
      FNAME: params.firstName || params.first_name || inputData.firstName || inputData.first_name || '',
      LNAME: params.lastName || params.last_name || inputData.lastName || inputData.last_name || ''
    },
    interests: params.interests || {},
    tags: params.tags ? (Array.isArray(params.tags) ? params.tags : params.tags.split(',')) : []
  };
  
  const response = UrlFetchApp.fetch(`${baseUrl}/lists/${listId}/members`, {
    method: 'POST',
    headers: {
      'Authorization': `apikey ${apiKey}`,
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(subscriberData)
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(`✅ Added subscriber to Mailchimp: ${email}`);
    return { ...inputData, mailchimpSubscribed: true, subscriberId: data.id, email: email };
  } else {
    throw new Error(`Add subscriber failed: ${response.getResponseCode()}`);
  }
}

function handleGetLists(baseUrl, apiKey, params, inputData) {
  const count = params.count || params.limit || 10;
  
  const response = UrlFetchApp.fetch(`${baseUrl}/lists?count=${count}`, {
    method: 'GET',
    headers: {
      'Authorization': `apikey ${apiKey}`
    }
  });
  
  if (response.getResponseCode() === 200) {
    const data = JSON.parse(response.getContentText());
    console.log(`✅ Retrieved ${data.lists.length} Mailchimp lists`);
    return { ...inputData, mailchimpLists: data.lists, listCount: data.lists.length };
  } else {
    throw new Error(`Get lists failed: ${response.getResponseCode()}`);
  }
}

function handleMailchimpTestConnection(baseUrl, apiKey, params, inputData) {
  try {
    const response = UrlFetchApp.fetch(`${baseUrl}/ping`, {
      method: 'GET',
      headers: {
        'Authorization': `apikey ${apiKey}`
      }
    });
    
    if (response.getResponseCode() === 200) {
      const data = JSON.parse(response.getContentText());
      console.log(`✅ Mailchimp connection test successful. Account: ${data.account_name}`);
      return { ...inputData, connectionTest: 'success', accountName: data.account_name };
    } else {
      throw new Error(`Test failed: ${response.getResponseCode()}`);
    }
  } catch (error) {
    console.error('❌ Mailchimp connection test failed:', error);
    return { ...inputData, connectionTest: 'failed', error: error.toString() };
  }
}