import { appsScriptHttpHelpers, REAL_OPS } from '../compile-to-appsscript';

describe('appsScriptHttpHelpers', () => {
  it('emits the shared helper module', () => {
    const helpers = appsScriptHttpHelpers();
    expect(helpers).toContain('function withRetries');
    expect(helpers).toContain('function fetchJson');
    expect(helpers.trim()).toMatchInlineSnapshot(`
"var __HTTP_RETRY_DEFAULTS = {\n  maxAttempts: 5,\n  initialDelayMs: 500,\n  backoffFactor: 2,\n  maxDelayMs: 60000\n};\n\nfunction logStructured(level, event, details) {\n  var payload = {\n    level: level,\n    event: event,\n    details: details || {},\n    timestamp: new Date().toISOString()\n  };\n  var message = '[' + payload.level + '] ' + payload.event + ' ' + JSON.stringify(payload.details);\n  if (level === 'ERROR') {\n    console.error(message);\n  } else if (level === 'WARN') {\n    console.warn(message);\n  } else {\n    console.log(message);\n  }\n}\n\nfunction logInfo(event, details) {\n  logStructured('INFO', event, details);\n}\n\nfunction logWarn(event, details) {\n  logStructured('WARN', event, details);\n}\n\nfunction logError(event, details) {\n  logStructured('ERROR', event, details);\n}\n\nfunction withRetries(fn, options) {\n  var config = options || {};\n  var maxAttempts = config.maxAttempts || __HTTP_RETRY_DEFAULTS.maxAttempts;\n  var initialDelayMs = config.initialDelayMs || __HTTP_RETRY_DEFAULTS.initialDelayMs;\n  var backoffFactor = config.backoffFactor || __HTTP_RETRY_DEFAULTS.backoffFactor;\n  var maxDelayMs = config.maxDelayMs || __HTTP_RETRY_DEFAULTS.maxDelayMs;\n  var attempt = 0;\n  var delay = initialDelayMs;\n\n  while (true) {\n    try {\n      return fn(attempt + 1);\n    } catch (error) {\n      attempt++;\n      var message = error && error.message ? error.message : String(error);\n      if (attempt >= maxAttempts) {\n        logError('http_retry_exhausted', { attempts: attempt, message: message });\n        throw error;\n      }\n      logWarn('http_retry', { attempt: attempt, delayMs: delay, message: message });\n      Utilities.sleep(delay);\n      delay = Math.min(delay * backoffFactor, maxDelayMs);\n    }\n  }\n}\n\nfunction fetchJson(url, requestOptions) {\n  var options = requestOptions || {};\n  var method = options.method || 'GET';\n  var headers = options.headers || {};\n  var payload = options.payload;\n  var contentType = options.contentType || options['contentType'];\n  var muteHttpExceptions = options.muteHttpExceptions !== undefined ? options.muteHttpExceptions : true;\n  var followRedirects = options.followRedirects;\n  var start = new Date().getTime();\n\n  var fetchOptions = {\n    method: method,\n    headers: headers,\n    muteHttpExceptions: muteHttpExceptions\n  };\n\n  if (typeof payload !== 'undefined') {\n    fetchOptions.payload = payload;\n  }\n\n  if (typeof contentType !== 'undefined') {\n    fetchOptions.contentType = contentType;\n  }\n\n  if (typeof followRedirects !== 'undefined') {\n    fetchOptions.followRedirects = followRedirects;\n  }\n\n  if (options.escape !== undefined) {\n    fetchOptions.escape = options.escape;\n  }\n\n  var response = UrlFetchApp.fetch(url, fetchOptions);\n  var durationMs = new Date().getTime() - start;\n  var status = response.getResponseCode();\n  var text = response.getContentText();\n  var allHeaders = response.getAllHeaders();\n  var success = status >= 200 && status < 300;\n\n  var logDetails = {\n    url: url,\n    method: method,\n    status: status,\n    durationMs: durationMs\n  };\n\n  if (!success) {\n    logDetails.response = text;\n  }\n\n  logStructured(success ? 'INFO' : 'ERROR', success ? 'http_success' : 'http_failure', logDetails);\n\n  var responseContentType = '';\n  if (allHeaders['Content-Type']) {\n    responseContentType = String(allHeaders['Content-Type']).toLowerCase();\n  } else if (allHeaders['content-type']) {\n    responseContentType = String(allHeaders['content-type']).toLowerCase();\n  }\n\n  var body = text;\n  if (responseContentType.indexOf('application/json') !== -1) {\n    try {\n      body = text ? JSON.parse(text) : null;\n    } catch (error) {\n      logWarn('http_parse_failure', { url: url, message: error && error.message ? error.message : String(error) });\n    }\n  }\n\n  if (!success) {\n    var err = new Error('Request failed with status ' + status);\n    var errorWithDetails = err;\n    errorWithDetails.status = status;\n    errorWithDetails.body = body;\n    errorWithDetails.text = text;\n    errorWithDetails.headers = allHeaders;\n    throw errorWithDetails;\n  }\n\n  return {\n    ok: success,\n    status: status,\n    headers: allHeaders,\n    body: body,\n    text: text\n  };\n}"
`);
  });
});

describe('REAL_OPS HTTP snippets', () => {
  it('wraps Slack webhook operations with retries and logging', () => {
    expect(REAL_OPS['action.slack:send_message']({})).toMatchInlineSnapshot(`\n"function step_sendSlackMessage(ctx) {\n  const webhookUrl = PropertiesService.getScriptProperties().getProperty('SLACK_WEBHOOK_URL');\n  if (!webhookUrl) {\n    logWarn('slack_missing_webhook', { message: 'Slack webhook URL not configured' });\n    return ctx;\n  }\n\n  const message = interpolate('Automated notification', ctx);\n  const channel = '#general';\n\n  const payload = {\n    channel: channel,\n    text: message,\n    username: 'Apps Script Bot'\n  };\n\n  withRetries(() => fetchJson(webhookUrl, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    payload: JSON.stringify(payload),\n    contentType: 'application/json'\n  }));\n\n  logInfo('slack_message_sent', { channel: channel });\n\n  return ctx;\n}"\n`);
  });

  it('wraps Salesforce lead creation with helpers', () => {
    expect(REAL_OPS['action.salesforce:create_lead']({})).toMatchInlineSnapshot(`\n"function step_createSalesforceLead(ctx) {\n  const accessToken = PropertiesService.getScriptProperties().getProperty('SALESFORCE_ACCESS_TOKEN');\n  const instanceUrl = PropertiesService.getScriptProperties().getProperty('SALESFORCE_INSTANCE_URL');\n\n  if (!accessToken || !instanceUrl) {\n    logWarn('salesforce_missing_credentials', { message: 'Salesforce credentials not configured' });\n    return ctx;\n  }\n\n  const leadData = {\n    FirstName: interpolate('{{first_name}}', ctx),\n    LastName: interpolate('{{last_name}}', ctx),\n    Email: interpolate('{{email}}', ctx),\n    Company: interpolate('{{company}}', ctx)\n  };\n\n  const response = withRetries(() => fetchJson(`${instanceUrl}/services/data/v52.0/sobjects/Lead`, {\n    method: 'POST',\n    headers: {\n      'Authorization': `Bearer ${accessToken}`,\n      'Content-Type': 'application/json'\n    },\n    payload: JSON.stringify(leadData),\n    contentType: 'application/json'\n  }));\n\n  ctx.salesforceLeadId = response.body && response.body.id;\n  logInfo('salesforce_create_lead', { leadId: ctx.salesforceLeadId || null });\n  return ctx;\n}"\n`);
  });
});
