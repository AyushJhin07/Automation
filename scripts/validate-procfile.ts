import { readFileSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';

const currentDir = fileURLToPath(new URL('.', import.meta.url));
const repoRoot = join(currentDir, '..');

function readJSON(path: string) {
  const contents = readFileSync(path, 'utf8');
  return JSON.parse(contents);
}

function parseProcfile(path: string) {
  const raw = readFileSync(path, 'utf8');
  return raw
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0 && !line.startsWith('#'))
    .map((line) => {
      const colon = line.indexOf(':');
      if (colon === -1) {
        throw new Error(`Invalid Procfile entry (missing ':' separator): ${line}`);
      }
      const type = line.slice(0, colon).trim();
      const command = line.slice(colon + 1).trim();
      return { type, command };
    });
}

function extractEntryPoints(buildCommand: string) {
  const buildMatch = buildCommand.match(/esbuild\s+(.+?)\s+--/s);
  if (!buildMatch) {
    throw new Error('Unable to locate entrypoints in build:server command');
  }
  return buildMatch[1]
    .split(/\s+/)
    .map((entry) => entry.trim())
    .filter((entry) => entry.length > 0);
}

function toDistPath(entry: string) {
  if (!entry.startsWith('server/')) {
    return null;
  }
  const withoutExt = entry.replace(/\.ts$/, '');
  return withoutExt.replace(/^server\//, 'dist/') + '.js';
}

function main() {
  const packageJsonPath = join(repoRoot, 'package.json');
  const procfilePath = join(repoRoot, 'Procfile');

  const pkg = readJSON(packageJsonPath);
  const buildServerScript = pkg?.scripts?.['build:server'];
  if (typeof buildServerScript !== 'string' || buildServerScript.length === 0) {
    throw new Error('package.json is missing a build:server script.');
  }

  const procEntries = parseProcfile(procfilePath);
  if (procEntries.length === 0) {
    throw new Error('Procfile does not contain any process definitions.');
  }

  const entryPoints = extractEntryPoints(buildServerScript);
  const expectedTargets = entryPoints
    .map(toDistPath)
    .filter((value): value is string => value !== null);

  const uniqueTargets = Array.from(new Set(expectedTargets));

  const missingTargets: string[] = [];
  for (const target of uniqueTargets) {
    const hasMatch = procEntries.some(({ command }) => command.includes(target));
    if (!hasMatch) {
      missingTargets.push(target);
    }
  }

  const procTargets = procEntries
    .map(({ command }) => {
      const match = command.match(/dist\/[\w/-]+\.js/);
      return match?.[0] ?? null;
    })
    .filter((value): value is string => value !== null);

  const unexpectedTargets = procTargets.filter((target) => !uniqueTargets.includes(target));

  if (missingTargets.length > 0 || unexpectedTargets.length > 0) {
    if (missingTargets.length > 0) {
      console.error('Procfile is missing targets generated by build:server:', missingTargets);
    }
    if (unexpectedTargets.length > 0) {
      console.error('Procfile lists targets not bundled by build:server:', unexpectedTargets);
    }
    process.exit(1);
  }

  console.log('Procfile manifest is in sync with build:server entrypoints.');
}

main();
