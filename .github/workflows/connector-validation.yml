name: Connector Metadata

on:
  push:
    branches: [ main ]
    paths:
      - 'connectors/**'
      - 'scripts/validate-connectors.ts'
      - 'scripts/validate-connector-ops.ts'
      - 'shared/runtimes.ts'
      - 'package.json'
      - 'package-lock.json'
      - '.github/workflows/connector-validation.yml'
      - 'docs/connectors/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'connectors/**'
      - 'scripts/validate-connectors.ts'
      - 'scripts/validate-connector-ops.ts'
      - 'shared/runtimes.ts'
      - 'package.json'
      - 'package-lock.json'
      - '.github/workflows/connector-validation.yml'
      - 'docs/connectors/**'

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - run: npm install

      - name: Validate connector schemas
        run: npm run check:connectors

      - name: Verify Apps Script backlog sync
        run: npm run check:apps-script-backlog

      - name: Generate Apps Script coverage report
        run: npm run report:apps-script-coverage

      - name: Upload Apps Script coverage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: apps-script-coverage
          path: |
            production/reports/apps-script-runtime-coverage.csv
            production/reports/apps-script-runtime-coverage.json

      - name: Comment Apps Script coverage summary
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const core = require('@actions/core');
            const fs = require('fs/promises');
            const path = require('path');

            const summaryPath = path.join(process.env.GITHUB_WORKSPACE ?? '.', 'production', 'reports', 'apps-script-runtime-coverage.json');
            const summary = JSON.parse(await fs.readFile(summaryPath, 'utf8'));

            let baseSummary = null;
            const baseSha = context.payload.pull_request?.base?.sha;
            if (baseSha) {
              try {
                const { data } = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: 'production/reports/apps-script-runtime-coverage.json',
                  ref: baseSha,
                });
                if (!Array.isArray(data) && data.content) {
                  const decoded = Buffer.from(data.content, data.encoding).toString('utf8');
                  baseSummary = JSON.parse(decoded);
                }
              } catch (error) {
                core.warning(`Unable to load base Apps Script coverage report: ${error.message}`);
              }
            }

            const formatPercent = value => `${(value * 100).toFixed(2)}%`;
            const formatSigned = value => (value > 0 ? `+${value}` : value < 0 ? `${value}` : '0');
            const formatDelta = (count, ratio) =>
              baseSummary
                ? `${formatSigned(count)} / ${(ratio >= 0 ? '+' : '') + (ratio * 100).toFixed(2)}%`
                : 'n/a';

            const currentOps = summary.coverage.operations;
            const baseOps = baseSummary?.coverage?.operations;
            const opsDeltaCount = baseOps ? currentOps.enabled - baseOps.enabled : 0;
            const opsDeltaRatio = baseOps ? currentOps.ratio - baseOps.ratio : 0;

            const currentConnectors = summary.coverage.connectors;
            const baseConnectors = baseSummary?.coverage?.connectors;
            const connectorDeltaCount = baseConnectors ? currentConnectors.full - baseConnectors.full : 0;
            const connectorDeltaRatio = baseConnectors ? currentConnectors.ratio - baseConnectors.ratio : 0;

            const metricsTable = [
              '| Metric | Current | Δ vs. base |',
              '| --- | --- | --- |',
              `| Operations covered | ${currentOps.enabled} / ${currentOps.total} (${formatPercent(currentOps.ratio)}) | ${formatDelta(opsDeltaCount, opsDeltaRatio)} |`,
              `| Full-coverage connectors | ${currentConnectors.full} / ${currentConnectors.total} (${formatPercent(currentConnectors.ratio)}) | ${formatDelta(connectorDeltaCount, connectorDeltaRatio)} |`,
              `| Coverage target | ${formatPercent(summary.target)} | — |`,
            ].join('\n');

            let gapsSection = '_All connectors currently have full Apps Script coverage._';
            if (summary.gaps.length > 0) {
              const rows = summary.gaps
                .slice(0, 10)
                .map(gap => `| ${gap.app} | ${gap.appsScriptEnabled} / ${gap.totalOperations} |`);
              const header = ['| Connector | Enabled Ops |', '| --- | --- |'];
              gapsSection = [
                '**Connectors missing full Apps Script coverage**',
                '',
                [...header, ...rows].join('\n'),
              ].join('\n');
              if (summary.gaps.length > rows.length) {
                gapsSection += `\n...and ${summary.gaps.length - rows.length} more.`;
              }
            }

            const commentBody = [
              '## Apps Script Coverage Report',
              '',
              metricsTable,
              '',
              gapsSection,
            ].join('\n');

            const issueNumber = context.payload.pull_request.number;
            const existingComments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              per_page: 100,
            });

            const previous = existingComments.find(comment =>
              comment.user?.login === 'github-actions[bot]' && comment.body?.includes('## Apps Script Coverage Report'),
            );

            if (previous) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: previous.id,
                body: commentBody,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: commentBody,
              });
            }
